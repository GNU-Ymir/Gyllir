in formatter;

use std::{io, stream, algorithm::searching};

/**
 * Format a text and write it in 'stream'
 * @params: 
 *   - stream: the stream to fill
 *   - content: the content to format
 *   - values: the values to use during the formatting
 */
pub fn format (dmut stream : &StringStream, content : [c8], values : [[c8] => [c8]]) {
    let mut rest = content;
    while rest.len != 0us {
        let (beg, form, rest_) = findNext (rest);
        stream:.write (beg);
        if (form.len != 0us) {
            if let Ok (x) = values [form] {
                stream:.write (x);
            }
        }

        rest = rest_;
    }        
}

/**
 * Format git url that can be in ssh format to http format
 * */
pub fn formatGitUrl (url : [c8], version : [c8] = "main")-> [c8] {
    if url.len >= 8 && url [0 .. 4] == "git@" && url [$ - 4 .. $] == ".git" {
        if let Ok (n) = find (url, ':') {
            let rootUrl = url [4 .. n];
            return "https://" ~ rootUrl ~ "/" ~ url [n + 1 .. $ - 4] ~ "/tree/" ~ strip (version) ~ "/src/";
        }
    }

    url ~ "/src/"
}

/**
 * Find the next format
 * @params: 
 *    - content: the content of the string 
 * @returns:
 *    - .0: the text before the format
 *    - .1: the format content
 *    - .2: the text after the format 
 */
prv fn findNext (content : [c8]) -> ([c8], [c8], [c8]) {
    let mut i = 0us;
    if (content.len <= 3) return (content, "", "");

    while i < content.len - 3 { // format is at least $()
        if content [i .. i + 2] == "$(" {
            let mut j = i + 1us, mut nb_close = 0;
            while j < content.len - 1us {
                if (content[j] == ')'c8) nb_close -= 1;
                else if (content[j] == '('c8) nb_close += 1;
                if (nb_close == 0) break;
                j += 1us;
            }

            if (nb_close == 0) {
                let form = content [i + 2us .. j];
                let start = content [0us .. i];
                let rest = content [j + 1us .. $];

                return (start, form, rest);
            }                
        }
        i += 1us;
    }

    return (content, "", "");
}


fn strip (str : [c8])-> [c8] {
    let mut start = 0us, mut end = str.len;
    let mut started = false;

    for i, j in str {
        if !std::char::isWhite (j) {
            if (!started) { started = true; start = i; }
            else { end = i + 1; }
        }
    }

    str [start .. end]
}
