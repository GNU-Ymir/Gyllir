in body;

use std::{stream,
          format,
          conv, fs::path};

use gyllir::doc::{_, symbols::_, types::_, comment::parser};
use gyllir::repo::defaults;

/**
 * Html body of a page 
 */
@final
pub class HtmlBody over HtmlNode {

    // The module to dump
    let _module : &Module;

    // The name of the project
    let _project : [c8];

    /**
     * @params: 
     *    - project: the name of the project
     *    - module: the content of the page to dump
     */
    pub self (project : [c8], module : &Module)
        with _project = project, _module = module
    {}
    
    /**
     * Dump the module into a html page
     * @params:
     *    - stream: the stream to populate
     */
    pub over dumpHtml (self, dmut stream : &StringStream) {
        let content = copy ["Content" => self.dumpCommonSymbol (self._module)];
        formatter::format (alias stream, ressources::MODULE_HEAD, content);
        
        for ch in self._module.childs if ch !of Module {
            self.dumpContent (alias stream, ch);
        }
    }

    /**
     * Dump the elements common to all symbols
     * @params:
     *     - s: the symbol to dump
     */
    fn dumpCommonSymbol (self, s : &Symbol)-> [c8] {
        let dmut stream = copy StringStream ();
        let p = copy CommentParser (s.doc);
        stream:.write ("<div class=\"doc\">");
        p.dumpHtml (alias stream);
        stream:.write ("</div>");

        stream[]
    }

    /**
     * Dump a symbol into html
     * @params: 
     *    - stream: the stream to populate
     *    - sym: the symbol to dump
     */
    fn dumpContent (self, dmut stream : &StringStream, sym : &Symbol, templates : [&TemplateParam] = [], templateTest : [c8] = []) {
        stream;
        sym;
        templates;
        templateTest;

        match sym {
            a : &Aka        => self.dumpAka (alias stream, a, templates-> templates, templateTest-> templateTest);
            // c : &Class      => self.dumpClass (alias stream, c, templates-> templates, templateTest-> templateTest);
            // c : &Ctor       => self.dumpCtor (alias stream, c, templates-> templates, templateTest-> templateTest);
            // e : &EnumSymbol => self.dumpEnum (alias stream, e, templates-> templates, templateTest-> templateTest);
            f : &Function   => self.dumpFunction (alias stream, f, templates-> templates, templateTest-> templateTest);
            // g : &Global     => self.dumpGlobal (alias stream, v, templates-> templates, templateTest-> templateTest);
            // m : &Macro      => self.dumpMacro (alias stream, m, templates-> templates, templateTest-> templateTest);
            // m : &Method     => self.dumpMethod (alias stream, m, templates-> templates, templateTest-> templateTest);
            // v : &Variable   => self.dumpVariable (alias stream, m, templates-> templates, templateTest-> templateTest);
            // t : &Trait      => self.dumpTrait (alias stream, t, templates-> templates, templateTest-> templateTest);
            t : &Template => {
                for c in t.inners {
                    self.dumpContent (alias stream, c, templates-> t.params, templateTest-> t.test);
                }
            }
        }
    }

    /**
     * Dump an aka to html
     * @params:
     *    - stream: the stream to populate
     *    - a: the aka to dump
     */
    fn dumpAka (self, dmut stream : &StringStream, a : &Aka, templateTest : [c8] = "", templates : [&TemplateParam] = []) {
        let p = Path (a.name, sep-> "::");
        let dmut innerStream = copy StringStream ();

        let (token, end) = if a.isValue { ("=", a.value) } else { (":", self.dumpType (a.type)) };


        let tempFormat = self.dumpTemplates (templates);
        let tempTest = self.dumpTemplateTest (templateTest);

        let code = std::format::format ("{} def {}{}{} {} {}",
                                        self.dumpProtection (a.protect),
                                        tempTest,
                                        p.file (),
                                        tempFormat,
                                        token, end);

        formatter::format (alias innerStream, ressources::INLINE_CODE, copy ["Code" => code]);
        innerStream:.write (self.dumpCommonSymbol (a));

        formatter::format (alias stream, ressources::DECLARATION, copy ["Kind" => "def",
                                                                        "Name" => p.file (),
                                                                        "Templates" => (tempFormat ~ tempTest),
                                                                        "Content" => innerStream[]]);
    } catch {
        _ => {}
    }

    // /**
    //  * Dump an assertion
    //  * @params:
    //  *    - stream: the stream to populate
    //  *    - a: the assertion to dump
    //  */
    // fn dumpAssert (self, dmut stream : &StringStream, a : &Assert) {
    //     let code = if (a.getMessage () != "") {
    //         std::format::format ("assert ({}, {})", a.getTest (), a.getMessage ())
    //     } else {
    //         std::format::format ("assert ({})", a.getTest ())
    //     };

    //     stream:.write (std::format::format (self._inlineCode, code));
    //     self.dumpCommonSymbol (alias stream, a);
    // } catch {
    //     err : _ => {}
    // }


    // /**
    //  * Dump an enumeration
    //  * @params:
    //  *    - stream: the stream to populate
    //  *    - e: the enum to dump
    //  */
    // fn dumpEnum (self, dmut stream : &StringStream, e : &Enum, tempTest : [c8] = "", tempParams : [c8] = "", tempDoc : [c8] = "") {
    //     let p = Path::new (utils::path::toPath (e.getName ()));

    //     let dmut innerStream = StringStream::new ();
    //     let code = std::format::format ("{} enum {}: {} \n| /** full declaration omitted \n-> {}{};",
    //                                     self.convertProtection (e.getProtection ()),
    //                                     tempParams,
    //                                     self.dumpType (e.getType ()),
    //                                     p.file (), tempTest);

    //     innerStream:.write (std::format::format (self._inlineCode, code));
    //     self.dumpCommonSymbol (alias innerStream, e, tempDoc-> tempDoc);

    //     let dmut contentStream = StringStream::new ();
    //     self.dumpFields (alias contentStream, e.getFields ());
    //     innerStream:.write (std::format::format (self._declMembers, contentStream[]));

    //     let tempTestCode = if (tempTest != "") {
    //         std::format::format (" <code class=\"language-ymir hljs\"> if ({}) </code>", tempTest)
    //     } else { "" };


    //     stream:.write (std::format::format (self._declHead,
    //                                         "enum",
    //                                         p.file (),
    //                                         tempParams ~ tempTestCode,
    //                                         innerStream[]));

    // } catch {
    //     _ => {}
    // }


    // /**
    //  * Dump an enumeration
    //  * @params:
    //  *    - stream: the stream to populate
    //  *    - s: the struct to dump
    //  */
    // fn dumpStruct (self, dmut stream : &StringStream, s : &Struct, tempTest : [c8] = "", tempParams : [c8] = "", tempDoc : [c8] = "") {
    //     if (s.getProtection () != Protection::PUB) return {}

    //     let p = Path::new (utils::path::toPath (s.getName ()));

    //     let attrs = self.dumpAttrsStruct (s);
    //     let dmut innerStream = StringStream::new ();
    //     let code = std::format::format ("{}{} struct {}\n| /** full declaration omitted */ \n-> {}{};",
    //                                     self.convertProtection (s.getProtection ()),
    //                                     attrs,
    //                                     tempParams,
    //                                     p.file (), tempTest);

    //     innerStream:.write (std::format::format (self._inlineCode, code));
    //     self.dumpCommonSymbol (alias innerStream, s, tempDoc-> tempDoc);

    //     let dmut contentStream = StringStream::new ();
    //     self.dumpFields (alias contentStream, s.getFields ());
    //     innerStream:.write (std::format::format (self._declMembers, contentStream[]));

    //     let tempTestCode = if (tempTest != "") {
    //         std::format::format (" <code class=\"language-ymir hljs\"> if ({}) </code>", tempTest)
    //     } else { "" };

    //     stream:.write (std::format::format (self._declHead,
    //                                         "struct",
    //                                         p.file (),
    //                                         tempParams ~ tempTestCode,
    //                                         innerStream[]));

    // } catch {
    //     _ => {}
    // }


    // /**
    //  * Dump the attribute of a struct
    //  * @params:
    //  *    - s: the struct which has attributes to dump
    //  * @returns: the string containing the attributes
    //  */
    // fn dumpAttrsStruct (self, s : &Struct)-> [c8] {
    //     let dmut attrs = StringStream::new ();
    //     let mut nb = 0us;
    //     for _, i in s.getAttrs () {
    //         let write = match i {
    //             "union" | "packed" => { true }
    //             _ => { false }
    //         }
    //         if (write) {
    //             if (nb != 0us) attrs:.write (", ");
    //             attrs:.write (i);
    //             nb += 1us;
    //         }
    //     }

    //     if (nb > 1us) {
    //         "@{" ~ attrs[] ~ "}"
    //     } else if nb == 1us {
    //         "@" ~ attrs[]
    //     } else {
    //         ""
    //     }
    // }

    // /**
    //  * Dump a trait to html
    //  * @params:
    //  *   - stream: the stream to populate
    //  *   - t: the trait to dump
    //  */
    // fn dumpTrait (self, dmut stream : &StringStream, t : &Trait, tempTest : [c8] = "", tempParams : [c8] = "", tempDoc : [c8] = "") {
    //     let p = Path::new (utils::path::toPath (t.getName ()));

    //     let dmut innerStream = StringStream::new ();

    //     let code = std::format::format ("{} trait {}{} {} {{ \n\t/** full declaration omitted */ \n}",
    //                                     self.convertProtection (t.getProtection ()),
    //                                     tempTest,
    //                                     p.file (),
    //                                     tempParams);

    //     innerStream:.write (std::format::format (self._inlineCode, code));
    //     self.dumpCommonSymbol (alias innerStream, t, tempDoc-> tempDoc);

    //     let dmut contentStream = StringStream::new ();
    //     for j in t.getChilds () {
    //         self.dumpContent (alias contentStream, j);
    //     }

    //     innerStream:.write (std::format::format (self._declMembers, contentStream[]));


    //     let tempTestCode = if (tempTest != "") {
    //         std::format::format (" <code class=\"language-ymir hljs\"> if ({}) </code>", tempTest)
    //     } else { "" };

    //     stream:.write (std::format::format (self._declHead,
    //                                         "trait",
    //                                         p.file (),
    //                                         tempParams ~ tempTestCode,
    //                                         innerStream[]));

    // } catch {
    //     _ => {}
    // }


    // /**
    //  * Dump a macro
    //  * @params:
    //  *    - stream: the stream to populate
    //  *    - m: the macro to dump
    //  */
    // pub fn dumpMacro (self, dmut stream : &StringStream, m : &Macro) {
    //     if (m.getProtection () != Protection::PUB) return {}

    //     let p = Path::new (utils::path::toPath (m.getName ()));

    //     let dmut innerStream = StringStream::new ();

    //     let code = std::format::format ("{} macro {} {{ \n\t/** full declaration omitted */ \n}",
    //                                     self.convertProtection (m.getProtection ()),
    //                                     p.file ());

    //     innerStream:.write (std::format::format (self._inlineCode, code));
    //     self.dumpCommonSymbol (alias innerStream, m);

    //     // let dmut contentStream = StringStream::new ();
    //     // for j in t.getChilds () {
    //     //     self.dumpContent (alias contentStream, j);
    //     // }

    //     // innerStream:.write (std::format::format (self._declMembers, contentStream[]));

    //     stream:.write (std::format::format (self._declHead,
    //                                         "macro",
    //                                         p.file (),
    //                                         "",
    //                                         innerStream[]));
    // } catch {
    //     _ => {}
    // }

    // /**
    //  * Dump a class to html
    //  * @params:
    //  *    - stream: the stream to populate
    //  *    - c: the class to dump
    //  */
    // fn dumpClass (self, dmut stream : &StringStream, c : &Class, tempTest : [c8] = "", tempParams : [c8] = "", tempDoc : [c8] = "") {
    //     if (c.getProtection () != Protection::PUB) return {}

    //     let p = Path::new (utils::path::toPath (c.getName ()));

    //     let dmut innerStream = StringStream::new ();


    //     let ancestor = if (c.getAncestor ().getName () != "") {
    //         std::format::format ("over {}", c.getAncestor ().getName ())
    //     } else {
    //         ""
    //     };

    //     let dmut impls = StringStream::new ();
    //     for i in c.getImpls () {
    //         let ip = Path::new (utils::path::toPath (i.getTrait ()));
    //         impls:.write (std::format::format ("\timpl <a href=\"{}.html#{}\">{}</a>;\n", ip.parent ().toStr (sep-> "_"), ip.file (), ip.toStr (sep-> "::")));
    //     }

    //     for tc in c.getTemplateConds () {
    //         for i in tc.getImpls () {
    //             let ip = Path::new (utils::path::toPath (i.getTrait ()));
    //             impls:.write (std::format::format ("\tcte if {} {{\n\t\timpl <a href=\"{}.html#{}\">{}</a>;\n\t}\n", tc.getCondition (), ip.parent ().toStr (sep-> "_"), ip.file (), ip.toStr (sep-> "::")));
    //         }
    //     }

    //     let attrs =
    //         if (c.isFinal ()) { " @final"
    //         } else if (c.isAbstract ()) { " @abstract"
    //         } else { "" };



    //     let code = std::format::format ("{}{} class{} {}{} {} {{ \n\t/** full declaration omitted */ \n\n{}}",
    //                                     self.convertProtection (c.getProtection ()),
    //                                     attrs,
    //                                     tempTest,
    //                                     p.file (),
    //                                     tempParams,
    //                                     ancestor,
    //                                     impls[]);

    //     innerStream:.write (std::format::format (self._inlineCode, code));
    //     self.dumpCommonSymbol (alias innerStream, c, tempDoc-> tempDoc);

    //     let dmut contentStream = StringStream::new ();
    //     self.dumpClassAsserts (alias contentStream, c);
    //     self.dumpClassFields (alias contentStream, c.getFields ());
    //     self.dumpClassCstrs (alias contentStream, c);
    //     self.dumpClassMethods (alias contentStream, c, fromTemplate-> tempParams != "");

    //     innerStream:.write (std::format::format (self._declMembers, contentStream[]));

    //     let tempTestCode = if (tempTest != "") {
    //         std::format::format (" <code class=\"language-ymir hljs\"> if ({}) </code>", tempTest)
    //     } else { "" };


    //     stream:.write (std::format::format (self._declHead,
    //                                         "class",
    //                                         p.file (),
    //                                         tempParams ~ tempTestCode,
    //                                         innerStream[]));

    // } catch {
    //     _ => {}
    // }

    // /**
    //  * Dump the cstrs of the class into the stream
    //  * @params:
    //  *     - stream: the stream to populate
    //  *     - c: the class containing cstrs to dump
    //  */
    // fn dumpClassCstrs (self, dmut stream : &StringStream, c : &Class) {
    //     if (c.getCstrs ().len == 0us) return {}
    //     let dmut innerStream = StringStream::new ();

    //     for p in c.getCstrs () {
    //         let name = Path::new (utils::path::toPath (p.getName ())).file ();
    //         if (p.getProtection () != Protection::PRV) {
    //             let dmut innerStream2 = StringStream::new ();
    //             self.dumpFunction (alias innerStream2, p, isConstruct-> true);

    //             innerStream:.write (std::format::format (self._declHead,
    //                                                      "ctor", name, "",
    //                                                      innerStream2[]));
    //         }
    //     }


    //     for tc in c.getTemplateConds () {
    //         self.dumpClassTemplateCondCstrs (alias innerStream, tc);
    //     }

    //     if (innerStream[].len != 0us)
    //         stream:.write (std::format::format (self._memberHead,
    //                                             "Constructors",
    //                                             innerStream[]));
    // } catch {
    //     _ => {}
    // }



    // fn dumpClassTemplateCondCstrs (self, dmut stream : &StringStream, tc : &TemplateCond) {
    //     for p in tc.getCstrs () {
    //         if (p.getProtection () != Protection::PRV) {
    //             let name = Path::new (utils::path::toPath (p.getName ())).file ();
    //             let dmut innerStream2 = StringStream::new ();
    //             self.dumpFunction (alias innerStream2, p, tempTest-> tc.getCondition (), isConstruct-> true);

    //             stream:.write (std::format::format (self._declHead,
    //                                                      "self", name, "",
    //                                                      innerStream2[]));
    //         }
    //     }

    //     for tc2 in tc.getTemplateConds () {
    //         self.dumpClassTemplateCondCstrs (alias stream, tc2);
    //     }
    // } catch {
    //     _ => {}
    // }



    // /**
    //  * Dump an inner module
    //  * @params:
    //  *   - stream: the stream to populate
    //  *   - m: the module to dump
    //  */
    // fn dumpInnerModule (self, dmut stream : &StringStream, m : &Module, tempTest : [c8] = "", tempParams : [c8] = "", tempDoc : [c8] = "") {
    //     if (m.getProtection () == Protection::PRV) return {}

    //     let p = Path::new (utils::path::toPath (m.getName ()));
    //     let dmut innerStream = StringStream::new ();

    //     let code = std::format::format ("{} mod {}{}{}",
    //                                     self.convertProtection (m.getProtection ()),
    //                                     tempTest,
    //                                     p.file (),
    //                                     tempParams);

    //     innerStream:.write (std::format::format (self._inlineCode, code));
    //     self.dumpCommonSymbol (alias innerStream, m, tempDoc-> tempDoc);

    //     let dmut contentStream = StringStream::new ();
    //     for j in m.getChilds () {
    //         self.dumpContent (alias contentStream, j);
    //     }

    //     innerStream:.write (std::format::format (self._declMembers, contentStream[]));

    //     let tempTestCode = if (tempTest != "") {
    //         std::format::format (" <code class=\"language-ymir hljs\"> if ({}) </code>", tempTest)
    //     } else { "" };


    //     stream:.write (std::format::format (self._declHead,
    //                                         "mod",
    //                                         p.file (),
    //                                         tempParams ~ tempTestCode,
    //                                         innerStream[]));

    // } catch {
    //     _ => {}
    // }

    // /**
    //  * Dump an inner module
    //  * @params:
    //  *   - stream: the stream to populate
    //  *   - m: the module to dump
    //  */
    // fn dumpBlock (self, dmut stream : &StringStream, b : &Block) {
    //     //if (b.getProtection () != Protection::PUB) return {}

    //     for j in b.getChilds () {
    //         self.dumpContent (alias stream, j);
    //     }
    // }


    /**
     * Dump a function that was not declared in a class, trait or something like that
     * @params:
     *    - stream: the stream to populate
     *    - func: the function to dump
     */
    fn dumpFunction (self, dmut stream : &StringStream, func : &Function, templateTest : [c8] = "", templates : [&TemplateParam] = []) {
        let name = Path (func.name, sep-> "::");

        let dmut innerStream = copy StringStream ();
        let tempFormat = self.dumpTemplates (templates);
        let tempTest = self.dumpTemplateTest (templateTest);

        let mut attrs : [[c8]] = [];
        let dmut codeStream = copy StringStream ();
        if (func.isInline) attrs ~= ["inline"];
        if (func.isUnsafe) attrs ~= ["unsafe"];

        if (attrs.len > 1) { codeStream:.write ("@{", attrs [0], ",", attrs [1], "}\n"); }
        else if (attrs.len == 1) { codeStream:.write ("@", attrs [0], "\n"); }

        codeStream:.write (std::format::format ("{} {}fn {}{}{} (",
                                                self.dumpProtection (func.protect),
                                                tempTest,
                                                name.file (), tempFormat));

        for i, f in func.parameters {
            if (i != 0) codeStream:.write (", ");
            if f.isRef codeStream:.write ("ref ");
            if f.isLazy codeStream:.write ("lazy ");
            if f.isMut codeStream:.write ("mut ");
            codeStream:.write (f.name, " : ", self.dumpType (f.type));
            if (f.defaultValue != "") codeStream:.write (" = ", f.defaultValue);
        }

        codeStream:.write (")-> ", self.dumpType (func.retType));

        formatter::format (alias innerStream, ressources::INLINE_CODE, copy ["Code" => codeStream[]]);
        innerStream:.write (self.dumpCommonSymbol (func));

        formatter::format (alias stream, ressources::DECLARATION, copy ["Kind" => "fn",
                                                                        "Name" => name.file (),
                                                                        "Templates" => (tempFormat ~ tempTest),
                                                                        "Content" => innerStream[]]);
    } catch {
        _ => {}
    }


    // /**
    //  * Dump a function
    //  * @params:
    //  *   - stream: the stream to populate
    //  *   - func: the function to dump
    //  *   - isOver: true iif the function is an overriden method
    //  */
    // fn dumpFunction (self, dmut stream : &StringStream, func : &Function, isOver : bool = false,  tempTest : [c8] = "", tempParams : [c8] = "", tempDoc : [c8] = "", fromTemplate : bool = false, isConstruct : bool = false) {
    //     let dmut codeStream = StringStream::new ();

    //     let name = Path::new (utils::path::toPath (func.getName ())).file ();
    //     let df = if isOver { "over" } else if name != "self" { if (isConstruct) { "self" } else { "fn" } } else { "" };

    //     let mut fstParam = "";
    //     let (attributes, funcIsMut) = self.dumpAttrsFunction (func);
    //     match func {
    //         m : &Method => {
    //             if (!fromTemplate) {
    //                 if (m.isMut () || funcIsMut) {
    //                     fstParam = "\n\tmut self";
    //                 } else fstParam = "\n\tself";
    //                 if (m.getParameters ().len != 0us) fstParam = fstParam ~ ", ";
    //             }
    //         }
    //     }

    //     let tempTestIf = if (tempTest != "") { " if (" ~ tempTest ~ ")" } else { "" };

    //     codeStream:.write (std::format::format ("{} {}{}{}{}{} ({}",
    //                                             self.convertProtection (func.getProtection ()),
    //                                             df,
    //                                             tempTestIf, attributes,
    //                                             name, tempParams, fstParam));


    //     if (func.getParameters ().len != 0us) {
    //         codeStream:.write ("\n");
    //         for i, p in func.getParameters () {
    //             let value = if (p.getValue ().len != 0us) {
    //                 std::format::format (" = {}", p.getValue ())
    //             } else { "" };

    //             let mut type = self.dumpType (p.getType ());
    //             type = if (type.len != 0us) {
    //                 std::format::format (" : {}", type)
    //             } else { "" };

    //             let isMut = if (p.isDeeplyMutable ()) { "dmut " } else if (p.isMutable ()) { "mut " } else { "" };
    //             let isRef = if (p.isRef ()) { "ref " } else { "" };


    //             if (i != 0us) codeStream:.write (",\n");
    //             codeStream:.write (std::format::format ("\t{}{}{}{}{}",
    //                                                     isRef,
    //                                                     isMut,
    //                                                     p.getName (),
    //                                                     type,
    //                                                     value));
    //         }

    //         codeStream:.write ("\n)");
    //     } else if (fstParam != "") { codeStream:.write ("\n)");
    //     } else codeStream:.write (")");

    //     if (func.getThrowers ().len != 0us) {
    //         codeStream:.write (" throws ");
    //         for i, p in func.getThrowers () {
    //             if (i != 0us) codeStream:.write (", ");
    //             codeStream:.write (self.dumpType (p));
    //         }
    //     }


    //     let type = self.dumpType (func.getRetType ());
    //     if (name != "self") {
    //         codeStream:.write ("\n-> "):.write (if (type != "") type else "void");
    //     }

    //     stream:.write (std::format::format (self._inlineCode, codeStream[]));
    //     self.dumpCommonSymbol (alias stream, func, tempDoc-> tempDoc);

    // } catch {
    //     _ => {}
    // }

    // /**
    //  * Dump the attributes of a function
    //  * @params:
    //  *    - func: the function that has attributes to dump
    //  * @returns:
    //  *    - .0: the list of attributes in a string, (some of them are ignored)
    //  *    - .1: true if the function has the attribute `mut`
    //  */
    // fn dumpAttrsFunction (self, func : &Function)-> ([c8], bool) {
    //     let dmut attrs = StringStream::new ();
    //     let mut nb = 0us, mut isMut = false;
    //     for _, i in func.getAttributes () {
    //         let write = match i {
    //             "final" | "virtual" => { true }
    //             "mut" => { isMut = true; false }
    //             _ => { false }
    //         }
    //         if (write) {
    //             if (nb != 0us) attrs:.write (", ");
    //             attrs:.write (i);
    //             nb += 1us;
    //         }
    //     }

    //     if (nb > 1us) {
    //         (" @{" ~ attrs[] ~ "} ", isMut)
    //     } else if nb == 1us {
    //         (" @" ~ attrs[] ~ " ", isMut)
    //     } else {
    //         (" ", isMut)
    //     }
    // }


    // /**
    //  * Dump the method of the class into the stream
    //  * @params:
    //  *     - stream: the stream to populate
    //  *     - c: the class containing methods to dump
    //  */
    // fn dumpClassMethods (self, dmut stream : &StringStream, c : &Class, tempTest : [c8] = "", tempParams : [c8] = "", fromTemplate : bool = false) {
    //     if (c.getMethods ().len == 0us) return {}
    //     let dmut innerStream = StringStream::new ();

    //     for p in c.getMethods () {
    //         if (p.getProtection () != Protection::PRV) {

    //             let dmut innerStream2 = StringStream::new ();
    //             self.dumpFunction (alias innerStream2, p, isOver-> p.isOver (), tempTest-> tempTest, tempParams-> tempParams, fromTemplate-> fromTemplate);

    //             let tempTestCode = if (tempTest != "") {
    //                 std::format::format (" <code class=\"language-ymir hljs\"> if ({}) </code>", tempTest)
    //             } else { "" };

    //             let name = Path::new (utils::path::toPath (p.getName ())).file ();
    //             innerStream:.write (std::format::format (self._declHead,
    //                                                      "fn", name, tempParams ~ tempTestCode,
    //                                                      innerStream2[]));
    //         }
    //     }

    //     for tc in c.getTemplateConds () {
    //         self.dumpClassTemplateCondMethods (alias innerStream, tc, tempTest-> tempTest, tempParams-> tempParams);
    //     }

    //     for tmp in c.getTemplates () {
    //         match tmp.getChild () {
    //             p : &Function => {
    //                 if (p.getProtection () != Protection::PRV) {
    //                     let (tempTestIn, tempParamsIn, tempDocIn) = self.dumpTemplate (tmp);

    //                     let dmut innerStream2 = StringStream::new ();
    //                     self.dumpFunction (alias innerStream2, p, tempTest-> tempTestIn, tempParams-> tempParamsIn, tempDoc-> tempDocIn, fromTemplate-> true);

    //                     let tempTestCode = if (tempTestIn != "") {
    //                         std::format::format (" <code class=\"language-ymir hljs\"> if ({}) </code>", tempTestIn)
    //                     } else { "" };

    //                     let name = Path::new (utils::path::toPath (p.getName ())).file ();
    //                     innerStream:.write (std::format::format (self._declHead,
    //                                                              "fn", name, tempParamsIn ~ tempTestCode,
    //                                                              innerStream2[]));
    //                 }
    //             }
    //         }
    //     }

    //     if (innerStream[].len != 0us)
    //         stream:.write (std::format::format (self._memberHead,
    //                                             "Methods",
    //                                             innerStream[]));
    // } catch {
    //     _ => {}
    // }


    // fn dumpClassTemplateCondMethods (self, dmut stream : &StringStream, tc : &TemplateCond, tempTest : [c8] = "", tempParams : [c8] = "") {
    //     let tmpTest = if (tempTest != "") {
    //         tempTest ~ " && " ~ tc.getCondition ()
    //     } else { tc.getCondition () };

    //     let tmpTestCode = if (tmpTest != "") {
    //         std::format::format (" <code class=\"language-ymir hljs\"> if ({}) </code>", tmpTest)
    //     } else { "" };

    //     for p in tc.getMethods () {
    //         let dmut innerStream2 = StringStream::new ();
    //         self.dumpFunction (alias innerStream2, p, isOver-> p.isOver (), tempTest-> tmpTest, tempParams-> tempParams, fromTemplate-> true);

    //         let name = Path::new (utils::path::toPath (p.getName ())).file ();

    //         stream:.write (std::format::format (self._declHead,
    //                                             "fn", name, tempParams ~ tmpTestCode,
    //                                             innerStream2[]));
    //     }

    //     for tmp in tc.getTemplates () {
    //         match tmp.getChild () {
    //             p : &Function => {
    //                 if (p.getProtection () != Protection::PRV) {
    //                     let (tempTestIn, tempParamsIn, tempDocIn) = self.dumpTemplate (tmp);

    //                     let tempTestInAnd = if (tempTestIn != "") { tempTestIn ~ " && " ~ tmpTest } else { tmpTest };

    //                     let dmut innerStream2 = StringStream::new ();
    //                     self.dumpFunction (alias innerStream2, p, tempTest-> tempTestInAnd, tempParams-> tempParamsIn, tempDoc-> tempDocIn, fromTemplate-> true);

    //                     let tmpTestCodeAnd = if (tempTestInAnd != "") {
    //                         std::format::format (" <code class=\"language-ymir hljs\"> if ({}) </code>", tempTestInAnd)
    //                     } else { "" };

    //                     let name = Path::new (utils::path::toPath (p.getName ())).file ();
    //                     stream:.write (std::format::format (self._declHead,
    //                                                              "fn", name, tempParamsIn ~ tmpTestCodeAnd,
    //                                                              innerStream2[]));
    //                 }
    //             }
    //         }
    //     }

    //     for tmpc in tc.getTemplateConds () {
    //         self.dumpClassTemplateCondMethods (alias stream, tmpc, tempTest-> tmpTest, tempParams-> tempParams);
    //     }

    // } catch {
    //     _ => {}
    // }


    // /**
    //  * Dump a list of fields
    //  * @params:
    //  *     - stream: the stream to populate
    //  *     - c: the fields to dump
    //  */
    // fn dumpClassFields (self, dmut stream : &StringStream, fields : [&Parameter]) {
    //     if (fields.len == 0us) return {}

    //     let dmut innerStream = StringStream::new ();
    //     for p in fields {
    //         if (p.getProtection () == Protection::PUB) {
    //             let dmut innerStream2 = StringStream::new ();

    //             let value = if (p.getValue ().len != 0us) {
    //                 std::format::format (" = {}", p.getValue ())
    //             } else { "" };

    //             let mut type = self.dumpType (p.getType ());
    //             type = if (type.len != 0us) {
    //                 std::format::format (" : {}", type)
    //             } else { "" };

    //             let isMut = if (p.isMutable ()) { " mut" } else { "" };

    //             let code = std::format::format ("{} let{} {}{}{};",
    //                                             self.convertProtection (p.getProtection ()),
    //                                             isMut,
    //                                             p.getName (),
    //                                             type,
    //                                             value);

    //             innerStream2:.write (std::format::format (self._inlineCode, code));
    //             self.dumpCommonSymbol (alias innerStream2, p);

    //             innerStream:.write (std::format::format (self._declHead,
    //                                                      "let",
    //                                                      p.getName (), "",
    //                                                      innerStream2[]));
    //         }
    //     }

    //     if (innerStream[].len != 0us)
    //         stream:.write (std::format::format (self._memberHead,
    //                                             "Fields",
    //                                             innerStream[]));

    // } catch {
    //     _ => {}
    // }


    // fn dumpVariable (self, dmut stream : &StringStream, v : &Variable, tempTest : [c8] = "", tempParams : [c8] = "", tempDoc : [c8] = "") {
    //     if (v.getProtection () != Protection::PUB) return {}

    //     let p = Path::new (utils::path::toPath (v.getName ()));

    //     let dmut innerStream = StringStream::new ();
    //     let value = if (v.getValue ().len != 0us) {
    //         std::format::format (" = {}", v.getValue ())
    //     } else { "" };

    //     let mut type = self.dumpType (v.getType ());
    //     type = if (type.len != 0us) {
    //         std::format::format (" : {}", type)
    //     } else { "" };

    //     let isMut = if (v.isMutable ()) { " mut" } else { "" };

    //     let code = std::format::format ("{} static{}{} {}{} {} {};",
    //                                     self.convertProtection (v.getProtection ()),
    //                                     tempTest,
    //                                     isMut,
    //                                     p.file (),
    //                                     tempParams,
    //                                     type,
    //                                     value);

    //     innerStream:.write (std::format::format (self._inlineCode, code));
    //     self.dumpCommonSymbol (alias innerStream, v, tempDoc-> tempDoc);

    //     let tempTestCode = if (tempTest != "") {
    //         std::format::format (" <code class=\"language-ymir hljs\"> if ({}) </code>", tempTest)
    //     } else { "" };

    //     stream:.write (std::format::format (self._declHead,
    //                                         "static",
    //                                         p.file (), tempParams ~ tempTestCode,
    //                                         innerStream[]));
    // } catch {
    //     _ => {}
    // }

    // /**
    //  * Dump a list of fields
    //  * @params:
    //  *     - stream: the stream to populate
    //  *     - c: the fields to dump
    //  */
    // fn dumpFields (self, dmut stream : &StringStream, fields : [&Parameter]) {
    //     if (fields.len == 0us) return {}

    //     let dmut innerStream = StringStream::new ();
    //     for p in fields {
    //         let dmut innerStream2 = StringStream::new ();

    //         let value = if (p.getValue ().len != 0us) {
    //             std::format::format (" = {}", p.getValue ())
    //         } else { "" };

    //         let mut type = self.dumpType (p.getType ());
    //         type = if (type.len != 0us) {
    //             std::format::format (" : {}", type)
    //         } else { "" };

    //         let isMut = if (p.isMutable ()) { " mut" } else { "" };

    //         let code = std::format::format ("{} {} {} {};",
    //                                         isMut,
    //                                         p.getName (),
    //                                         type,
    //                                         value);

    //         innerStream2:.write (std::format::format (self._inlineCode, code));
    //         self.dumpCommonSymbol (alias innerStream2, p);

    //         innerStream:.write (std::format::format (self._declHead,
    //                                                  "let",
    //                                                  p.getName (), "",
    //                                                  innerStream2[]));
    //     }

    //     stream:.write (std::format::format (self._memberHead,
    //                                         "Fields",
    //                                         innerStream[]));

    // } catch {
    //     _ => {}
    // }

    // /**
    //  * Dump the assertions of a class
    //  * @params:
    //  *     - stream: the stream to populate
    //  *     - c: the class containing methods to dump
    //  */
    // fn dumpClassAsserts (self, dmut stream : &StringStream, c : &Class) {
    //     if (c.getAsserts ().len == 0us) return {}
    //     let dmut innerStream = StringStream::new ();

    //     for a in c.getAsserts () {
    //         let dmut innerStream2 = StringStream::new ();
    //         self.dumpAssert (alias innerStream2, a);

    //         innerStream:.write (std::format::format (self._declHead,
    //                                                  "", "", "",
    //                                                  innerStream2[]));
    //     }

    //     stream:.write (std::format::format (self._memberHead,
    //                                         "Assertions",
    //                                         innerStream[]));
    // } catch {
    //     _ => {}
    // }


    // /**
    //  * Dump the template test and template params into strings
    //  * @params:
    //  *   - t: the template to dump
    //  * @returns:
    //  *   - .0: the template test
    //  *   - .1: the template params
    //  */
    // fn dumpTemplate (self, t : &Template)-> ([c8], [c8], [c8]) {
    //     let dmut paramStream = StringStream::new ();
    //     paramStream:.write (" {");
    //     for i, j in t.getParams () {
    //         if (i != 0us) paramStream:.write (", ");
    //         paramStream:.write (j);
    //     }
    //     paramStream:.write ("} ");

    //     let dmut docStream = StringStream::new ();
    //     self.dumpCommonSymbol (alias docStream, t);

    //     if (t.getTest () != "") {
    //         (t.getTest (), paramStream[], docStream[])
    //     } else {
    //         ("", paramStream[], docStream[])
    //     }
    // }


    fn dumpType (self, type : &Type) -> [c8] {
        let inner = match type {
            a : &ArrayType => {
                std::format::format ("[{} ; {}]", self.dumpType (a.getInnerType ()), a.getLen ())
            }
            s : &ScalarType => { s.getName () }
            c : &ClassType => {
                let beg = "<a href=\"" ~ c.getModule ().toStr (sep-> "_") ~ ".html#" ~ c.getName () ~ "\">";
                if (c.isClass ()) {
                    if c.isInnerMutable () {
                        "&(mut " ~ beg ~ c.getName () ~ "</a>)"
                    } else {
                        "&(" ~ beg ~ c.getName () ~ "</a>)"
                    }
                }
                else { beg ~ c.getName () ~ "</a>" }
            }
            e : &EnumType => { "<a href=\"" ~ e.getModule ().toStr (sep-> "_") ~ ".html#" ~ e.getName () ~ "\">" ~ e.getName () ~ "</a>" }
            o : &OptionType => { std::format::format ("({})?", self.dumpType (o.getInnerType ())) }
            p : &PointerType => { std::format::format ("*({})", self.dumpType (p.getInnerType ())) }
            m : &MapType => { std::format::format ("[{} => {}]", self.dumpType (m.getKey ()), self.dumpType (m.getValue ())) }
            r : &RangeType => { std::format::format ("..{}", self.dumpType (r.getInnerType ())) }
            s : &SliceType => { std::format::format ("[{}]", self.dumpType (s.getInnerType ())) }
            t : &TupleType => {
                let dmut stream = copy StringStream ();
                stream:.write ("(");
                for i, j in t.getInnerTypes () {
                    if (i != 0us) stream:.write (",");
                    stream:.write (self.dumpType (j));
                }
                stream:.write (")");
                stream[]
            }
            fptr : &FuncPtrType => {
                let dmut stream = copy StringStream ();
                if (fptr.isDelegate ()) stream:.write ("dg (");
                else stream:.write ("fn (");
                for i, j in fptr.getParameters () {
                    if (i != 0) stream:.write (", ");
                    if (fptr.getReferences ()[i]) stream:.write ("ref ");
                    if (fptr.getLazys ()[i]) stream:.write ("lazy ");
                    stream:.write (self.dumpType (j));
                }
                stream:.write (")-> ", self.dumpType (fptr.getRetType ()));
                stream[]
            }
            a : &AnyType => {
                if a.getName () == "<empty>" {
                    return "void";
                }

                if (a.getModule ().toStr () == "") { a.getName () }
                else {
                    "<a href=\"" ~ a.getModule ().toStr (sep-> "_") ~ ".html#" ~ a.getName () ~ "\">" ~ a.getName () ~ "</a>"
                }
            }
            _ => { "" }
        }

        if (type.isMutable () && inner.len != 0us) {
            "mut " ~ inner
        } else inner
    } catch {
        _ => {
            ""
        }
    }

    /**
     * Convert a protection into string
     */
    fn dumpProtection (self, protection : Protection)-> [c8] {
        match protection {
            Protection::PUB => { "pub" }
            Protection::PROT => { "prot" }
            _ => { "prv" }

        }
    }

    fn dumpTemplates (self, params : [&TemplateParam])-> [c8] {
        if (params.len == 0) return "";

        let dmut stream = copy StringStream ();
        stream:.write ("{");
        for i, j in params {
            if i != 0 stream:.write (", ");
            stream:.write (j);
        }
        stream:.write ("}");
        stream[]
    }

    fn dumpTemplateTest (self, test : [c8])-> [c8] {
        if (test == []) return "";

        " if (" ~ test ~ ") "
    }

}
