in body;

use std::{stream,
          format,
          algorithm::sorting,
          conv, fs::path};

use gyllir::doc::{_, symbols::_, types::_, comment::parser};
use gyllir::repo::defaults;


/**
 * Html body of a page 
 */
@final
pub class HtmlBody over HtmlNode {

    // Test of assertion
    cte assert (true, "msg");

    // The module to dump
    let _module : &Module;

    // The name of the project
    let _project : [c8];

    // The path of the current module
    let _path : Path;

    let mut _akas : [mut &Symbol] = [];
    let mut _classes : [mut &Symbol] = [];
    let mut _traits : [mut &Symbol] = [];
    let mut _enums : [mut &Symbol] = [];
    let mut _functions : [mut &Symbol] = [];
    let mut _globals : [mut &Symbol] = [];
    let mut _macros : [mut &Symbol] = [];
    let mut _modules : [mut &Symbol] = [];

    /**
     * @params: 
     *    - project: the name of the project
     *    - module: the content of the page to dump
     */
    pub self (project : [c8], module : &Module)
        with _project = project
        , _module = module
        , _path = Path (module.name, sep-> "::")
    {
        self:.loadContent ();
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ======================================          MAIN          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Dump the module into a html page
     * @params:
     *    - stream: the stream to populate
     */
    pub over dumpHtml (self, dmut stream : &StringStream) {
        let content = copy ["Content" => self.dumpCommonSymbol (self._module)];
        formatter::format (alias stream, ressources::MODULE_HEAD, content);

        self.dumpSubModuleTable (alias stream);

        for a in self._akas self.dumpContent (alias stream, a);
        for a in self._enums self.dumpContent (alias stream, a);
        for a in self._globals self.dumpContent (alias stream, a);
        for a in self._macros self.dumpContent (alias stream, a);
        for a in self._functions self.dumpContent (alias stream, a);
        for a in self._traits self.dumpContent (alias stream, a);
        for a in self._classes self.dumpContent (alias stream, a);
    }

    /**
     * Dump the elements common to all symbols
     * @params:
     *     - s: the symbol to dump
     */
    fn dumpCommonSymbol (self, s : &Symbol)-> [c8] {
        let dmut stream = copy StringStream ();
        let p = copy CommentParser (s.doc);
        stream:.write ("<div class=\"doc\">");
        p.dumpHtml (alias stream);
        stream:.write ("</div>");

        stream[]
    }

    /**
     * Dump the comments
     */
    fn dumpComments (self, comm : [c8])-> [c8] {
        let dmut stream = copy StringStream ();
        let p = copy CommentParser (comm);
        stream:.write ("<div class=\"doc\">");
        p.dumpHtml (alias stream);
        stream:.write ("</div>");

        stream[]
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          SUBMODULES          ===================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Dump the table listing the sub modules defined in this module
     * */
    fn dumpSubModuleTable (self, dmut stream : &StringStream) {
        if (self._modules.len != 0) {
            let dmut subModule = copy StringStream ();
            for m in self._modules {
                let p = Path (m.name, sep-> "::");
                let mut name = p.file (), mut url = p;

                if let Ok (f) = std::algorithm::searching::find (m.name, '!') {
                    if let Ok (e) = std::algorithm::searching::rfind (m.name, '}') {
                        let templates = m.name [f .. e];
                        let res_name = m.name [0 .. f];

                        url = Path (res_name, sep-> "::");
                        name = Path (res_name, sep-> "::").file () ~ templates;
                    }
                }

                let comm = copy CommentParser (m.doc);

                formatter::format (alias subModule, ressources::SUBMODULE, copy ["Url" => url.toStr (sep-> "_"),
                                                                                 "Name" => name,
                                                                                 "Protection" => self.dumpProtection (m.protect),
                                                                                 "Doc" => comm.dumpTextShort ()]);
            }

            formatter::format (alias stream, ressources::MODULE_TABLE, copy ["Content" => subModule[]]);
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          SYMBOLS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Dump a symbol into html
     * @params: 
     *    - stream: the stream to populate
     *    - sym: the symbol to dump
     */
    fn dumpContent (self, dmut stream : &StringStream, sym : &Symbol, templates : [&TemplateParam] = [], templateTest : [c8] = []) {
        match sym {
            a : &Aka         => self.dumpAka (alias stream, a, templates-> templates, templateTest-> templateTest);
            c : &ClassSymbol => self.dumpClass (alias stream, c, templates-> templates, templateTest-> templateTest);
            t : &TraitSymbol => self.dumpTrait (alias stream, t, templates-> templates, templateTest-> templateTest);
            e : &EnumSymbol  => self.dumpEnum (alias stream, e, templates-> templates, templateTest-> templateTest);
            f : &Function    => self.dumpFunction (alias stream, f, templates-> templates, templateTest-> templateTest);
            g : &Global      => self.dumpGlobal (alias stream, g);
            m : &Macro       => self.dumpMacro (alias stream, m);
            t : &Template    => {
                for c in t.inners {
                    self.dumpContent (alias stream, c, templates-> t.params, templateTest-> t.test);
                }
            }
        }
    }

    /**
     * Dump an aka to html
     * @params:
     *    - stream: the stream to populate
     *    - a: the aka to dump
     */
    fn dumpAka (self, dmut stream : &StringStream, a : &Aka, templateTest : [c8] = "", templates : [&TemplateParam] = []) {
        let p = Path (a.name, sep-> "::");
        let dmut innerStream = copy StringStream ();

        let (token, end) = if a.isValue { ("=", a.value) } else { (":", self.dumpType (a.type)) };


        let dmut codeStream = copy StringStream ();
        let tempFormat = self.dumpTemplates (templates);
        let tempTest = self.dumpTemplateTest (templateTest);

        let pr = self.dumpProtection (a.protect);
        codeStream:.write (pr, " def");
        codeStream:.entabing (txt-> std::format::format ("{: <*}", pr.len + 4, " "));
        codeStream:.write (tempTest);

        codeStream:.write (std::format::format (" {}{} {} {}",
                                                p.file (),
                                                tempFormat,
                                                token, end));

        formatter::format (alias innerStream, ressources::INLINE_CODE, copy ["Code" => codeStream[]]);
        innerStream:.write (self.dumpCommonSymbol (a));

        formatter::format (alias stream, ressources::DECLARATION, copy ["Kind" => "def",
                                                                        "Name" => p.file (),
                                                                        "Templates" => (tempFormat ~ tempTest),
                                                                        "Content" => innerStream[]]);
    } catch {
        _ => {}
    }


    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          TRAITS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Dump the html representation of a trait
     * */
    fn dumpTrait (self, dmut stream : &StringStream, tr : &TraitSymbol, templateTest : [c8] = "", templates : [&TemplateParam] = []) {
        let p = Path (tr.name, sep-> "::");
        let dmut innerStream = copy StringStream ();
        let tempFormat = self.dumpTemplates (templates);
        let tempTest = self.dumpTemplateTest (templateTest);

        let code = std::format::format ("{} trait{} {} {} {{ \n\t/** full declaration omitted */ \n\n}",
                                        self.dumpProtection (tr.protect),
                                        tempTest,
                                        p.file (),
                                        tempFormat);

        formatter::format (alias innerStream, ressources::INLINE_CODE, copy ["Code" => code]);
        innerStream:.write (self.dumpCommonSymbol (tr));

        let dmut contentStream = copy StringStream ();
        self.dumpClassAssertions (alias contentStream, tr.asserts);
        self.dumpClassMethods (alias contentStream, tr.methods);
        self.dumpClassConditionalMethods (alias contentStream, tr.condMethods);

        formatter::format (alias innerStream, ressources::MEMBERS, copy ["Content" => contentStream[]]);
        formatter::format (alias stream, ressources::DECLARATION, copy ["Kind" => "trait",
                                                                        "Name" => p.file (),
                                                                        "Templates" => (tempFormat ~ tempTest),
                                                                        "Content" => innerStream[]]);
    } catch {
        _ => {}
    }


    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          CLASS          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Dump a class to html
     * @params:
     *    - stream: the stream to populate
     *    - c: the class to dump
     */
    fn dumpClass (self, dmut stream : &StringStream, c : &ClassSymbol, templateTest : [c8] = "", templates : [&TemplateParam] = []) {
        let p = Path (c.name, sep-> "::");
        let dmut innerStream = copy StringStream ();

        let tempFormat = self.dumpTemplates (templates);
        let tempTest = self.dumpTemplateTest (templateTest);

        let kind = if c.isRecord { "record" } else if c.isEntity { "entity" } else { "class" };

        let ancestor = if (c.ancestor of ClassType) {
            std::format::format ("over {}", self.dumpType (c.ancestor, andClass-> false))
        } else if let a : &AnyType = c.ancestor && a.name != "" {
            std::format::format ("over {}", self.dumpType (c.ancestor, andClass-> false))
        } else { "" };

        let dmut impls = copy StringStream ();
        for im in c.implements {
            let test = if im.1 == "" { "" } else { "if " ~ im.1 };
            impls:.write (std::format::format ("\t{}impl {};\n", test, self.dumpType (im.0)));
        }

        let attrs =
            if (c.isFinal) { "@final\n"
            } else if (c.isAbstract) { "@abstract\n"
            } else { "" };

        let code = std::format::format ("{}{} {}{} {}{} {} {{ \n\t/** full declaration omitted */ \n\n{}}",
                                        attrs,
                                        self.dumpProtection (c.protect),
                                        kind,
                                        tempTest,
                                        p.file (),
                                        tempFormat,
                                        ancestor,
                                        impls[]);

        formatter::format (alias innerStream, ressources::INLINE_CODE, copy ["Code" => code]);
        innerStream:.write (self.dumpCommonSymbol (c));

        let dmut contentStream = copy StringStream ();
        self.dumpClassAssertions (alias contentStream, c.asserts);
        self.dumpClassFields (alias contentStream, c.fields);
        self.dumpClassConditionalFields (alias contentStream, c.condFields);
        self.dumpClassCtors (alias contentStream, c.ctors);
        self.dumpClassConditionalCtors (alias contentStream, c.condCtors);
        self.dumpClassTemplateCtors (alias contentStream, c.templateCtors);

        self.dumpClassMethods (alias contentStream, c.methods);
        self.dumpClassConditionalMethods (alias contentStream, c.condMethods);
        self.dumpClassTemplateMethods (alias contentStream, c.templateMethods);

        formatter::format (alias innerStream, ressources::MEMBERS, copy ["Content" => contentStream[]]);
        formatter::format (alias stream, ressources::DECLARATION, copy ["Kind" => kind,
                                                                        "Name" => p.file (),
                                                                        "Templates" => (tempFormat ~ tempTest),
                                                                        "Content" => innerStream[]]);
    } catch {
        _ => {}
    }

    /**
     * Dump the assertions of a class
     * */
    fn dumpClassAssertions (self, dmut stream : &StringStream, assertions : [Assertion]) {
        if (assertions.len == 0us) return;
        let dmut innerStream = copy StringStream ();

        for a in assertions {
            let dmut inner = copy StringStream ();
            let cond = if (a.condition != "") { "if " ~ a.condition } else { "" };
            let msg = if (a.msg != "") { ", " ~ a.msg } else { "" };
            let code = std::format::format ("{}cte assert ({}{})", cond, a.test, msg);

            formatter::format (alias inner, ressources::INLINE_CODE, copy ["Code" => code]);
            inner:.write (self.dumpComments (a.doc));

            // innerStream:.write (inner[]);
            formatter::format (alias innerStream, ressources::DECLARATION, copy ["Kind" => "assert",
                                                                                 "Name" => "",
                                                                                 "Templates" => cond,
                                                                                 "Content" => inner[]]);
        }

        if (innerStream[].len != 0us)
            formatter::format (alias stream, ressources::MEMBER_HEAD, copy ["Kind" => "Assertions",
                                                                            "Content" => innerStream[]]);
    } catch {
        _ => {}
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          CTORS          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Dump the cstrs of the class into the stream
     * @params:
     *     - stream: the stream to populate
     *     - c: the class containing cstrs to dump
     */
    fn dumpClassCtors (self, dmut stream : &StringStream, ctors : [&Ctor]) {
        if (ctors.len == 0us) return;
        let dmut innerStream = copy StringStream ();

        for p in ctors {
            self.dumpCtor (alias innerStream, p);
        }

        if (innerStream[].len != 0us)
            formatter::format (alias stream, ressources::MEMBER_HEAD, copy ["Kind" => "Constructors",
                                                                            "Content" => innerStream[]]);
    }

    /**
     * Dump the cstrs of the class into the stream
     * @params:
     *     - stream: the stream to populate
     *     - c: the class containing cstrs to dump
     */
    fn dumpClassConditionalCtors (self, dmut stream : &StringStream, ctors : [(&Ctor, [c8])]) {
        if (ctors.len == 0us) return;
        let dmut innerStream = copy StringStream ();

        for p in ctors {
            self.dumpCtor (alias innerStream, p.0, templateTest-> p.1);
        }

        if (innerStream[].len != 0us)
            formatter::format (alias stream, ressources::MEMBER_HEAD, copy ["Kind" => "Conditional Constructors",
                                                                            "Content" => innerStream[]]);
    }

    /**
     * Dump the template cstrs of the class into the stream
     * @params:
     *     - stream: the stream to populate
     *     - c: the class containing cstrs to dump
     */
    fn dumpClassTemplateCtors (self, dmut stream : &StringStream, ctors : [&Template]) {
        if (ctors.len == 0us) return;
        let dmut innerStream = copy StringStream ();

        for p in ctors {
            for z in p.inners if let c : &Ctor = z {
                self.dumpCtor (alias innerStream, c, templateTest-> p.test, templates-> p.params);
            }
        }

        if (innerStream[].len != 0us)
            formatter::format (alias stream, ressources::MEMBER_HEAD, copy ["Kind" => "Template Constructors",
                                                                            "Content" => innerStream[]]);
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          CLASS FIELDS          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Dump a list of fields
     * @params:
     *     - stream: the stream to populate
     *     - c: the fields to dump
     */
    fn dumpClassFields (self, dmut stream : &StringStream, fields : [&Variable]) {
        if (fields.len == 0us) return;

        let dmut innerStream = copy StringStream ();
        for p in fields {
            self.dumpClassField (alias innerStream, p);
        }

        if (innerStream[].len != 0)
            formatter::format (alias stream, ressources::MEMBER_HEAD, copy ["Kind" => "Fields",
                                                                            "Content" => innerStream[]]);
    }

    /**
     * Dump a list of conditional fields
     * @params:
     *     - stream: the stream to populate
     *     - c: the fields to dump
     */
    fn dumpClassConditionalFields (self, dmut stream : &StringStream, fields : [(&Variable, [c8])]) {
        if (fields.len == 0us) return;

        let dmut innerStream = copy StringStream ();
        for v in fields {
            self.dumpClassField (alias innerStream, v.0, templateTest-> v.1);
        }

        if (innerStream[].len != 0)
            formatter::format (alias stream, ressources::MEMBER_HEAD, copy ["Kind" => "Conditional Fields",
                                                                            "Content" => innerStream[]]);
    }

    /**
     * Dump a field in html format
     * */
    fn dumpClassField (self, dmut stream : &StringStream, field : &Variable, templateTest : [c8] = "") {
        let dmut innerStream2 = copy StringStream ();
        let tempTest = self.dumpTemplateTest (templateTest);

        let value = if (field.defaultValue.len != 0) {
            std::format::format (" = {}", field.defaultValue)
        } else { "" };

        let mut type = self.dumpType (field.type);
        type = if (type.len != 0us) {
            std::format::format (" : {}", type)
        } else { "" };

        let isMut = if (field.isMut) { " mut" } else if field.isDMut { " dmut" } else { "" };
        let isRef = if (field.isRef) { " ref" } else { "" };

        let code = std::format::format ("{}{} let{}{} {}{}{};",
                                        self.dumpProtection (field.protect),
                                        tempTest,
                                        isRef,
                                        isMut,
                                        field.name,
                                        type,
                                        value);

        formatter::format (alias innerStream2, ressources::INLINE_CODE, copy ["Code" => code]);
        innerStream2:.write (self.dumpCommonSymbol (field));

        formatter::format (alias stream, ressources::DECLARATION, copy ["Kind" => "let",
                                                                        "Name" => field.name,
                                                                        "Templates" => tempTest,
                                                                        "Content" => innerStream2[]]);
    } catch {
        _ => {}
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          METHODS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Dump the cstrs of the class into the stream
     * @params:
     *     - stream: the stream to populate
     *     - c: the class containing cstrs to dump
     */
    fn dumpClassMethods (self, dmut stream : &StringStream, methods : [&Method]) {
        if (methods.len == 0us) return;
        let dmut innerStream = copy StringStream ();

        for p in methods {
            self.dumpMethod (alias innerStream, p);
        }

        if (innerStream[].len != 0us)
            formatter::format (alias stream, ressources::MEMBER_HEAD, copy ["Kind" => "Methods",
                                                                            "Content" => innerStream[]]);
    }

    /**
     * Dump the cstrs of the class into the stream
     * @params:
     *     - stream: the stream to populate
     *     - c: the class containing cstrs to dump
     */
    fn dumpClassConditionalMethods (self, dmut stream : &StringStream, methods : [(&Method, [c8])]) {
        if (methods.len == 0us) return;
        let dmut innerStream = copy StringStream ();

        for p in methods {
            self.dumpMethod (alias innerStream, p.0, templateTest-> p.1);
        }

        if (innerStream[].len != 0us)
            formatter::format (alias stream, ressources::MEMBER_HEAD, copy ["Kind" => "Conditional Methods",
                                                                            "Content" => innerStream[]]);
    }

    /**
     * Dump the template cstrs of the class into the stream
     * @params:
     *     - stream: the stream to populate
     *     - c: the class containing cstrs to dump
     */
    fn dumpClassTemplateMethods (self, dmut stream : &StringStream, methods : [&Template]) {
        if (methods.len == 0us) return;
        let dmut innerStream = copy StringStream ();

        for p in methods {
            for z in p.inners if let m : &Method = z {
                self.dumpMethod (alias innerStream, m, templateTest-> p.test, templates-> p.params);
            }
        }

        if (innerStream[].len != 0us)
            formatter::format (alias stream, ressources::MEMBER_HEAD, copy ["Kind" => "Template Methods",
                                                                            "Content" => innerStream[]]);
    }


    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          FUNCTIONS          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Dump the html representation of a function
     */
    fn dumpFunction (self, dmut stream : &StringStream, func : &Function, templateTest : [c8] = "", templates : [&TemplateParam] = []) {
        let name = Path (func.name, sep-> "::");

        let dmut innerStream = copy StringStream ();
        let tempFormat = self.dumpTemplates (templates);
        let tempTest = self.dumpTemplateTest (templateTest);

        let dmut codeStream = copy StringStream ();

        if func.isInline && func.isUnsafe { codeStream:.write ("@{unsafe, inline}"); }
        else if func.isInline { codeStream:.write ("@inline\n"); }
        else if func.isUnsafe { codeStream:.write ("@unsafe\n"); }

        let pr = self.dumpProtection (func.protect);
        codeStream:.write (pr, " fn");
        codeStream:.entabing (txt-> std::format::format ("{: <*}", pr.len + 3, " "));
        codeStream:.write (tempTest);

        let base = std::format::format (" {}{} (", name.file (), tempFormat);
        codeStream:.write (base);
        codeStream:.detabing ();

        codeStream:.entabing (txt-> std::format::format ("{: <*}", base.len + pr.len + 3, " "));
        for i, f in func.parameters {
            if (i != 0) {
                codeStream:.write (",\n");
            }

            if f.isRef codeStream:.write ("ref ");
            if f.isLazy codeStream:.write ("lazy ");
            if f.isMut codeStream:.write ("mut ");
            if f.isDMut codeStream:.write ("dmut ");
            codeStream:.write (f.name, " : ", self.dumpType (f.type));
            if (f.defaultValue != "") codeStream:.write (" = ", f.defaultValue);
        }

        codeStream:.write (")");
        codeStream:.detabing ();
        codeStream:.entabing (txt-> std::format::format ("{: <*}", pr.len + 4, " "));
        if (func.parameters.len > 1) { codeStream:.write ("\n"); }

        codeStream:.write ("-> ", self.dumpType (func.retType));

        if (func.throwers.len != 0) {
            codeStream:.write ("\nthrows ");
            for i, j in func.throwers {
                if (i != 0) codeStream:.write (", ");
                codeStream:.write (self.dumpType (j, andClass-> false));
            }
        }

        codeStream:.detabing ();

        formatter::format (alias innerStream, ressources::INLINE_CODE, copy ["Code" => codeStream[]]);
        innerStream:.write (self.dumpCommonSymbol (func));

        formatter::format (alias stream, ressources::DECLARATION, copy ["Kind" => "fn",
                                                                        "Name" => name.file (),
                                                                        "Templates" => tempFormat,
                                                                        "Content" => innerStream[]]);
    } catch {
        _ => {}
    }

    /**
     * Dump the html representation of a constructor
     * */
    fn dumpCtor (self, dmut stream : &StringStream, ctor : &Ctor, templateTest : [c8] = "", templates : [&TemplateParam] = []) {
        let name = Path (ctor.name, sep-> "::");

        let dmut innerStream = copy StringStream ();
        let tempFormat = self.dumpTemplates (templates);
        let tempTest = self.dumpTemplateTest (templateTest);

        let dmut codeStream = copy StringStream ();
        if (ctor.isUnsafe) codeStream:.write ("@unsafe\n");

        let rename = if (name.file () == "self") { "" } else { " " ~ name.file () };

        let pr = self.dumpProtection (ctor.protect);
        codeStream:.write (pr, " self");
        codeStream:.entabing (txt-> std::format::format ("{: <*}", pr.len + 5, " "));
        codeStream:.write (tempTest);

        let base = std::format::format ("{}{} (", rename, tempFormat);
        codeStream:.write (base);
        codeStream:.detabing ();

        codeStream:.entabing (txt-> std::format::format ("{: <*}", base.len + pr.len + 5, " "));
        for i, f in ctor.parameters {
            if (i != 0) {
                codeStream:.write (",\n");
            }

            if f.isRef codeStream:.write ("ref ");
            if f.isLazy codeStream:.write ("lazy ");
            if f.isMut codeStream:.write ("mut ");
            if f.isDMut codeStream:.write ("dmut ");
            codeStream:.write (f.name, " : ", self.dumpType (f.type));
            if (f.defaultValue != "") codeStream:.write (" = ", f.defaultValue);
        }
        codeStream:.write (")");
        codeStream:.detabing ();

        if (ctor.throwers.len != 0) {
            codeStream:.entabing (txt-> std::format::format ("{: <*}", pr.len + 6, " "));
            codeStream:.write ("\nthrows ");
            for i, j in ctor.throwers {
                if (i != 0) codeStream:.write (", ");
                codeStream:.write (self.dumpType (j, andClass-> false));
            }
            codeStream:.detabing ();
        }

        formatter::format (alias innerStream, ressources::INLINE_CODE, copy ["Code" => codeStream[]]);
        innerStream:.write (self.dumpCommonSymbol (ctor));

        formatter::format (alias stream, ressources::DECLARATION, copy ["Kind" => "ctor",
                                                                        "Name" => name.file (),
                                                                        "Templates" => (tempFormat ~ tempTest),
                                                                        "Content" => innerStream[]]);
    } catch {
        _ => {}
    }

    /**
     * Dump the html representation of a constructor
     * */
    fn dumpMethod (self, dmut stream : &StringStream, method : &Method, templateTest : [c8] = "", templates : [&TemplateParam] = []) {
        let name = Path (method.name, sep-> "::");

        let dmut innerStream = copy StringStream ();
        let tempFormat = self.dumpTemplates (templates);
        let tempTest = self.dumpTemplateTest (templateTest);

        let dmut codeStream = copy StringStream ();
        let dmut attrs : [[c8]] = [];
        if (method.isFinal) attrs ~= ["final"];
        if (method.isField) attrs ~= ["field"];
        if (method.isUnsafe) attrs ~= ["unsafe"];
        if attrs.len > 1 {
            codeStream:.write ("@{");
            for i, j in attrs {
                if (i != 0) codeStream:.write (", ");
                codeStream:.write (j);
            }
            codeStream:.write ("}\n");
        } else if attrs.len == 1 { codeStream:.write ("@", attrs [0], "\n"); }

        let fstParam = if method.isMutable { "mut self" } else { "self" };

        let pr = self.dumpProtection (method.protect);
        codeStream:.write (pr, " fn");
        codeStream:.entabing (txt-> std::format::format ("{: <*}", pr.len + 3, " "));
        codeStream:.write (tempTest);

        let base = std::format::format (" {}{} (", name.file (), tempFormat);
        codeStream:.write (base);
        codeStream:.detabing ();

        codeStream:.entabing (txt-> std::format::format ("{: <*}", base.len + pr.len + 3, " "));
        codeStream:.write (fstParam);
        for f in method.parameters {
            codeStream:.write (",\n");
            //if (method.parameters.len > 3) stream:.write ("\n");

            if f.isRef codeStream:.write ("ref ");
            if f.isLazy codeStream:.write ("lazy ");
            if f.isMut codeStream:.write ("mut ");
            if f.isDMut codeStream:.write ("dmut ");
            codeStream:.write (f.name, " : ", self.dumpType (f.type));
            if (f.defaultValue != "") codeStream:.write (" = ", f.defaultValue);
        }
        codeStream:.write (")");

        codeStream:.detabing ();
        codeStream:.entabing (txt-> std::format::format ("{: <*}", pr.len + 4, " "));
        if (method.parameters.len > 0) codeStream:.write ("\n");

        codeStream:.write ("-> ", self.dumpType (method.retType));

        if (method.throwers.len != 0) {
            codeStream:.write ("\nthrows ");
            for i, j in method.throwers {
                if (i != 0) codeStream:.write (", ");
                codeStream:.write (self.dumpType (j, andClass-> false));
            }
        }
        codeStream:.detabing ();

        formatter::format (alias innerStream, ressources::INLINE_CODE, copy ["Code" => codeStream[]]);
        innerStream:.write (self.dumpCommonSymbol (method));

        formatter::format (alias stream, ressources::DECLARATION, copy ["Kind" => "fn",
                                                                        "Name" => name.file (),
                                                                        "Templates" => tempFormat,
                                                                        "Content" => innerStream[]]);
    } catch {
        _ => {}
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          ENUMERATION          ===================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Dump the html representation of a enum symbol
     * */
    fn dumpEnum (self, dmut stream : &StringStream, e : &EnumSymbol, templateTest : [c8] = "", templates : [&TemplateParam] = []) {
        let p = Path (e.name, sep-> "::");

        let tempFormat = self.dumpTemplates (templates);
        let tempTest = self.dumpTemplateTest (templateTest);

        let pr = self.dumpProtection (e.protect);
        let type = if let en : &EnumType = e.type {
            ": " ~ self.dumpType (en.proxy, withMut-> false)
        } else { "" };

        let code = std::format::format ("{} enum {}{}{}\n-> {} ", pr, tempTest, tempFormat, type, p.file ());

        let dmut codeStream = copy StringStream ();
        formatter::format (alias codeStream, ressources::INLINE_CODE, copy ["Code" => code]);
        codeStream:.write (self.dumpCommonSymbol (e));

        let dmut contentStream = copy StringStream ();
        for c in e.fields {
            let dmut fieldStream = copy StringStream ();
            formatter::format (alias fieldStream, ressources::INLINE_CODE, copy ["Code" => std::format::format ("{} = {}", c.0, c.1)]);
            fieldStream:.write (self.dumpComments (c.2));

            formatter::format (alias contentStream, ressources::DECLARATION, copy ["Kind" => "let",
                                                                                   "Name" => c.0,
                                                                                   "Templates" => "",
                                                                                   "Content" => fieldStream[]]);
        }

        formatter::format (alias codeStream, ressources::MEMBERS, copy ["Content" => contentStream[]]);
        formatter::format (alias stream, ressources::DECLARATION, copy ["Kind" => "enum",
                                                                        "Name" => p.file (),
                                                                        "Templates" => (tempFormat ~ tempTest),
                                                                        "Content" => codeStream[]]);
    } catch {
        _ => {}
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ================================          GLOBAL VARIABLE          =================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Dump the html representation of a global symbol
     * */
    fn dumpGlobal (self, dmut stream : &StringStream, g : &Global) {
        let p = Path (g.name, sep-> "::");

        let dmut codeStream = copy StringStream ();
        if (g.isThreadLocal) { codeStream:.write ("@thread\n"); }
        let pr = self.dumpProtection (g.protect);

        let kind = if (g.isStatic) { "static" } else { "lazy" };
        codeStream:.write (pr, " ", kind, " ", p.file ());
        if let a : &AnyType = g.type {
             if (a.name != "") codeStream:.write (" : ", self.dumpType (a));
        } else {
            codeStream:.write (" : ", self.dumpType (g.type));
        }

        if (g.value != "") {
            codeStream:.write (" = ", g.value);
        }

        let dmut innerStream = copy StringStream ();
        formatter::format (alias innerStream, ressources::INLINE_CODE, copy ["Code" => codeStream[]]);
        innerStream:.write (self.dumpCommonSymbol (g));

        formatter::format (alias stream, ressources::DECLARATION, copy ["Kind" => "let",
                                                                        "Name" => p.file (),
                                                                        "Templates" => "",
                                                                        "Content" => innerStream[]]);
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          MACRO          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Dump the html representation of a global symbol
     * */
    fn dumpMacro (self, dmut stream : &StringStream, m : &Macro) {
        let p = Path (m.name, sep-> "::");

        let dmut codeStream = copy StringStream ();
        codeStream:.write (self.dumpProtection (m.protect), " macro ", p.file ());

        let dmut innerStream = copy StringStream ();
        formatter::format (alias innerStream, ressources::INLINE_CODE, copy ["Code" => codeStream[]]);
        innerStream:.write (self.dumpCommonSymbol (m));

        let dmut contentStream = copy StringStream ();
        self.dumpMacroCtors (alias contentStream, m.ctors);
        self.dumpMacroRules (alias contentStream, m.rules);

        formatter::format (alias innerStream, ressources::MEMBERS, copy ["Content" => contentStream[]]);
        formatter::format (alias stream, ressources::DECLARATION, copy ["Kind" => "macro",
                                                                        "Name" => p.file (),
                                                                        "Templates" => "",
                                                                        "Content" => innerStream[]]);
    }

    /**
     * Dump the ctors of a macro
     */
    fn dumpMacroCtors (self, dmut stream : &StringStream, rules : [&MacroRule]) {
        if (rules.len == 0us) return;

        let dmut innerStream = copy StringStream ();
        for r in rules {
            self.dumpMacroRule (alias innerStream, r, kind-> "self");
        }

        if (innerStream[].len != 0us)
            formatter::format (alias stream, ressources::MEMBER_HEAD, copy ["Kind" => "Constructors",
                                                                            "Content" => innerStream[]]);
    }

    /**
     * Dump the rules of a macro
     * */
    fn dumpMacroRules (self, dmut stream : &StringStream, rules : [&MacroRule]) {
        if (rules.len == 0us) return;

        let dmut innerStream = copy StringStream ();
        for r in rules {
            self.dumpMacroRule (alias innerStream, r, kind-> "fn");
        }

        if (innerStream[].len != 0us)
            formatter::format (alias stream, ressources::MEMBER_HEAD, copy ["Kind" => "Rules",
                                                                            "Content" => innerStream[]]);
    }

    /**
     * Dump the html representation of a macro rule
     * */
    fn dumpMacroRule (self, dmut stream : &StringStream, rule : &MacroRule, kind : [c8]) {
        let n = Path (rule.name);
        let name = if kind == "self" { "" } else { " " ~ n.file () };

        let dmut innerStream = copy StringStream ();
        let dmut code = copy StringStream ();
        code:.write (self.dumpProtection (rule.protect), " ", kind);
        let entab = std::format::format ("{: <*}", code[].len - 1, " ");
        code:.entabing (txt-> entab);
        code:.write (name, " (\n");

        code:.write (rule.rule);
        code:.detabing ();
        code:.write ("\n)\n");

        if (rule.skips.len != 0) {
            code:.write ("skips ");
            for i, j in rule.skips {
                if i != 0 { code:.write (" | "); }
                code:.write (j);
            }
        }

        formatter::format (alias innerStream, ressources::INLINE_CODE, copy ["Code" => code[]]);
        innerStream:.write (self.dumpCommonSymbol (rule));

        formatter::format (alias stream, ressources::DECLARATION, copy ["Kind" => kind,
                                                                        "Name" => n.file (),
                                                                        "Templates" => "",
                                                                        "Content" => innerStream[]]);
    } catch {
        _ => {}
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          TYPES          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Dump the html code representing a type
     * */
    fn dumpType (self, type : &Type, andClass : bool = true, withMut : bool = true) -> [c8] {
        let inner = match type {
            a : &ArrayType => {
                std::format::format ("[{} ; {}]", self.dumpType (a.child, withMut-> withMut && !type.isDMut), a.len)
            }
            s : &ScalarType => { s.name }
            c : &ClassType => {
                let beg = if self.isLocal (c.module) {
                    "<a class=\"symbol-link\" href=\"#" ~ c.name ~ "\">"
                } else {
                    "<a class=\"symbol-link\" href=\"" ~ c.module.toStr (sep-> "_") ~ ".html#" ~ c.name ~ "\">"
                };

                if (c.isClass && andClass) {
                    if c.innerMut && withMut {
                        "&(mut " ~ beg ~ c.fullName ~ "</a>)"
                    } else {
                        "&(" ~ beg ~ c.fullName ~ "</a>)"
                    }
                }
                else { beg ~ c.fullName ~ "</a>" }
            }
            e : &EnumType => {
                if self.isLocal (e.module) {
                    "<a class=\"symbol-link\" href=\"#" ~ e.name ~ "\">" ~ e.fullName ~ "</a>"
                } else {
                    "<a class=\"symbol-link\" href=\"./" ~ e.module.toStr (sep-> "_") ~ ".html#" ~ e.name ~ "\">" ~ e.fullName ~ "</a>"
                }
            }
            o : &OptionType => { std::format::format ("({})?", self.dumpType (o.child, withMut-> withMut && !type.isDMut && !type.isDMut)) }
            p : &PointerType => { std::format::format ("*({})", self.dumpType (p.child, withMut-> withMut && !type.isDMut)) }
            m : &MapType => { std::format::format ("[{} => {}]", self.dumpType (m.key, withMut-> withMut && !type.isDMut), self.dumpType (m.value, withMut-> withMut && !type.isDMut)) }
            r : &RangeType => { std::format::format ("..{}", self.dumpType (r.child, withMut-> withMut && !type.isDMut)) }
            s : &SliceType => { std::format::format ("[{}]", self.dumpType (s.child, withMut-> withMut && !type.isDMut)) }
            t : &TupleType => {
                let dmut stream = copy StringStream ();
                stream:.write ("(");
                for i, j in t.childs {
                    if (i != 0us) stream:.write (",");
                    stream:.write (self.dumpType (j, withMut-> withMut && !type.isDMut));
                }
                stream:.write (")");
                stream[]
            }
            fptr : &FuncPtrType => {
                let dmut stream = copy StringStream ();
                if (fptr.isDelegate) stream:.write ("dg (");
                else stream:.write ("fn (");
                for i, j in fptr.parameters {
                    if (i != 0) stream:.write (", ");
                    if (fptr.refs [i]) stream:.write ("ref ");
                    if (fptr.lazys [i]) stream:.write ("lazy ");
                    stream:.write (self.dumpType (j, withMut-> withMut && !type.isDMut));
                }
                stream:.write (")-> ", self.dumpType (fptr.retType, withMut-> withMut && !type.isDMut));
                stream[]
            }
            a : &AnyType => {
                if a.name == "<empty>" {
                    return "void";
                }

                if (a.module.toStr () == "") { a.fullName }
                else {
                    let beg = if self.isLocal (a.module) {
                        "<a class=\"symbol-link\" href=\"#" ~ a.name ~ "\">"
                    } else {
                        "<a class=\"symbol-link\" href=\"" ~ a.module.toStr (sep-> "_") ~ ".html#" ~ a.name ~ "\">"
                    };

                    beg ~ a.fullName ~ "</a>"
                }
            }
            _ => { "" }
        }

        if (type.isMut && inner.len != 0us && withMut) {
            "mut " ~ inner
        } else if (type.isDMut && inner.len != 0 && withMut) {
            "dmut " ~ inner
        } else inner
    } catch {
        _ => {
            ""
        }
    }

    /**
     * Convert a protection into string
     */
    fn dumpProtection (self, protection : Protection)-> [c8] {
        match protection {
            Protection::PUB => { "pub" }
            Protection::PROT => { "prot" }
            _ => { "prv" }

        }
    }

    fn dumpTemplates (self, params : [&TemplateParam])-> [c8] {
        if (params.len == 0) return "";

        let dmut stream = copy StringStream ();
        stream:.write (" {");
        for i, j in params {
            if i != 0 stream:.write (", ");
            stream:.write (j);
        }
        stream:.write ("}");
        stream[]
    }

    fn dumpTemplateTest (self, test : [c8])-> [c8] {
        if (test == []) return "";

        " if (" ~ test ~ ")\n"
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          CHECKING          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    fn isLocal (self, p : Path)-> bool {
        self._path == p
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          LOADING          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Load the content to export symbols in the correct order
     * */
    fn loadContent (mut self) {
        for ch in self._module.childs {
            self:.loadElement (ch, ch);
        }

        sort (alias self._modules, |x, y| => { x.name < y.name });
        sort (alias self._akas, |x, y| => { x.name < y.name });
        sort (alias self._classes, |x, y| => { x.name < y.name });
        sort (alias self._traits, |x, y| => { x.name < y.name });
        sort (alias self._enums, |x, y| => { x.name < y.name });
        sort (alias self._functions, |x, y| => { x.name < y.name });
        sort (alias self._globals, |x, y| => { x.name < y.name });
        sort (alias self._macros, |x, y| => { x.name < y.name });
    }

    /**
     * Load an element in the correct collection
     * */
    fn loadElement (mut self, root : &Symbol, element : &Symbol) {
        match element {
            Module () => { self._modules ~= [root]; }
            Aka () => { self._akas ~= [root]; }
            ClassSymbol () => { self._classes ~= [root]; }
            TraitSymbol () => { self._traits ~= [root]; }
            EnumSymbol () => { self._enums ~= [root]; }
            Function () => { self._functions ~= [root]; }
            Global () => { self._globals ~= [root]; }
            Macro () => { self._macros ~= [root]; }
            t : &Template => {
                if (t.inners.len <= 1) {
                    for c in t.inners {
                        self:.loadElement (root-> t, c);
                    }
                } else {
                    for c in t.inners {
                        let dmut newTemplate = copy Template (t.name, t.doc, t.loc, t.protect);
                        newTemplate.test = t.test;
                        newTemplate.params = t.params;
                        newTemplate.inners = copy [c];
                        self:.loadElement (root-> newTemplate, c);
                    }
                }
            }
        }
    }

}
