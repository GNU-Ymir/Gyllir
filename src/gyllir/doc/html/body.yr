in body;

use std::{stream,
          format,
          conv, fs::path};

use gyllir::doc::{_, symbols::_, types::_, comment::parser};
use gyllir::repo::defaults;

/**
 * Html body of a page 
 */
@final
pub class HtmlBody over HtmlNode {

    // Test of assertion
    cte assert (true, "msg");

    // The module to dump
    let _module : &Module;

    // The name of the project
    let _project : [c8];

    /**
     * @params: 
     *    - project: the name of the project
     *    - module: the content of the page to dump
     */
    pub self (project : [c8], module : &Module)
        with _project = project, _module = module
    {}
    
    /**
     * Dump the module into a html page
     * @params:
     *    - stream: the stream to populate
     */
    pub over dumpHtml (self, dmut stream : &StringStream) {
        let content = copy ["Content" => self.dumpCommonSymbol (self._module)];
        formatter::format (alias stream, ressources::MODULE_HEAD, content);
        
        for ch in self._module.childs if ch !of Module {
            self.dumpContent (alias stream, ch);
        }
    }

    /**
     * Dump the elements common to all symbols
     * @params:
     *     - s: the symbol to dump
     */
    fn dumpCommonSymbol (self, s : &Symbol)-> [c8] {
        let dmut stream = copy StringStream ();
        let p = copy CommentParser (s.doc);
        stream:.write ("<div class=\"doc\">");
        p.dumpHtml (alias stream);
        stream:.write ("</div>");

        stream[]
    }

    /**
     * Dump the comments
     */
    fn dumpComments (self, comm : [c8])-> [c8] {
        let dmut stream = copy StringStream ();
        let p = copy CommentParser (comm);
        stream:.write ("<div class=\"doc\">");
        p.dumpHtml (alias stream);
        stream:.write ("</div>");

        stream[]
    }



    /**
     * Dump a symbol into html
     * @params: 
     *    - stream: the stream to populate
     *    - sym: the symbol to dump
     */
    fn dumpContent (self, dmut stream : &StringStream, sym : &Symbol, templates : [&TemplateParam] = [], templateTest : [c8] = []) {
        stream;
        sym;
        templates;
        templateTest;

        match sym {
            a : &Aka        => self.dumpAka (alias stream, a, templates-> templates, templateTest-> templateTest);
            c : &ClassSymbol      => self.dumpClass (alias stream, c, templates-> templates, templateTest-> templateTest);
            // c : &Ctor       => self.dumpCtor (alias stream, c, templates-> templates, templateTest-> templateTest);
            // e : &EnumSymbol => self.dumpEnum (alias stream, e, templates-> templates, templateTest-> templateTest);
            f : &Function   => self.dumpFunction (alias stream, f, templates-> templates, templateTest-> templateTest);
            // g : &Global     => self.dumpGlobal (alias stream, v, templates-> templates, templateTest-> templateTest);
            // m : &Macro      => self.dumpMacro (alias stream, m, templates-> templates, templateTest-> templateTest);
            // m : &Method     => self.dumpMethod (alias stream, m, templates-> templates, templateTest-> templateTest);
            // v : &Variable   => self.dumpVariable (alias stream, m, templates-> templates, templateTest-> templateTest);
            // t : &Trait      => self.dumpTrait (alias stream, t, templates-> templates, templateTest-> templateTest);
            t : &Template => {
                for c in t.inners {
                    self.dumpContent (alias stream, c, templates-> t.params, templateTest-> t.test);
                }
            }
        }
    }

    /**
     * Dump an aka to html
     * @params:
     *    - stream: the stream to populate
     *    - a: the aka to dump
     */
    fn dumpAka (self, dmut stream : &StringStream, a : &Aka, templateTest : [c8] = "", templates : [&TemplateParam] = []) {
        let p = Path (a.name, sep-> "::");
        let dmut innerStream = copy StringStream ();

        let (token, end) = if a.isValue { ("=", a.value) } else { (":", self.dumpType (a.type)) };


        let tempFormat = self.dumpTemplates (templates);
        let tempTest = self.dumpTemplateTest (templateTest);

        let code = std::format::format ("{} def {}{}{} {} {}",
                                        self.dumpProtection (a.protect),
                                        tempTest,
                                        p.file (),
                                        tempFormat,
                                        token, end);

        formatter::format (alias innerStream, ressources::INLINE_CODE, copy ["Code" => code]);
        innerStream:.write (self.dumpCommonSymbol (a));

        formatter::format (alias stream, ressources::DECLARATION, copy ["Kind" => "def",
                                                                        "Name" => p.file (),
                                                                        "Templates" => (tempFormat ~ tempTest),
                                                                        "Content" => innerStream[]]);
    } catch {
        _ => {}
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          CLASS          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Dump a class to html
     * @params:
     *    - stream: the stream to populate
     *    - c: the class to dump
     */
    fn dumpClass (self, dmut stream : &StringStream, c : &ClassSymbol, templateTest : [c8] = "", templates : [&TemplateParam] = []) {
        let p = Path (c.name, sep-> "::");
        let dmut innerStream = copy StringStream ();

        let tempFormat = self.dumpTemplates (templates);
        let tempTest = self.dumpTemplateTest (templateTest);

        let kind = if c.isRecord { "record" } else if c.isEntity { "entity" } else { "class" };

        let ancestor = if (c.ancestor of ClassType) {
            std::format::format ("over {}", self.dumpType (c.ancestor))
        } else {
            ""
        };

        let dmut impls = copy StringStream ();
        for im in c.implements {
            let test = if im.1 == "" { "" } else { "if " ~ im.1 };
            impls:.write (std::format::format ("\t{}impl {};\n", test, self.dumpType (im.0)));
        }

        let attrs =
            if (c.isFinal) { "@final\n"
            } else if (c.isAbstract) { "@abstract\n"
            } else { "" };

        let code = std::format::format ("{}{} {}{} {}{} {} {{ \n\t/** full declaration omitted */ \n\n{}}",
                                        attrs,
                                        self.dumpProtection (c.protect),
                                        kind,
                                        tempTest,
                                        p.file (),
                                        tempFormat,
                                        ancestor,
                                        impls[]);

        formatter::format (alias innerStream, ressources::INLINE_CODE, copy ["Code" => code]);
        innerStream:.write (self.dumpCommonSymbol (c));

        let dmut contentStream = copy StringStream ();
        self.dumpClassAssertions (alias contentStream, c.asserts);
        self.dumpClassFields (alias contentStream, c.fields);
        self.dumpClassConditionalFields (alias contentStream, c.cond_fields);
        self.dumpClassCstrs (alias contentStream, c.ctors);
        self.dumpClassConditionalCstrs (alias contentStream, c.cond_ctors);

        // self.dumpClassMethods (alias contentStream, c.ctors);
        // self.dumpClassMethods (alias contentStream, c, fromTemplate-> tempParams != "");

        formatter::format (alias innerStream, ressources::MEMBERS, copy ["Content" => contentStream[]]);
        formatter::format (alias stream, ressources::DECLARATION, copy ["Kind" => kind,
                                                                        "Name" => p.file (),
                                                                        "Templates" => (tempFormat ~ tempTest),
                                                                        "Content" => innerStream[]]);
    } catch {
        _ => {}
    }

    /**
     * Dump the assertions of a class
     * */
    fn dumpClassAssertions (self, dmut stream : &StringStream, assertions : [Assertion]) {
        if (assertions.len == 0us) return;
        let dmut innerStream = copy StringStream ();

        for a in assertions {
            let dmut inner = copy StringStream ();
            let cond = if (a.condition != "") { "if " ~ a.condition } else { "" };
            let msg = if (a.msg != "") { ", " ~ a.msg } else { "" };
            let code = std::format::format ("{}cte assert ({}{})", cond, a.test, msg);

            formatter::format (alias inner, ressources::INLINE_CODE, copy ["Code" => code]);
            inner:.write (self.dumpComments (a.doc));

            // innerStream:.write (inner[]);
            formatter::format (alias innerStream, ressources::DECLARATION, copy ["Kind" => "assert",
                                                                                 "Name" => "",
                                                                                 "Templates" => cond,
                                                                                 "Content" => inner[]]);
        }

        if (innerStream[].len != 0us)
            formatter::format (alias stream, ressources::MEMBER_HEAD, copy ["Kind" => "Assertions",
                                                                            "Content" => innerStream[]]);
    } catch {
        _ => {}
    }

    /**
     * Dump the cstrs of the class into the stream
     * @params:
     *     - stream: the stream to populate
     *     - c: the class containing cstrs to dump
     */
    fn dumpClassCstrs (self, dmut stream : &StringStream, ctors : [&Ctor]) {
        if (ctors.len == 0us) return;
        let dmut innerStream = copy StringStream ();

        for p in ctors {
            self.dumpCtor (alias innerStream, p);
        }

        if (innerStream[].len != 0us)
            formatter::format (alias stream, ressources::MEMBER_HEAD, copy ["Kind" => "Constructors",
                                                                            "Content" => innerStream[]]);
    }

    /**
     * Dump the cstrs of the class into the stream
     * @params:
     *     - stream: the stream to populate
     *     - c: the class containing cstrs to dump
     */
    fn dumpClassConditionalCstrs (self, dmut stream : &StringStream, ctors : [(&Ctor, [c8])]) {
        if (ctors.len == 0us) return;
        let dmut innerStream = copy StringStream ();

        for p in ctors {
            self.dumpCtor (alias innerStream, p.0, templateTest-> p.1);
        }

        if (innerStream[].len != 0us)
            formatter::format (alias stream, ressources::MEMBER_HEAD, copy ["Kind" => "Conditional Constructors",
                                                                            "Content" => innerStream[]]);
    }

    /**
     * Dump a list of fields
     * @params:
     *     - stream: the stream to populate
     *     - c: the fields to dump
     */
    fn dumpClassFields (self, dmut stream : &StringStream, fields : [&Variable]) {
        if (fields.len == 0us) return;

        let dmut innerStream = copy StringStream ();
        for p in fields {
            let dmut innerStream2 = copy StringStream ();

            let value = if (p.defaultValue.len != 0) {
                std::format::format (" = {}", p.defaultValue)
            } else { "" };

            let mut type = self.dumpType (p.type);
            type = if (type.len != 0us) {
                std::format::format (" : {}", type)
            } else { "" };

            let isMut = if (p.isMut) { " mut" } else { "" };
            let isRef = if (p.isRef) { " ref" } else { "" };

            let code = std::format::format ("{} let{}{} {}{}{};",
                                            self.dumpProtection (p.protect),
                                            isRef,
                                            isMut,
                                            p.name,
                                            type,
                                            value);

            formatter::format (alias innerStream2, ressources::INLINE_CODE, copy ["Code" => code]);
            innerStream2:.write (self.dumpCommonSymbol (p));

            formatter::format (alias innerStream, ressources::DECLARATION, copy ["Kind" => "let",
                                                                                 "Name" => p.name,
                                                                                 "Templates" => "",
                                                                                 "Content" => innerStream2[]]);
        }

        if (innerStream[].len != 0)
            formatter::format (alias stream, ressources::MEMBER_HEAD, copy ["Kind" => "Fields",
                                                                            "Content" => innerStream[]]);
    } catch {
        _ => {}
    }

    /**
     * Dump a list of conditional fields
     * @params:
     *     - stream: the stream to populate
     *     - c: the fields to dump
     */
    fn dumpClassConditionalFields (self, dmut stream : &StringStream, fields : [(&Variable, [c8])]) {
        if (fields.len == 0us) return;

        let dmut innerStream = copy StringStream ();
        for v in fields {
            let p = v.0;
            let dmut innerStream2 = copy StringStream ();

            let value = if (p.defaultValue.len != 0) {
                std::format::format (" = {}", p.defaultValue)
            } else { "" };

            let mut type = self.dumpType (p.type);
            type = if (type.len != 0us) {
                std::format::format (" : {}", type)
            } else { "" };

            let isMut = if (p.isMut) { " mut" } else { "" };
            let isRef = if (p.isRef) { " ref" } else { "" };

            let code = std::format::format ("{}if {} let{}{} {}{}{};",
                                            self.dumpProtection (p.protect),
                                            v.1,
                                            isRef,
                                            isMut,
                                            p.name,
                                            type,
                                            value);

            formatter::format (alias innerStream2, ressources::INLINE_CODE, copy ["Code" => code]);
            innerStream2:.write (self.dumpCommonSymbol (p));

            formatter::format (alias innerStream, ressources::DECLARATION, copy ["Kind" => "let",
                                                                                 "Name" => p.name,
                                                                                 "Templates" => "if " ~ v.1,
                                                                                 "Content" => innerStream2[]]);
        }

        if (innerStream[].len != 0)
            formatter::format (alias stream, ressources::MEMBER_HEAD, copy ["Kind" => "Conditional Fields",
                                                                            "Content" => innerStream[]]);
    } catch {
        _ => {}
    }


    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          FUNCTIONS          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Dump the html representation of a function
     */
    fn dumpFunction (self, dmut stream : &StringStream, func : &Function, templateTest : [c8] = "", templates : [&TemplateParam] = []) {
        let name = Path (func.name, sep-> "::");

        let dmut innerStream = copy StringStream ();
        let tempFormat = self.dumpTemplates (templates);
        let tempTest = self.dumpTemplateTest (templateTest);

        let dmut codeStream = copy StringStream ();

        if func.isInline && func.isUnsafe { codeStream:.write ("@{unsafe, inline}"); }
        else if func.isInline { codeStream:.write ("@inline"); }
        else if func.isUnsafe { codeStream:.write ("@unsafe"); }

        let base = std::format::format ("{} {}fn {}{}{} (",
                                        self.dumpProtection (func.protect),
                                        tempTest,
                                        name.file (), tempFormat);
        codeStream:.write (base);
        codeStream:.entabing (txt-> std::format::format ("{: <8}", base.len));
        for i, f in func.parameters {
            if (i != 0) {
                codeStream:.write (", ");
                if (func.parameters.len > 4) stream:.write ("\n");
            }

            if f.isRef codeStream:.write ("ref ");
            if f.isLazy codeStream:.write ("lazy ");
            if f.isMut codeStream:.write ("mut ");
            codeStream:.write (f.name, " : ", self.dumpType (f.type));
            if (f.defaultValue != "") codeStream:.write (" = ", f.defaultValue);
        }
        codeStream:.detabing ();
        codeStream:.write (")-> ", self.dumpType (func.retType));

        if (func.throwers.len != 0) {
            codeStream:.entabing ();
            codeStream:.write ("\n\tthrows ");
            for i, j in func.throwers {
                if (i != 0) codeStream:.write (", ");
                codeStream:.write (self.dumpType (j, andClass-> false));
            }
            codeStream:.detabing ();
        }

        formatter::format (alias innerStream, ressources::INLINE_CODE, copy ["Code" => codeStream[]]);
        innerStream:.write (self.dumpCommonSymbol (func));

        formatter::format (alias stream, ressources::DECLARATION, copy ["Kind" => "fn",
                                                                        "Name" => name.file (),
                                                                        "Templates" => (tempFormat ~ tempTest),
                                                                        "Content" => innerStream[]]);
    } catch {
        _ => {}
    }

    /**
     * Dump the html representation of a constructor
     * */
    fn dumpCtor (self, dmut stream : &StringStream, ctor : &Ctor, templateTest : [c8] = "", templates : [&TemplateParam] = []) {
        let name = Path (ctor.name, sep-> "::");

        let dmut innerStream = copy StringStream ();
        let tempFormat = self.dumpTemplates (templates);
        let tempTest = self.dumpTemplateTest (templateTest);

        let dmut codeStream = copy StringStream ();
        if (ctor.isUnsafe) codeStream:.write ("@unsafe");

        let rename = if (name.file () == "self") { "" } else { " " ~ name.file () };

        let base = std::format::format ("{} {}self{}{}{} (",
                                        self.dumpProtection (ctor.protect),
                                        tempTest,
                                        rename,
                                        tempFormat);
        codeStream:.write (base);
        codeStream:.entabing (txt-> std::format::format ("{: <8}", base.len));
        for i, f in ctor.parameters {
            if (i != 0) {
                codeStream:.write (", ");
                if (ctor.parameters.len > 4) stream:.write ("\n");
            }

            if f.isRef codeStream:.write ("ref ");
            if f.isLazy codeStream:.write ("lazy ");
            if f.isMut codeStream:.write ("mut ");
            codeStream:.write (f.name, " : ", self.dumpType (f.type));
            if (f.defaultValue != "") codeStream:.write (" = ", f.defaultValue);
        }

        codeStream:.write (")");
        codeStream:.detabing ();

        if (ctor.throwers.len != 0) {
            codeStream:.entabing ();
            codeStream:.write ("\n\tthrows ");
            for i, j in ctor.throwers {
                if (i != 0) codeStream:.write (", ");
                codeStream:.write (self.dumpType (j, andClass-> false));
            }
            codeStream:.detabing ();
        }

        formatter::format (alias innerStream, ressources::INLINE_CODE, copy ["Code" => codeStream[]]);
        innerStream:.write (self.dumpCommonSymbol (ctor));

        formatter::format (alias stream, ressources::DECLARATION, copy ["Kind" => "ctor",
                                                                        "Name" => name.file (),
                                                                        "Templates" => (tempFormat ~ tempTest),
                                                                        "Content" => innerStream[]]);
    } catch {
        _ => {}
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          TYPES          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Dump the html code representing a type
     * */
    fn dumpType (self, type : &Type, andClass : bool = true) -> [c8] {
        let inner = match type {
            a : &ArrayType => {
                std::format::format ("[{} ; {}]", self.dumpType (a.child), a.len)
            }
            s : &ScalarType => { s.name }
            c : &ClassType => {
                let beg = "<a href=\"" ~ c.module.toStr (sep-> "_") ~ ".html#" ~ c.name ~ "\">";
                if (c.isClass && andClass) {
                    if c.innerMut {
                        "&(mut " ~ beg ~ c.name ~ "</a>)"
                    } else {
                        "&(" ~ beg ~ c.name ~ "</a>)"
                    }
                }
                else { beg ~ c.name ~ "</a>" }
            }
            e : &EnumType => { "<a href=\"" ~ e.module.toStr (sep-> "_") ~ ".html#" ~ e.name ~ "\">" ~ e.name ~ "</a>" }
            o : &OptionType => { std::format::format ("({})?", self.dumpType (o.child)) }
            p : &PointerType => { std::format::format ("*({})", self.dumpType (p.child)) }
            m : &MapType => { std::format::format ("[{} => {}]", self.dumpType (m.key), self.dumpType (m.value)) }
            r : &RangeType => { std::format::format ("..{}", self.dumpType (r.child)) }
            s : &SliceType => { std::format::format ("[{}]", self.dumpType (s.child)) }
            t : &TupleType => {
                let dmut stream = copy StringStream ();
                stream:.write ("(");
                for i, j in t.childs {
                    if (i != 0us) stream:.write (",");
                    stream:.write (self.dumpType (j));
                }
                stream:.write (")");
                stream[]
            }
            fptr : &FuncPtrType => {
                let dmut stream = copy StringStream ();
                if (fptr.isDelegate) stream:.write ("dg (");
                else stream:.write ("fn (");
                for i, j in fptr.parameters {
                    if (i != 0) stream:.write (", ");
                    if (fptr.refs [i]) stream:.write ("ref ");
                    if (fptr.lazys [i]) stream:.write ("lazy ");
                    stream:.write (self.dumpType (j));
                }
                stream:.write (")-> ", self.dumpType (fptr.retType));
                stream[]
            }
            a : &AnyType => {
                if a.name == "<empty>" {
                    return "void";
                }

                if (a.module.toStr () == "") { a.name }
                else {
                    "<a href=\"" ~ a.module.toStr (sep-> "_") ~ ".html#" ~ a.name ~ "\">" ~ a.name ~ "</a>"
                }
            }
            _ => { "" }
        }

        if (type.isMut && inner.len != 0us) {
            "mut " ~ inner
        } else inner
    } catch {
        _ => {
            ""
        }
    }

    /**
     * Convert a protection into string
     */
    fn dumpProtection (self, protection : Protection)-> [c8] {
        match protection {
            Protection::PUB => { "pub" }
            Protection::PROT => { "prot" }
            _ => { "prv" }

        }
    }

    fn dumpTemplates (self, params : [&TemplateParam])-> [c8] {
        if (params.len == 0) return "";

        let dmut stream = copy StringStream ();
        stream:.write ("{");
        for i, j in params {
            if i != 0 stream:.write (", ");
            stream:.write (j);
        }
        stream:.write ("}");
        stream[]
    }

    fn dumpTemplateTest (self, test : [c8])-> [c8] {
        if (test == []) return "";

        " if (" ~ test ~ ") "
    }

}
