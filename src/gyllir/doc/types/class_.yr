in class_;

use std::{stream, fs::path};

/**
 * A classure type
 */
pub class ClassType over Type {

    pub let mut fullName : [c8];
    pub let mut name : [c8];

    pub let innerMut : bool;

    // True iif this is an entity
    pub let isEntity : bool;

    // True iif this is a record
    pub let isRecord : bool;

    // The path to the module declaration
    pub let mut module : Path;

    /**
     * @params: 
     *   - name: the name of the class
     *   - isMut: bool is the class is mutable
     */
    pub self (name : [c8], mutability : [c8], innerMut : bool, isEntity : bool = false, isRecord : bool = false)
        with super (mutability-> mutability)
        , fullName = name
        , name = Path (name, sep-> "::"s8).file ()
        , module = Path (name, sep-> "::"s8).parent ()
        , isEntity = isEntity
        , isRecord = isRecord
        , innerMut = innerMut
    {
        if let Ok (f) = std::algorithm::searching::find (self.fullName, '!') {
            if let Ok (e) = std::algorithm::searching::rfind (self.fullName, '}') {
                let templates = self.fullName [f .. e + 1];
                let res_name = self.fullName [0 .. f];
                self.module = Path (res_name, sep-> "::").parent ();
                self.name = Path (res_name, sep-> "::").file () ~ templates;
                self.fullName = res_name ~ templates;
            }
        }
    }

    @field
    pub fn isClass (self)-> bool {
        !self.isEntity && !self.isRecord
    }

    impl Streamable {
        pub over toStream (self, dmut stream : &StringStream) {
            if self.isEntity {
                stream:.write ("Entity");
            } else if self.isRecord {
                stream:.write ("Record");
            } else {
                stream:.write ("Class");
            }

            stream:.write (" (", self.module.push (self.name).toStr (sep-> "::"), ")");
        }
    }
}
