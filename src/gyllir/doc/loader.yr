in loader;

use std::{io, config::_, format};
use gyllir::doc::{symbols::_, types::_};


pub record SymbolLoader {

    /**
     * Create an empty symbol loader
     * */
    pub self () {}

    /**
     * Load a configuration and return the symbol found in it
     * */
    pub fn load (self, config : &Config)-> &Symbol {
        if let d : &Dict = config && "kind" in d {
            if let Ok (x) = d ["kind"]? match x {
                Str (value-> "module") => { return self.loadModule (d); }
                Str (value-> "function") => { return self.loadFunction (d); }
                Str (value-> "method") => { return self.loadMethod (d); }
                Str (value-> "ctor") => { return self.loadCtor (d); }
                Str (value-> "class") => { return self.loadClass (d); }
                Str (value-> "entity") => { return self.loadClass (d, isEntity-> true); }
                Str (value-> "record") => { return self.loadClass (d, isRecord-> true); }
            }
        }

        copy symbols::none_::None ()
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          MODULE          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Load the configuration of a module documentation
     * */
    fn loadModule (self, module : &Dict)-> &Module {
        let (name, doc, loc, protection) = self.loadStandard (module);
        let dmut result = copy Module (name, doc, loc, protection);

        if let Ok (ch) = module ["childs"]? match ch {
            a : &Array => {
                for x in a[] {
                    let i = self.load (x);
                    if (i !of none_::None) {
                        result.childs ~= [i];
                    }
                }
            }
        }

        result
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          FUNCTION          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */


    /**
     * Load a configuration of a function documentation
     * */
    fn loadFunction (self, func : &Dict)-> &Function {
        let (name, doc, loc, protection) = self.loadStandard (func);
        let dmut result = copy Function (name, doc, loc, protection);

        result.parameters = self.loadParams (func);
        if let Ok (attrs : &Array) = func ["attributes"]? {
            for a in attrs[] match a {
                Str (value-> "unsafe") => { result.isUnsafe = true; }
                Str (value-> "inline") => { result.isInline = true; }
            }
        }

        result.throwers = self.loadThrowers (func);
        if let Ok (d : &Dict) = func ["ret_type"]? {
            result.retType = self.loadType (d);
        }

        result
    }

    /**
     * Load a constructor
     * */
    fn loadCtor (self, func : &Dict)-> &Ctor {
        let (name, doc, loc, protection) = self.loadStandard (func);
        let dmut result = copy Ctor (name, doc, loc, protection);

        result.parameters = self.loadParams (func);
        if let Ok (attrs : &Array) = func ["attributes"]? {
            for a in attrs[] match a {
                Str (value-> "unsafe") => { result.isUnsafe = true; }
            }
        }

        result.throwers = self.loadThrowers (func);
        result
    }

    /**
     * Load a method
     * */
    fn loadMethod (self, func : &Dict)-> &Method {
        let (name, doc, loc, protection) = self.loadStandard (func);
        let dmut result = copy Method (name, doc, loc, protection);

        result.parameters = self.loadParams (func);
        if let Ok (attrs : &Array) = func ["attributes"]? {
            for a in attrs[] match a {
                Str (value-> "unsafe") => { result.isUnsafe = true; }
                Str (value-> "field") => { result.isField = true; }
                Str (value-> "final") => { result.isFinal = true; }
                Str (value-> "abstract") => { result.isEmpty = true; }
            }
        }

        result.isMutable = if let Ok (Str (value-> "true")) = func ["mutable"]? {
            true
        } else { false };

        result.throwers = self.loadThrowers (func);
        if let Ok (d : &Dict) = func ["ret_type"]? {
            result.retType = self.loadType (d);
        }

        result
    }

    /**
     * Load parameters from configuration
     * */
    fn loadParams (self, func : &Dict, key : [c8] = "params")-> [&Variable] {
        let mut vars : [mut &Variable] = [];
        if let Ok (params : &Array) = func [key]? {
            for a in params[] {
                let (name, doc, loc, protection) = self.loadStandard (a);
                let dmut var = copy Variable (name, doc, loc, protection);

                if let Ok (type : &Dict) =  a ["type"]? { var.type = self.loadType (type); }
                if let Ok (Str (value-> "true")) = a ["ref"]? { var.isRef = true; }
                if let Ok (Str (value-> "true")) = a ["lazy"]? { var.isLazy = true; }
                if let Ok (Str (value-> default)) = a ["value"]? { var.defaultValue = default; }

                if let Ok (Str (value-> m)) =  a ["mutability"]? {
                    var.isMut = (if (m == "dmut" || m == "mut") { true }
                                 else { false });
                }

                vars ~= [var];
            }
        }

        vars
    }

    /**
     * Load the throwers of a function/ctors/etc..
     * */
    fn loadThrowers (self, func : &Dict)-> [&Type] {
        let mut res : [mut &Type] = [];
        if let Ok (thrs : &Array) = func ["throwers"]? {
            for a in thrs[] if let d : &Dict = a {
                res ~= [self.loadType (d)];
            }
        }

        res
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          CLASS          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Load a class symbol
     * */
    fn loadClass (self, cl : &Dict, isEntity : bool = false, isRecord : bool = false)-> &ClassSymbol {
        let (name, doc, loc, protection) = self.loadStandard (cl);
        let dmut result = copy ClassSymbol (name, doc, loc, protection);
        result.isEntity = isEntity;
        result.isRecord = isRecord;

        if let Ok (Str (value-> "true")) = cl ["has_dtor"]? { result.hasDtor = true; }
        if let Ok (Str (value-> "true")) = cl ["abstract"]? { result.isAbstract = true; }
        if let Ok (Str (value-> "true")) = cl ["final"]? { result.isFinal = true; }
        if let Ok (anc : &Dict) = cl ["ancestor"]? { result.ancestor = self.loadType (anc); }

        result.fields = self.loadParams (cl, key-> "fields");
        if let Ok (arr : &Array) = cl ["ctors"]? {
            for c in arr[] if let d : &Dict = c {
                result.ctors ~= [self.loadCtor (d)];
            }
        }

        if let Ok (arr : &Array) = cl ["methods"]? {
            for c in arr[] if let d : &Dict = c {
                result.methods ~= [self.loadMethod (d)];
            }
        }

        result
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          TYPES          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Load a type from documentation configuration
     * */
    fn loadType (self, ty : &Dict)-> &Type {
        let isMut = if let Ok (Str (value-> m)) =  ty ["mutability"]? {
            if (m == "dmut" || m == "mut") { true }
            else { false }
        } else { false };

        if let Ok (x) = ty ["kind"]? match x {
            Str (value-> "fptr") => { return self.loadFuncPtrType (ty, isMut, isDelegate-> false); }
            Str (value-> "delegate") => { return self.loadFuncPtrType (ty, isMut, isDelegate-> true); }
            Str (value-> "array") => { return self.loadArrayType (ty, isMut); }
            Str (value-> "class") => { return self.loadClassType (ty, isMut); }
            Str (value-> "record") => { return self.loadClassType (ty, isMut, isRecord-> true); }
            Str (value-> "entity") => { return self.loadClassType (ty, isMut, isEntity-> true); }
            Str (value-> "enum") => { return self.loadEnumType (ty, isMut); }
            Str (value-> "option") => { return self.loadOptionType (ty, isMut); }
            Str (value-> "pointer") => { return self.loadPointerType (ty, isMut); }
            Str (value-> "range") => { return self.loadRangeType (ty, isMut); }
            Str (value-> "slice") => { return self.loadSliceType (ty, isMut); }
            Str (value-> "tuple") => { return self.loadTupleType (ty, isMut); }
            Str (value-> "map") => { return self.loadMapType (ty, isMut); }
            Str (value-> "scalar") => {
                let name = if let Ok (Str (value-> name)) = ty ["name"]? {
                    name
                } else { "" };

                return copy ScalarType (name, isMut);
            }
            _ => {
                let name = if let Ok (Str (value-> name)) = ty ["name"]? {
                    name
                } else { "" };

                return copy AnyType (name, isMut);
            }
        }

        EMPTY_ANY
    }

    /**
     * Load a function pointer from a config
     * */
    fn loadFuncPtrType (self, d : &Dict, isMut : bool, isDelegate : bool)-> &Type {
        let mut params : [mut &Type] = [];
        let mut refs : [mut bool] = [];
        let mut lazys : [mut bool] = [];
        if let Ok (a : &Array) = d ["params"]? {
            for i in a[] if let inner : &Dict = i {
                params ~= [self.loadType (inner)];
            }
        }

        if let Ok (a : &Array) = d ["refs"]? {
            for i in a[] if let Str (value-> b) = i {
                refs ~= [b == "true"];
            }
        }

        if let Ok (a : &Array) = d ["lazys"]? {
            for i in a[] if let Str (value-> b) = i {
                refs ~= [b == "true"];
            }
        }

        if (params.len != refs.len || params.len != lazys.len) {
            params = [];
            refs = [];
            lazys = [];
        }

        let retType = if let Ok (ret : &Dict) = d ["return"]? {
            self.loadType (ret)
        } else { EMPTY_ANY };

        copy FuncPtrType (isMut, isDelegate, params, refs, lazys, retType)
    }

    /**
     * Load the configuration of an array type
     * */
    fn loadArrayType (self, d : &Dict, isMut : bool)-> &Type {
        let len = if let Ok (Int (value-> len)) = d ["len"]? {
            cast!usize (len)
        } else { 0 };

        let inner = if let Ok (inner : &Dict) = d ["inner"]? {
            self.loadType (inner)
        } else { EMPTY_ANY };

        copy ArrayType (isMut, inner, len)
    }

    /**
     * Load the configuration of a slice type
     * */
    fn loadSliceType (self, d : &Dict, isMut : bool)-> &Type {
        let inner = if let Ok (inner : &Dict) = d ["inner"]? {
            self.loadType (inner)
        } else { EMPTY_ANY };

        copy SliceType (isMut, inner)
    }

    /**
     * Load the configuration of an option type
     * */
    fn loadOptionType (self, d : &Dict, isMut : bool)-> &Type {
        let inner = if let Ok (inner : &Dict) = d ["inner"]? {
            self.loadType (inner)
        } else { EMPTY_ANY };

        copy OptionType (isMut, inner)
    }

    /**
     * Load the configuration of a pointer type
     * */
    fn loadPointerType (self, d : &Dict, isMut : bool)-> &Type {
        let inner = if let Ok (inner : &Dict) = d ["inner"]? {
            self.loadType (inner)
        } else { EMPTY_ANY };

        copy PointerType (isMut, inner)
    }

    /**
     * Load the configuration of a range type
     * */
    fn loadRangeType (self, d : &Dict, isMut : bool)-> &Type {
        let inner = if let Ok (inner : &Dict) = d ["inner"]? {
            self.loadType (inner)
        } else { EMPTY_ANY };

        copy RangeType (isMut, inner)
    }

    /**
     * Load the configuration of a tuple type
     * */
    fn loadTupleType (self, d : &Dict, isMut : bool)-> &Type {
        let mut inners : [mut &Type] = [];
        if let Ok (inner : &Array) = d ["inners"]? {
            for a in inner[] if let i : &Dict = a {
                inners ~= [self.loadType (i)];
            } else { inners ~= [EMPTY_ANY]; }
        }

        copy TupleType (isMut, inners)
    }

    /**
     * Load the configuration of a class/struct/record type
     * */
    fn loadClassType (self, d : &Dict, isMut : bool, isEntity : bool = false, isRecord : bool = false)-> &Type {
        let name = if let Ok (Str (value-> name)) = d ["name"]? {
            name
        } else { "" };

        copy ClassType (name, isMut, isEntity-> isEntity, isRecord-> isRecord)
    }

    /**
     * Load the configuration of an enumeration type
     * */
    fn loadEnumType (self, d : &Dict, isMut : bool)-> &Type {
        let name = if let Ok (Str (value-> name)) = d ["name"]? {
            name
        } else { "" };

        let inner = if let Ok (inner : &Dict) = d ["proxy"]? {
            self.loadType (inner)
        } else { EMPTY_ANY };

        copy EnumType (name, isMut, inner)
    }

    /**
     * Load the configuration of a map type
     * */
    fn loadMapType (self, d : &Dict, isMut : bool)-> &Type {
        let key = if let Ok (inner : &Dict) = d ["key"]? {
            self.loadType (inner)
        } else { EMPTY_ANY };

        let value = if let Ok (inner : &Dict) = d ["value"]? {
            self.loadType (inner)
        } else { EMPTY_ANY };

        copy MapType (isMut, key, value)
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          STANDARD          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Load the standard information of a symbol
     * */
    fn loadStandard (self, cfg : &Config, defaultProtection : Protection = Protection::PRV)-> ([c8], [c8], Location, Protection) {
        if let doc : &Dict = cfg {
            let name = if let Ok (Str (value-> name)) = doc ["name"]? {
                name
            } else { "" };

            let filename = if let Ok (Str (value-> file)) = doc ["loc_file"]? {
                file
            } else { "" };

            let line = if let Ok (Int (value-> i)) = doc ["loc_line"]?  {
                cast!u64 (i)
            } else { 0 };

            let col = if let Ok (Int (value-> i)) = doc ["loc_col"]?  {
                cast!u64 (i)
            } else { 0 };

            let comm = if let Ok (Str (value-> c)) = doc ["doc"]? {
                c
            } else { "" };

            let protect = if let Ok (Str (value-> prt)) = doc ["protect"]? {
                if (prt == "pub") { Protection::PUB }
                else if (prt == "prot") { Protection::PROT }
                else { Protection::PRV }
            } else { defaultProtection };

            return (name, comm, Location (filename, line, col), protect);
        }

        ("", "", INTERNAL_LOCATION, defaultProtection)
    }
}
