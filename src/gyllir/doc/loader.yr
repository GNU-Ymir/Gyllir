in loader;

use std::{io, config::_, format};
use gyllir::doc::{symbols::_, types::_, symbols::template::_};


pub record SymbolLoader {

    /**
     * Create an empty symbol loader
     * */
    pub self () {}

    /**
     * Load a configuration and return the symbol found in it
     * */
    pub fn load (self, config : &Config)-> &Symbol {
        if let d : &Dict = config && "kind" in d {
            if let Ok (x) = d ["kind"]? match x {
                Str (value-> "module") => { return self.loadModule (d); }
                Str (value-> "function") => { return self.loadFunction (d); }
                Str (value-> "method") => { return self.loadMethod (d); }
                Str (value-> "ctor") => { return self.loadCtor (d); }
                Str (value-> "class") => { return self.loadClass (d); }
                Str (value-> "entity") => { return self.loadClass (d, isEntity-> true); }
                Str (value-> "record") => { return self.loadClass (d, isRecord-> true); }
                Str (value-> "template") => { return self.loadTemplate (d); }
                Str (value-> "trait") => { return self.loadTrait (d); }
                Str (value-> "enum") => { return self.loadEnum (d); }
                Str (value-> "global") => { return self.loadGlobal (d); }
                Str (value-> "def") => { return self.loadAka (d); }
                Str (value-> "macro") => { return self.loadMacro (d); }
                Str (value-> kind) => {
                    utils::log::warn ("Warning", "undefined symbol kind : '", kind, "'");
                }
            }
        }

        copy symbols::none_::None ()
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          MODULE          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Load the configuration of a module documentation
     * */
    fn loadModule (self, module : &Dict)-> &Module {
        let (name, doc, loc, protection) = self.loadStandard (module);
        let dmut result = copy Module (name, doc, loc, protection);

        if let Ok (ch) = module ["childs"]? match ch {
            a : &Array => {
                for x in a[] {
                    let i = self.load (x);
                    if (i !of none_::None) {
                        result.childs ~= [i];
                    }
                }
            }
        }

        result
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          FUNCTION          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */


    /**
     * Load a configuration of a function documentation
     * */
    fn loadFunction (self, func : &Dict)-> &Function {
        let (name, doc, loc, protection) = self.loadStandard (func);
        let dmut result = copy Function (name, doc, loc, protection);

        result.parameters = self.loadParams (func);
        if let Ok (attrs : &Array) = func ["attributes"]? {
            for a in attrs[] match a {
                Str (value-> "unsafe") => { result.isUnsafe = true; }
                Str (value-> "inline") => { result.isInline = true; }
            }
        }

        result.throwers = self.loadThrowers (func);
        if let Ok (d : &Dict) = func ["ret_type"]? {
            result.retType = self.loadType (d);
        }

        result
    }

    /**
     * Load a constructor
     * */
    fn loadCtor (self, func : &Dict)-> &Ctor {
        let (name, doc, loc, protection) = self.loadStandard (func);
        let dmut result = copy Ctor (name, doc, loc, protection);

        result.parameters = self.loadParams (func);
        if let Ok (attrs : &Array) = func ["attributes"]? {
            for a in attrs[] match a {
                Str (value-> "unsafe") => { result.isUnsafe = true; }
            }
        }

        result.throwers = self.loadThrowers (func);
        result
    }

    /**
     * Load a method
     * */
    fn loadMethod (self, func : &Dict)-> &Method {
        let (name, doc, loc, protection) = self.loadStandard (func);
        let dmut result = copy Method (name, doc, loc, protection);

        result.parameters = self.loadParams (func);
        if let Ok (attrs : &Array) = func ["attributes"]? {
            for a in attrs[] match a {
                Str (value-> "unsafe") => { result.isUnsafe = true; }
                Str (value-> "field") => { result.isField = true; }
                Str (value-> "final") => { result.isFinal = true; }
                Str (value-> "abstract") => { result.isEmpty = true; }
            }
        }

        result.isMutable = if let Ok (Str (value-> "true")) = func ["mutable"]? {
            true
        } else { false };

        result.throwers = self.loadThrowers (func);
        if let Ok (d : &Dict) = func ["ret_type"]? {
            result.retType = self.loadType (d);
        }

        result
    }

    /**
     * Load parameters from configuration
     * */
    fn loadParams (self, func : &Dict, key : [c8] = "params")-> [&Variable] {
        let mut vars : [mut &Variable] = [];
        if let Ok (params : &Array) = func [key]? {
            for a in params[] {
                let (name, doc, loc, protection) = self.loadStandard (a);
                let dmut var = copy Variable (name, doc, loc, protection);

                if let Ok (type : &Dict) =  a ["type"]? { var.type = self.loadType (type); }
                if let Ok (Str (value-> "true")) = a ["ref"]? { var.isRef = true; }
                if let Ok (Str (value-> "true")) = a ["lazy"]? { var.isLazy = true; }
                if let Ok (Str (value-> default)) = a ["value"]? { var.defaultValue = default; }

                if let Ok (Str (value-> m)) =  a ["mutability"]? {
                    var.isMut = (if (m == "dmut" || m == "mut") { true }
                                 else { false });
                }

                vars ~= [var];
            }
        }

        vars
    }

    /**
     * Load the throwers of a function/ctors/etc..
     * */
    fn loadThrowers (self, func : &Dict)-> [&Type] {
        let mut res : [mut &Type] = [];
        if let Ok (thrs : &Array) = func ["throwers"]? {
            for a in thrs[] if let d : &Dict = a {
                res ~= [self.loadType (d)];
            }
        }

        res
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          CLASS          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Load a class symbol
     * */
    fn loadClass (self, cl : &Dict, isEntity : bool = false, isRecord : bool = false)-> &ClassSymbol {
        let (name, doc, loc, protection) = self.loadStandard (cl);
        let dmut result = copy ClassSymbol (name, doc, loc, protection);
        result.isEntity = isEntity;
        result.isRecord = isRecord;

        if let Ok (Str (value-> "true")) = cl ["has_dtor"]? { result.hasDtor = true; }
        if let Ok (Str (value-> "true")) = cl ["abstract"]? { result.isAbstract = true; }
        if let Ok (Str (value-> "true")) = cl ["final"]? { result.isFinal = true; }
        if let Ok (anc : &Dict) = cl ["ancestor"]? { result.ancestor = self.loadType (anc); }

        result.fields = self.loadParams (cl, key-> "fields");
        if let Ok (arr : &Array) = cl ["ctors"]? {
            for c in arr[] if let d : &Dict = c {
                result.ctors ~= [self.loadCtor (d)];
            }
        }

        if let Ok (arr : &Array) = cl ["methods"]? {
            for c in arr[] if let d : &Dict = c {
                result.methods ~= [self.loadMethod (d)];
            }
        }

        if let Ok (arr : &Array) = cl ["template_ctors"]? {
            for c in arr[] if let d : &Dict = c {
                result.templateCtors ~= [self.loadTemplate (d)];
            }
        }

        if let Ok (arr : &Array) = cl ["template_methods"]? {
            for c in arr[] if let d : &Dict = c {
                result.templateMethods ~= [self.loadTemplate (d)];
            }
        }

        if let Ok (arr : &Array) = cl ["asserts"]? {
            for c in arr[] if let d : &Dict = c {
                result.asserts ~= [self.loadAssertion (d)];
            }
        }

        if let Ok (arr : &Array) = cl ["impl"]? {
            for i in arr[] if let s : &Str = i {
                result.implements ~= [s.value];
            }
        }

        result
    }

    /**
     * Load an assertion in a trait of a class
     * */
    fn loadAssertion (self, a : &Dict)-> ([c8], [c8], [c8]) {
        let test = if let Ok (Str (value-> test)) = a ["test"]? {
            test
        } else { "" };

        let msg = if let Ok (Str (value-> msg)) = a ["msg"]? {
            msg
        } else { "" };

        let doc = if let Ok (Str (value-> doc)) = a ["doc"]? {
            doc
        } else { "" };

        (test, msg, doc)
    }


    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          TRAITS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Load a trait symbol
     * */
    fn loadTrait (self, tr : &Dict)-> &TraitSymbol {
        let (name, doc, loc, protection) = self.loadStandard (tr);
        let dmut result = copy TraitSymbol (name, doc, loc, protection);

        if let Ok (arr : &Array) = tr ["methods"]? {
            for a in arr[] if let d : &Dict = a {
                result.methods ~= [self.loadMethod (d)];
            }
        }

        if let Ok (arr : &Array) = tr ["asserts"]? {
            for a in arr[] if let d : &Dict = a {
                result.asserts ~= [self.loadAssertion (d)];
            }
        }

        result
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          ENUMERATIONS          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Load the configuration of the documentation of an enumeration
     * */
    fn loadEnum (self, en : &Dict)-> &EnumSymbol {
        let (name, doc, loc, protect) = self.loadStandard (en);
        let dmut result = copy EnumSymbol (name, doc, loc, protect);

        if let Ok (arr : &Array) = en ["fields"]? {
            for a in arr[] if let d : &Dict = a {
                let fname = if let Ok (Str (value-> fname)) = d ["name"]? {
                    fname
                } else { "" };

                let value = if let Ok (Str (value-> value)) = d ["value"]? {
                    value
                } else { "" };

                let fdoc = if let Ok (Str (value-> fdoc)) = d ["doc"]? {
                    fdoc
                } else { "" };

                result.fields ~= [(fname, value, fdoc)];
            }
        }

        result
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          GLOBAL          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Load the configuration of the documentation of a global variable
     * */
    fn loadGlobal (self, glb : &Dict)-> &Global {
        let (name, doc, loc, protect) = self.loadStandard (glb);
        let dmut result = copy Global (name, doc, loc, protect);

        if let Ok (Str (value-> "true")) = glb ["thread_local"]? {
            result.isThreadLocal = true;
        }

        if let Ok (Str (value-> "true")) = glb ["static"]? {
            result.isStatic = true;
        }

        if let Ok (Str (value-> "mut" | "dmut")) = glb ["mutability"]? {
            result.isMutable = true;
        }

        if let Ok (ty : &Dict) = glb ["type"]? {
            result.type = self.loadType (ty);
        }

        if let Ok (Str (value-> value)) = glb ["value"]? {
            result.value = value;
        }

        result
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ======================================          AKA          =======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Load the configuration of the documentation of an aka symbol
     * */
    fn loadAka (self, aka : &Dict)-> &Aka {
        let (name, doc, loc, protect) = self.loadStandard (aka);
        let dmut result = copy Aka (name, doc, loc, protect);

        if let Ok (Str (value-> value)) = aka ["value"]? {
            result.isValue = true;
            result.value = value;
        } else if let Ok (ty : &Dict) = aka ["type"]? {
            result.isValue = false;
            result.type = self.loadType (ty);
        }

        result
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          MACRO          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Load a macro
     * */
    fn loadMacro (self, m : &Dict)-> &Macro {
        let (name, doc, loc, protect) = self.loadStandard (m);
        let dmut result = copy Macro (name, doc, loc, protect);

        if let Ok (arr : &Array) = m ["ctors"]? {
            for a in arr[] if let d : &Dict = a {
                result.ctors ~= [self.loadMacroRule (d)];
            }
        }

        if let Ok (arr : &Array) = m ["rules"]? {
            for a in arr[] if let d : &Dict = a {
                result.rules ~= [self.loadMacroRule (d)];
            }
        }

        result
    }

    /**
     * Load the configuration of a macro rule
     * */
    fn loadMacroRule (self, m : &Dict)-> &MacroRule {
        let (name, doc, loc, protect) = self.loadStandard (m);
        let dmut result = copy MacroRule (name, doc, loc, protect);

        if let Ok (Str (value-> "ctor")) = m ["kind"]? {
            result.isCtor = true;
        } else {
            result.isCtor = false;
        }

        if let Ok (Str (value-> rule)) = m ["rule"]? {
            result.rule = rule;
        }

        if let Ok (arr : &Array) = m ["skips"]? {
            for a in arr[] if let Str (value-> v) = a {
                result.skips ~= [v];
            }
        }

        result
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          TEMPLATES          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Load the configuration of the documentation of an template symbol
     * */
    fn loadTemplate (self, tmpl : &Dict)-> &Template {
        let (name, doc, loc, protection) = self.loadStandard (tmpl);
        let dmut result = copy Template (name, doc, loc, protection);
        result.params = self.loadTemplateParams (tmpl);

        if let Ok (Str (value-> test)) = tmpl ["test"]? {
            result.test = test;
        }

        let mut inners : [&Symbol] = [];
        if let Ok (a : &Array) = tmpl ["content"]? {
            for x in a[] {
                inners ~= [self.load (x)];
            }
        }

        result
    }

    /**
     * Load the template parameters of a template
     * */
    fn loadTemplateParams (self, tmpl : &Dict)-> [&TemplateParam] {
        let mut params : [&TemplateParam] = [];
        if let Ok (a : &Array) = tmpl ["templates"]? {
            for x in a [] match x {
                d : &Dict => {
                    self.loadTemplateParam (d);
                }
            }
        }

        params
    }

    /**
     * Load a template parameter
     * */
    fn loadTemplateParam (self, param : &Dict)-> &TemplateParam {
        if let Ok (x) = param ["kind"]? match x {
            Str (value-> "and") => return self.loadTemplateAndParam (param);
            Str (value-> "of" | "over" | "impl") =>
                return self.loadTemplateOfVarParam (param);
            Str (value-> "class" | "record" | "entity" | "tuple" | "alias") =>
                return self.loadTemplateVarParam (param);
            Str (value-> "variadic") =>
                return self.loadTemplateVariadicParam (param);
        }

        self.loadTemplateAnyParam (param)
    }

    /**
     * Load a template and parameter
     * */
    fn loadTemplateAndParam (self, param : &Dict)-> &TemplateAndParam {
        let mut inners : [&TemplateParam] = [];
        if let Ok (a : &Array) = param ["content"]? {
            for x in a [] match x {
                d : &Dict => {
                    inners ~= [self.loadTemplateParam (d)];
                }
            }
        }

        copy TemplateAndParam (inners)
    }

    /**
     * Load a template parameter
     * */
    fn loadTemplateOfVarParam (self, param : &Dict)-> &TemplateOfVarParam {
        let var = if let Ok (Str (value-> content)) = param ["var"]? {
            content
        } else { "" };

        let kind = if let Ok (Str (value-> content)) = param ["kind"]? {
            content
        } else { "" };

        let content = if let Ok (Str (value-> content)) = param ["content"]? {
            content
        } else { "" };

        copy TemplateOfVarParam (var, kind, content)
    }

    /**
     * Load a template parameter
     * */
    fn loadTemplateVarParam (self, param : &Dict)-> &TemplateVarParam {
        let var = if let Ok (Str (value-> content)) = param ["name"]? {
            content
        } else { "" };

        let kind = if let Ok (Str (value-> content)) = param ["kind"]? {
            content
        } else { "" };

        copy TemplateVarParam (var, kind)
    }

    /**
     * Load a template parameter
     * */
    fn loadTemplateVariadicParam (self, param : &Dict)-> &TemplateVariadicParam {
        let var = if let Ok (Str (value-> content)) = param ["name"]? {
            content
        } else { "" };

        let isValue = if let Ok (Str (value-> "true")) = param ["value"]? {
            true
        } else { false };

        copy TemplateVariadicParam (var, isValue)
    }

    /**
     * Load a template parameter
     * */
    fn loadTemplateAnyParam (self, param : &Dict)-> &TemplateAnyParam {
        let content = if let Ok (Str (value-> content)) = param ["content"]? {
            content
        } else { "" };

        copy TemplateAnyParam (content)
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          TYPES          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Load a type from documentation configuration
     * */
    fn loadType (self, ty : &Dict)-> &Type {
        let isMut = if let Ok (Str (value-> m)) =  ty ["mutability"]? {
            if (m == "dmut" || m == "mut") { true }
            else { false }
        } else { false };

        if let Ok (x) = ty ["kind"]? match x {
            Str (value-> "fptr") => { return self.loadFuncPtrType (ty, isMut, isDelegate-> false); }
            Str (value-> "delegate") => { return self.loadFuncPtrType (ty, isMut, isDelegate-> true); }
            Str (value-> "array") => { return self.loadArrayType (ty, isMut); }
            Str (value-> "class") => { return self.loadClassType (ty, isMut); }
            Str (value-> "record") => { return self.loadClassType (ty, isMut, isRecord-> true); }
            Str (value-> "entity") => { return self.loadClassType (ty, isMut, isEntity-> true); }
            Str (value-> "enum") => { return self.loadEnumType (ty, isMut); }
            Str (value-> "option") => { return self.loadOptionType (ty, isMut); }
            Str (value-> "pointer") => { return self.loadPointerType (ty, isMut); }
            Str (value-> "range") => { return self.loadRangeType (ty, isMut); }
            Str (value-> "slice") => { return self.loadSliceType (ty, isMut); }
            Str (value-> "tuple") => { return self.loadTupleType (ty, isMut); }
            Str (value-> "map") => { return self.loadMapType (ty, isMut); }
            Str (value-> "scalar") => {
                let name = if let Ok (Str (value-> name)) = ty ["name"]? {
                    name
                } else { "" };

                return copy ScalarType (name, isMut);
            }
            _ => {
                let name = if let Ok (Str (value-> name)) = ty ["name"]? {
                    name
                } else { "" };

                return copy AnyType (name, isMut);
            }
        }

        EMPTY_ANY
    }

    /**
     * Load a function pointer from a config
     * */
    fn loadFuncPtrType (self, d : &Dict, isMut : bool, isDelegate : bool)-> &Type {
        let mut params : [mut &Type] = [];
        let mut refs : [mut bool] = [];
        let mut lazys : [mut bool] = [];
        if let Ok (a : &Array) = d ["params"]? {
            for i in a[] if let inner : &Dict = i {
                params ~= [self.loadType (inner)];
            }
        }

        if let Ok (a : &Array) = d ["refs"]? {
            for i in a[] if let Str (value-> b) = i {
                refs ~= [b == "true"];
            }
        }

        if let Ok (a : &Array) = d ["lazys"]? {
            for i in a[] if let Str (value-> b) = i {
                refs ~= [b == "true"];
            }
        }

        if (params.len != refs.len || params.len != lazys.len) {
            params = [];
            refs = [];
            lazys = [];
        }

        let retType = if let Ok (ret : &Dict) = d ["return"]? {
            self.loadType (ret)
        } else { EMPTY_ANY };

        copy FuncPtrType (isMut, isDelegate, params, refs, lazys, retType)
    }

    /**
     * Load the configuration of an array type
     * */
    fn loadArrayType (self, d : &Dict, isMut : bool)-> &Type {
        let len = if let Ok (Int (value-> len)) = d ["len"]? {
            cast!usize (len)
        } else { 0 };

        let inner = if let Ok (inner : &Dict) = d ["inner"]? {
            self.loadType (inner)
        } else { EMPTY_ANY };

        copy ArrayType (isMut, inner, len)
    }

    /**
     * Load the configuration of a slice type
     * */
    fn loadSliceType (self, d : &Dict, isMut : bool)-> &Type {
        let inner = if let Ok (inner : &Dict) = d ["inner"]? {
            self.loadType (inner)
        } else { EMPTY_ANY };

        copy SliceType (isMut, inner)
    }

    /**
     * Load the configuration of an option type
     * */
    fn loadOptionType (self, d : &Dict, isMut : bool)-> &Type {
        let inner = if let Ok (inner : &Dict) = d ["inner"]? {
            self.loadType (inner)
        } else { EMPTY_ANY };

        copy OptionType (isMut, inner)
    }

    /**
     * Load the configuration of a pointer type
     * */
    fn loadPointerType (self, d : &Dict, isMut : bool)-> &Type {
        let inner = if let Ok (inner : &Dict) = d ["inner"]? {
            self.loadType (inner)
        } else { EMPTY_ANY };

        copy PointerType (isMut, inner)
    }

    /**
     * Load the configuration of a range type
     * */
    fn loadRangeType (self, d : &Dict, isMut : bool)-> &Type {
        let inner = if let Ok (inner : &Dict) = d ["inner"]? {
            self.loadType (inner)
        } else { EMPTY_ANY };

        copy RangeType (isMut, inner)
    }

    /**
     * Load the configuration of a tuple type
     * */
    fn loadTupleType (self, d : &Dict, isMut : bool)-> &Type {
        let mut inners : [mut &Type] = [];
        if let Ok (inner : &Array) = d ["inners"]? {
            for a in inner[] if let i : &Dict = a {
                inners ~= [self.loadType (i)];
            } else { inners ~= [EMPTY_ANY]; }
        }

        copy TupleType (isMut, inners)
    }

    /**
     * Load the configuration of a class/struct/record type
     * */
    fn loadClassType (self, d : &Dict, isMut : bool, isEntity : bool = false, isRecord : bool = false)-> &Type {
        let name = if let Ok (Str (value-> name)) = d ["name"]? {
            name
        } else { "" };

        let innerMut = if let Ok (Str (value-> m)) =  d ["mutability"]? {
            if (m == "dmut") { true }
            else { false }
        } else { false };

        copy ClassType (name, isMut, innerMut, isEntity-> isEntity, isRecord-> isRecord)
    }

    /**
     * Load the configuration of an enumeration type
     * */
    fn loadEnumType (self, d : &Dict, isMut : bool)-> &Type {
        let name = if let Ok (Str (value-> name)) = d ["name"]? {
            name
        } else { "" };

        let inner = if let Ok (inner : &Dict) = d ["proxy"]? {
            self.loadType (inner)
        } else { EMPTY_ANY };

        copy EnumType (name, isMut, inner)
    }

    /**
     * Load the configuration of a map type
     * */
    fn loadMapType (self, d : &Dict, isMut : bool)-> &Type {
        let key = if let Ok (inner : &Dict) = d ["key"]? {
            self.loadType (inner)
        } else { EMPTY_ANY };

        let value = if let Ok (inner : &Dict) = d ["value"]? {
            self.loadType (inner)
        } else { EMPTY_ANY };

        copy MapType (isMut, key, value)
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          STANDARD          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Load the standard information of a symbol
     * */
    fn loadStandard (self, cfg : &Config, defaultProtection : Protection = Protection::PRV)-> ([c8], [c8], Location, Protection) {
        if let doc : &Dict = cfg {
            let name = if let Ok (Str (value-> name)) = doc ["name"]? {
                name
            } else { "" };

            let filename = if let Ok (Str (value-> file)) = doc ["loc_file"]? {
                file
            } else { "" };

            let line = if let Ok (Int (value-> i)) = doc ["loc_line"]?  {
                cast!u64 (i)
            } else { 0 };

            let col = if let Ok (Int (value-> i)) = doc ["loc_col"]?  {
                cast!u64 (i)
            } else { 0 };

            let comm = if let Ok (Str (value-> c)) = doc ["doc"]? {
                c
            } else { "" };

            let protect = if let Ok (Str (value-> prt)) = doc ["protect"]? {
                if (prt == "pub") { Protection::PUB }
                else if (prt == "prot") { Protection::PROT }
                else { Protection::PRV }
            } else { defaultProtection };

            return (name, comm, Location (filename, line, col), protect);
        }

        ("", "", INTERNAL_LOCATION, defaultProtection)
    }
}
