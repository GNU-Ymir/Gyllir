mod gyllir::repo::manager;

import std::io;
import std::fs::_, std::env, std::args, std::config;
import gyllir::config::_;
import gyllir::args::_;
import gyllir::repo::defaults;
import std::time::_;
import std::config::conv;

import std::collection::vec;
import std::concurrency::process;
import gyllir::utils::git, gyllir::utils::errors;
import std::concurrency::thread, std::concurrency::mailbox;
import std::algorithm::comparison, std::algorithm::iteration;
import std::lexer;

/**
 * The structure containing all the command line arguments
 */
pub struct
| help: YesNo
| init : &InitCommand = InitCommand::new () 
| build : &BuildCommand = BuildCommand::new ()
| clean : &CleanCommand = CleanCommand::new ()
 -> GyllirArgs;


/**
 * The gyllir manager if the core of gyllir
 */
pub class GyllirManager {

    let mut _valid : bool = false;
    let mut _args : GyllirArgs = GyllirArgs (help-> YesNo::NO);
    let dmut _mail = MailBox!{(u64, &Path)}::new ();
    
    /**
     * Create a Gyllir builder from an argument 
     */
    pub self (args : [[c8]]) {
        let x = ArgumentParser!(GyllirArgs)::new ()
            :.info!"help" (short-> "h", comments-> "print this help and exit", isHelp-> true)
            :.info!"init" (comments-> "initialize a gyllir repository and create the config file.")
            :.info!"build" (comments-> "build the project in the current directory")
            :.info!"clean" (comments-> "clean the project (remove generated files)");
        {            
            self._args = x.parse (args);
            if (self.noneIsSet ()) {
                println (x.simpleUsage (cmd-> "gyllir"));
            } else {
                self._valid = true;
            }
        } catch {
            err : &ArgumentError => {
                if !self.hasHelpPrinted (err) {
                    println (x.diagnosis (err));
                }
            }
            _ : &HelpRequired => {
                println (x.usage (cmd-> "gyllir"));
            }
        }
    }
    
    /**
     * Run the builder
     * @returns: the builder did something
     */
    pub def run (mut self) {
        if !self._valid { return {} }
        
        if (self._args.init.isSet ()) {
            self:.initRepo ();
        } else if (self._args.build.isSet ()) {
            self:.buildRepo ();
        } else if (self._args.clean.isSet ()) {
            self:.cleanRepo ();
        }
    }

    
    /**
     * Ask the user for a given value (command line read)
     * @params: 
     *   - ask: the text to write as a question
     *   - default: the default value to return if the user did write nothing
     */
    prv def askUserFor (self, ask : [c8], default : [c8] = ""s8) -> [c8] {
        let x = read![c8] (ask-> (ask ~ " ["s8 ~ default ~ "]:"s8).(std::conv::to)![c32] ());
        if x == ""s8 {
            default
        } else x   
    }


    /**
     * ================================================================================================================================================================
     * ================================================================================================================================================================
     * ==================================================================    INITIALIZATION    ========================================================================
     * ================================================================================================================================================================
     * ================================================================================================================================================================
     */
    
    /**
     * Initialize a new repo
     */
    prv def initRepo (self) {
        let path = env::currentDir ().push (self._args.init.getName ().(std::conv::to)![c8] ());
        if isFile (path.push (defaults::__GYLLIR_CONFIG_FILENAME__)) {
            println ("The target directory already contains a 'gyllir.toml' file. Aborting.");
        } else {
            {
                let name = self.askUserFor ("Name"s8, default-> self._args.init.getName ().(std::conv::to)![c8] ());
                let author = self.askUserFor ("Author name"s8, default-> git::userName ()); // peut être remplacer ça par (git config --list --global) ["user.name"] ~ ["user.email"]
                let descr = self.askUserFor ("Description"s8, default-> "A minimal Ymir app"s8);
                let license = self.askUserFor ("License"s8, default-> "proprietary"s8);
                let type = self.askUserFor ("Type (executable/library)"s8, default-> "executable"s8);

                let toml = GyllirConfig (name-> name, author-> author, license-> license, description-> descr, type-> BuildType::new (type));
            
                self.createEmptyRepo (path, toml);       
                println ("Successfully created an empty project in '"s8 ~ path.toStr () ~ "'"s8);
            } catch {
                x : _ => {
                    println (x);
                }
            }
        }
    }

    /**
     * Create a new empty repository
     */
    prv def createEmptyRepo (self, path : &Path, conf : GyllirConfig)
        throws &FsError, &GitError
    {
        fs::createDir (path, recursive-> true)?;
        self.saveToml (path.push (defaults::__GYLLIR_CONFIG_FILENAME__), conf.to!{&Config} ());

        fs::createDir (path.push (defaults::__SRC_DIR__))?;
        with dmut f = File::create (path.push (defaults::__SRC_DIR__).push (defaults::__MAIN_FILE__), write-> true) {
            f:.write (defaults::__MAIN_CONTENT__);
        }

        with dmut f = File::create (path.push (defaults::__GITIGNORE_FILENAME__), write-> true) {
            f:.write (defaults::__GITIGNORE_CONTENT__);
            if conf.type.isExecutable () {
                f:.write ("./"s8 ~ conf.name);
            } else f:.write ("./"s8 ~ conf.name ~ ".a"s8);
            f:.write ("\n"s8);
        }

        git::init (cwd-> path);
        git::add (path.push ("."s8));
        git::commit ("Initial commit"s8, cwd-> path);
    }


    /**
     * ================================================================================================================================================================
     * ================================================================================================================================================================
     * ======================================================================   BUILDING   ============================================================================
     * ================================================================================================================================================================
     * ================================================================================================================================================================
     */

    /**
     * Build a repository 
     */
    prv def buildRepo (mut self) {
        let cwd = env::currentDir ();
        let conf = {
            self.loadToml (cwd.push (defaults::__GYLLIR_CONFIG_FILENAME__))
        } catch {
            _ => {
                println ("Failed to read configuration file. Aborting");
                return {}
            }
        }
        
        {
            fs::createDir (cwd.push (defaults::__BUILD_DIR__));
        } catch {
            x : &FsError => {
                if (x.code != FsErrorCode::ALREADY_EXISTS) {
                    println ("Failed to create build repository: "s8 ~ x.msg ~ " ("s8 ~ x.code.(fs::errors::to)![c8] () ~ "). Aborting"s8);
                    return {}
                }
            }
        }
        
        let files = {
            self.listAllSourceFiles (cwd.push (defaults::__SRC_DIR__))
        } catch {
            _ : &FsError => {
                println ("Invalid repository, missing source directory. Aborting");
                return {}
            }
        }

        let toBuild = self.listToBuild (files);
        self:.buildFiles (toBuild);        
        self:.linkRepo (files, conf);
    }

    /**
     * Link the files to create the executable or library
     */
    prv def linkRepo (mut self, files : [&Path], conf : GyllirConfig) {
        let cwd = env::currentDir ();
        let mut ofiles : [[c8]] = [];
        for file in files {
            let oname = file.stripExtension ().addExtension ("o"s8).file ();
            let odir = cwd.push (defaults::__BUILD_DIR__).push (file.parent ().removePrefix (cwd.push (defaults::__SRC_DIR__)));
            ofiles = ofiles ~ [odir.push (oname).toStr ()];
        }

        let outputname = self.toPath (conf.name, sep-> "/"s8, add-> "_"s8);
        println ("[100%] Linking ", outputname);
        
        if (self._args.build.isVerbose ()) {
            print ("[INFO] Running cmd gyc"s8, " -o "s8, outputname);
            for i in ofiles print (" ", i);
            println ("");                
        }
        
        if (conf.type.isExecutable ()) {
            with dmut subProc = SubProcess::run ("gyc"s8, ["-o"s8, outputname] ~ ofiles, cwd-> cwd) {
                let _ = subProc:.wait ();
                if (self._args.build.isVerbose ()) {
                    let o = subProc:.stdout ():.read ();
                    if (o != ""s8)
                        println (o);
                }

                let err = subProc:.stderr ():.read ();
                if (err != ""s8) {
                    println (err);
                    atomic self {
                        self._mail:.clear ();
                    }
                    return {}
                }
            }
        }
    }

    
    /**
     * Build the files 
     */
    prv def buildFiles (mut self, files : [&Path]) {
        let mut percent = 0u64;
        for i in 0us .. files.len {
            let prc = (percent * 100u64) / files.len;
            percent += 1u64;

            self._mail:.send ((prc, files [i]));
        }

        let mut threads : [Thread] = [];
        let nb_threads = clamp (self._args.build.getNbThreads (), 1u32, cast!u32 (files.len));
        if (self._args.build.isVerbose () && nb_threads != 0u32) {
            println ("[INFO] Spawning ", nb_threads, " threads");
        }
        
        for _ in 0u32 .. nb_threads {
            let th = spawnNoPipe (&self:.buildFile);
            threads = threads ~ [th];
        }

        for th in threads {
            th.join ();
        }        
    } catch {
        x : &OutOfArray => println (x);
    }


    prv def buildFile (mut self, _ : Thread) {
        let cwd = env::currentDir ();
        loop {
            let (p, file) = atomic self {
                match self._mail:.receive () {
                    Ok (x : _) => { x }
                    _ => { return {} }
                }
            }
            
            let oname = file.stripExtension ().addExtension ("o"s8).file ();
            let odir = cwd.push (defaults::__BUILD_DIR__).push (file.parent ().removePrefix (cwd.push (defaults::__SRC_DIR__)));
            fs::createDir (odir, recursive-> true)?;
            
            atomic self {
                if (p < 10u64) 
                    println ("[  ", p, "%] Building object ", odir.push (oname).toStr ());
                else println ("[ ", p, "%] Building object ", odir.push (oname).toStr ());
                if self._args.build.isVerbose () {
                    println ("[INFO] Running cmd gyc -fdependency -c -o", odir.push (oname).toStr (), " ", file.toStr (), " ", "-I "s8, cwd.push ("src"s8).toStr (), " ", if (self._args.build.isDebug ()) "-g"s8 else "-O3"s8);
                }
            }
            
            with dmut subProc = SubProcess::run ("gyc"s8, ["-fdependency"s8, "-c"s8, "-o"s8, odir.push (oname).toStr (), file.toStr (), "-I"s8, cwd.push ("src"s8).toStr (), if (self._args.build.isDebug ()) "-g"s8 else "-O3"s8], cwd-> cwd.push (defaults::__BUILD_DIR__)) {
                let _ = subProc:.wait ();
                if (self._args.build.isVerbose ()) {
                    let o = subProc:.stdout ():.read ();
                    if o != ""s8 { println (o); }
                }

                let err = subProc:.stderr ():.read ();
                if (err != ""s8) {
                    println (err);
                    atomic self {
                        self._mail:.clear ();
                    }
                    return {}
                }
            }

            let depname = self.toPath (file.stripExtension ().removePrefix (cwd.push (defaults::__SRC_DIR__)).addExtension ("dep.json"s8).toStr (), sep-> "/"s8, add-> "__"s8);
            let dstname = file.stripExtension ().removePrefix (cwd.push (defaults::__SRC_DIR__)).addExtension ("dep.json"s8).toStr ();
            if (depname != dstname) {
                with dmut subProc = SubProcess::run ("mv"s8, [depname, dstname], cwd-> cwd.push (defaults::__BUILD_DIR__)) {
                    let _ = subProc:.wait ();
                    let err = subProc:.stderr ():.read ();
                    if (err != ""s8) {
                        println (err);
                        atomic self {
                            self._mail:.clear ();
                        }
                        return {}
                    }
                }
            }
        }
    }
    
    /**
     * List all the files to build 
     * Either they don't have a .o binary already made, or the source file was modified more recently than the .o 
     * @params:
     *   - files: the list of source file
     * @returns: the list of source files to build
     */
    prv def listToBuild (self, files : [&Path]) -> [&Path] {
        let dmut res = Vec!{&Path}::new ();
        let dmut no = Vec!{&Path}::new ();

        let cwd = env::currentDir ();
        for file in files {
            let oname = file.stripExtension ().addExtension ("o"s8).file ();
            let odir = cwd.push (defaults::__BUILD_DIR__).push (file.parent ().removePrefix (cwd.push (defaults::__SRC_DIR__)));
            let opath = odir.push (oname);
            {
                if (fs::isFile (opath)) {
                    if (fs::fileDate (opath) < fs::fileDate (file)) res:.push (file);
                    else no:.push (file)
                } else res:.push (file);
            } catch {
                _ => res:.push (file);
            }
        }

        res:.fit ();
        no:.fit ();
        self.resolveDependencies (no [], res [])
    }

    /**
     * List all the files that have to be rebuild, due to dependencies
     * @assume: all the files in `files` have a .o, and probabely a .dep.json    
     * @params: 
     *   - files: the list of files that are not build by default
     *   - force: the list of files that will be rebuild
     */
    prv def resolveDependencies (self, files : [&Path], force : [&Path])-> [&Path] {
        import std::config::json;
        let cwd = env::currentDir ();
        
        for i in 0us .. files.len {
            let depname = files [i].stripExtension ().addExtension ("dep.json"s8).file ();
            let depdir = cwd.push (defaults::__BUILD_DIR__).push (files [i].parent ().removePrefix (cwd.push (defaults::__SRC_DIR__)));
            let deppath = depdir.push (depname);
            if fs::isFile (deppath) {
                with dmut dep = File::open (deppath) {
                    let dependencies = json::parse (dep:.readAll ());
                    if self.hasDependency (dependencies, force) return self.resolveDependencies (files [0us .. i] ~ files [i + 1us .. $], force ~ [files [i]]);
                } catch {
                    _ => return self.resolveDependencies (files [0us .. i] ~ files [i + 1us .. $], force ~ [files [i]]);
                }
            }
        } catch {
            x : _ => println (x);
        }

        return force;
    }

    /**
     * @returns: true, if the file has a dependency in files
     */
    prv def hasDependency (self, conf : &Config, files : [&Path])-> bool {
        let cwd = env::currentDir ();
        let deps = conf ["dependencies"]?;
        match deps {
            Ok (arr : &Array) => {
                for i in 0us .. arr.len () {
                    for f in files {
                        let filePath = f.removePrefix (cwd.push (defaults::__SRC_DIR__));
                        let depPath = Path::new (self.toPath (arr [i].(config::conv::to)![c8] ())).addExtension (defaults::__YMIR_EXTENSION__);
                        if depPath.toStr () == filePath.toStr () {
                            return true;
                        }
                    }
                }
            }
            _ => return true;
        }
        false
    } catch {
        _ => true
    }

    /**
     * Transform a module name into a path
     * @example: 
     * ===========
     * assert (self.toPath ("std::path"s8) == "std/path.yr"s8)
     * ===========
     */
    prv def toPath (self, module : [c8], sep : [c8] = "::"s8, add : [c8] = "/"s8)-> [c8] {
        let dmut res = StringStream::new ();
        let mut i = 0us;
        while i < module.len {
            if i < (module.len - sep.len - 1us) {
                if (module [i .. i + sep.len] == sep) {                    
                    res:.write (add);
                    i += sep.len;
                } else {
                    res:.write (module [i]);
                    i += 1us;
                } 
            } else {
                res:.write (module [i]);
                i += 1us;
            }
        }
        res []
    } catch {
        _ => __pragma!panic ();
    }

            

            
    /**
     * List all the source files in a directory (recursively)
     * A source file is a file, whose extension is __YMIR_EXTENSION__ (.yr)
     * @params: 
     *   - path: the path to the directory to traverse
     */
    prv def listAllSourceFiles (self, path : &Path)-> [&Path]
        throws &FsError
    {
        let dmut res = Vec!{&Path}::new ();
        {
            for entry in fs::readDir (path) {
                match entry {
                    f : &FileEntry => {
                        if f.getPath ().extension () == defaults::__YMIR_EXTENSION__ {
                            res:.push (path.push (f.getPath ()));
                        }
                    }
                    d : &DirEntry => {
                        let files = self.listAllSourceFiles (path.push (d.getPath ()));
                        for f in files { res:.push (f); }
                    }
                }
            }
        }

        res:.fit ();
        res []
    }
    
    /**
     * ================================================================================================================================================================
     * ================================================================================================================================================================
     * ======================================================================   DEPENDENCY   ==========================================================================
     * ================================================================================================================================================================
     * ================================================================================================================================================================
     */


    /**
     * ================================================================================================================================================================
     * ================================================================================================================================================================
     * =======================================================================    CLEANING   ==========================================================================
     * ================================================================================================================================================================
     * ================================================================================================================================================================
     */

    /**
     * Execute the clean repository command
     */
    pub def cleanRepo (self) {
        let cwd = env::currentDir ();
        let conf = {
            self.loadToml (cwd.push (defaults::__GYLLIR_CONFIG_FILENAME__))
        } catch {
            _ => {
                println ("Failed to read configuration file. Aborting");
                return {}
            }
        }

	if (self._args.clean.isDoc () || self._args.clean.isAll ()) {
            if (fs::isDir (cwd.push ("__doc"s8))) {
		fs::removeDir (cwd.push ("__doc"s8), recursive-> true);
            }            
        }        
        
	if (!self._args.clean.isDoc () || self._args.clean.isAll ()) {
            if (fs::isDir (cwd.push (".build"s8))) {
		fs::removeDir (cwd.push (".build"s8), recursive-> true);
            }
            
            let outputname = self.toPath (conf.name, sep-> "/"s8, add-> "_"s8);            
            if (fs::isFile (cwd.push (outputname))) 
                fs::removeFile (cwd.push (outputname));
        }        
    } catch {
        x : &FsError => println (x);
    }


    /**
     * ================================================================================================================================================================
     * ================================================================================================================================================================
     * ======================================================================     COMMON     ==========================================================================
     * ================================================================================================================================================================
     * ================================================================================================================================================================
     */


    /**
     * Save a configation into a file
     */
    pub def saveToml (self, path : &Path, content : &Config)
        throws &FsError
    {
        import std::config::toml;
        with dmut f = File::create (path, write-> true) {
            f:.write (content.dump ().(std::conv::to)![c8] ());
        }
    }

    /**
     * Read the configuration file
     */
    pub def loadToml (self, path : &Path)-> GyllirConfig
        throws &FsError, &SyntaxError, &ConfigError
    {
        import std::config::toml;
        with dmut f = File::open (path) {
            toml::parse (f:.readAll ()).(config::conv::to)!{GyllirConfig} ()
        }
    } 

    /**
     * @returns: true if the error was thrown by a sub command that printed the help
     */
    pub def hasHelpPrinted (self, err : &ArgumentError) -> bool {
        match err.subError {
            Ok (HelpPrinted ()) => { true }
            Ok (sub : &ArgumentError) => { self.hasHelpPrinted (sub) }
            _ => false
        }
    }

    /**
     * @returns: true if no option is set
     */
    pub def noneIsSet (self)-> bool {
        !self._args.init.isSet () &&
            !self._args.build.isSet () &&
            !self._args.clean.isSet ()
    }
    
}
