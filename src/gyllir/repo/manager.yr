mod gyllir::repo::manager;

import std::io;
import std::fs::_, std::env, std::args, std::config;
import gyllir::config::_;
import gyllir::args::_;
import gyllir::repo::defaults;
import std::time::_;
import std::config::conv;

import std::collection::vec;
import std::concurrency::process;
import gyllir::utils::git, gyllir::utils::errors;
import std::concurrency::thread, std::concurrency::mailbox;
import std::algorithm::comparison, std::algorithm::iteration;
import std::collection::set;
import std::lexer, std::tokenizer;

/**
 * The structure containing all the command line arguments
 */
pub struct
| help: YesNo
| init : &InitCommand = InitCommand::new () 
| build : &BuildCommand = BuildCommand::new ()
| clean : &CleanCommand = CleanCommand::new ()
| publish : &PublishCommand = PublishCommand::new ()
| test : &TestCommand = TestCommand::new ()
 -> GyllirArgs;


/**
 * The gyllir manager if the core of gyllir
 */
pub class GyllirManager {

    let mut _valid : bool = false;
    let mut _args : GyllirArgs = GyllirArgs (help-> YesNo::NO);
    let dmut _mail = MailBox!{(u64, &Path, &Path, [c8], bool, bool, [&Path])}::new ();
    let mut _failed : bool = false;
    let dmut _doneDependencies = HashSet!{&Url}::new ();
    
    /**
     * Create a Gyllir builder from an argument 
     */
    pub self (args : [[c8]]) {
        let x = ArgumentParser!(GyllirArgs)::new ()
            :.info!"help" (short-> "h", comments-> "print this help and exit", isHelp-> true)
            :.info!"init" (comments-> "initialize a gyllir repository and create the config file.")
            :.info!"build" (comments-> "build the project in the current directory")
            :.info!"publish" (comments-> "publish a version to the package registry")
            :.info!"clean" (comments-> "clean the project (remove generated files)")
            :.info!"test" (comments-> "run the tests")
            ;
        {            
            self._args = x.parse (args);
            if (self.noneIsSet ()) {
                println (x.simpleUsage (cmd-> "gyllir"));
            } else {
                self._valid = true;
            }
        } catch {
            err : &ArgumentError => {
                if !self.hasHelpPrinted (err) {
                    println (x.simpleUsage (cmd-> "gyllir"));
                    println (x.diagnosis (err));
                }
            }
            _ : &HelpRequired => {
                println (x.usage (cmd-> "gyllir"));
            }
        }
    }
    
    /**
     * Run the builder
     * @returns: the builder did something
     */
    pub def run (mut self) {
        if !self._valid { return {} }
        
        if (self._args.init.isSet ()) {
            self:.initRepo ();
        } else if (self._args.build.isSet ()) {
            let cwd = env::currentDir ();
            let conf = {
                self.loadToml (cwd.push (defaults::__GYLLIR_CONFIG_FILENAME__))
            } catch {
                x : _ => {
                    println ("Failed to read configuration file (", x, "). Aborting");
                    return {}
                }
            }
            {
                self:.buildRepo (conf, cwd-> cwd);
            } catch {
                r : &RecursiveDependency => {
                    println ("Failed to build repository, recursive dependency : ");
                    println (r.msg);
                    println ("Aborting");                    
                }
            }
        } else if (self._args.clean.isSet ()) {
            self:.cleanRepo (doc-> self._args.clean.isDoc (), all-> self._args.clean.isAll ());
        } else if (self._args.publish.isSet ()) {
            self:.publishRepo ();
        } else if (self._args.test.isSet ()) {
            {
                self:.runTests ();
            } catch {
                r : &RecursiveDependency => {
                    println ("Failed to build repository, recursive dependency : ");
                    println (r.msg);
                    println ("Aborting");                    
                }
            }
        }
    }

    
    /**
     * Ask the user for a given value (command line read)
     * @params: 
     *   - ask: the text to write as a question
     *   - default: the default value to return if the user did write nothing
     */
    prv def askUserFor (self, ask : [c8], default : [c8] = ""s8) -> [c8] {
        let x = read![c8] (ask-> (ask ~ " ["s8 ~ default ~ "]:"s8).(std::conv::to)![c32] ());
        if x == ""s8 {
            default
        } else x   
    }


    /**
     * ================================================================================================================================================================
     * ================================================================================================================================================================
     * ==================================================================    INITIALIZATION    ========================================================================
     * ================================================================================================================================================================
     * ================================================================================================================================================================
     */
    
    /**
     * Initialize a new repo
     */
    prv def initRepo (self) {
        let path = env::currentDir ().push (self._args.init.getName ().(std::conv::to)![c8] ());
        if isFile (path.push (defaults::__GYLLIR_CONFIG_FILENAME__)) {
            println ("The target directory already contains a 'gyllir.toml' file. Aborting.");
        } else {
            {
                let name = self.askUserFor ("Name"s8, default-> self._args.init.getName ().(std::conv::to)![c8] ());
                let author = self.askUserFor ("Author name"s8, default-> git::userName ()); // peut être remplacer ça par (git config --list --global) ["user.name"] ~ ["user.email"]
                let descr = self.askUserFor ("Description"s8, default-> "A minimal Ymir app"s8);
                let license = self.askUserFor ("License"s8, default-> "proprietary"s8);
                let type = self.askUserFor ("Type (executable/library)"s8, default-> "executable"s8);

                let gyllirHome = Path::new (env::getEnv ("HOME"s8)).push (".local"s8).push ("gyllir"s8).push (name);
                let registry = {
                    let url = self.askUserFor ("Registry"s8, default-> (UrlStarts::LOCAL).(std::conv::to)![c8] () ~ gyllirHome.toStr ());
                    Url::new (url)
                } catch {
                    x : &AssertError => {
                        println ("Invalid registry url : ", x.msg, ". Aborting");
                        return {}
                    }
                }
                

                let toml = GyllirConfig (name-> name, author-> author, license-> license, description-> descr, type-> BuildType::new (type), registry-> registry);
            
                self.createEmptyRepo (path, toml);       
                println ("Successfully created an empty project in '"s8 ~ path.toStr () ~ "'"s8);
            } catch {
                x : _ => {
                    println (x);
                }
            }
        }
    }

    /**
     * Create a new empty repository
     */
    prv def createEmptyRepo (self, path : &Path, conf : GyllirConfig)
        throws &FsError, &GitError
    {
        fs::createDir (path, recursive-> true)?;
        self.saveToml (path.push (defaults::__GYLLIR_CONFIG_FILENAME__), conf.to!{&Config} ());

        fs::createDir (path.push (defaults::__SRC_DIR__))?;
        fs::createDir (path.push (defaults::__TEST_DIR__))?;
        with dmut f = File::create (path.push (defaults::__SRC_DIR__).push (defaults::__MAIN_FILE__), write-> true) {
            f:.write (defaults::__MAIN_CONTENT__);
        }

        with dmut f = File::create (path.push (defaults::__GITIGNORE_FILENAME__), write-> true) {
            f:.write (defaults::__GITIGNORE_CONTENT__);
            if conf.type.isExecutable () {
                f:.write ("/"s8 ~ conf.name);
            } else f:.write ("/"s8 ~ conf.name ~ ".a"s8);
            f:.write ("\n"s8);
        }

        git::init (cwd-> path);
        git::add (path.push ("."s8));
        git::commit ("Initial commit"s8, cwd-> path);
    }


    /**
     * ================================================================================================================================================================
     * ================================================================================================================================================================
     * ======================================================================   BUILDING   ============================================================================
     * ================================================================================================================================================================
     * ================================================================================================================================================================
     */

    /**
     * Build a repository 
     */
    prv def buildRepo (mut self, conf : GyllirConfig, cwd : &Path = env::currentDir (), doLink : bool = true)-> bool
        throws &RecursiveDependency
    {        
        {
            fs::createDir (cwd.push (defaults::__BUILD_DIR__));
        } catch {
            x : &FsError => {
                if (x.code != FsErrorCode::ALREADY_EXISTS) {
                    println ("Failed to create build repository: "s8 ~ x.msg ~ " ("s8 ~ x.code.(fs::errors::to)![c8] () ~ "). Aborting"s8);
                    return false;
                }
            }
        }

        let mut links : [&Path] = [];
        let mut libs : [&Path] = [];        
        for name, dep in conf.dependencies.getList () {
            let (succ, link, lib) = self:.resolvePackageDependency (cwd, name.(std::conv::to)![c8] (), dep);
            if (!succ) return false;
            
            libs = libs ~ [lib];
            links = links ~ [link.push (defaults::__SRC_DIR__)];
        }
        
        let files = {
            self.listAllSourceFiles (cwd.push (defaults::__SRC_DIR__))
        } catch {
            _ : &FsError => {
                println ("Invalid repository, missing source directory. Aborting");
                return false;
            }
        }

        let toBuild = self.listToBuild (cwd, files);
        if (self:.buildFiles (cwd, toBuild, links, verbose-> self._args.build.isVerbose ())) {
            if doLink {
                let mut ofiles : [&Path] = [];
                for file in files {
                    let oname = file.stripExtension ().addExtension (defaults::__OBJECT_EXTENSION__).file ();
                    let odir = cwd.push (defaults::__BUILD_DIR__).push (file.parent ().removePrefix (cwd));
                    ofiles = ofiles ~ [odir.push (oname)];
                }
            
                return self:.linkRepo (cwd, ofiles, conf, libs, conf.libraries, verbose-> self._args.build.isVerbose ());
            } else return true;
        }

        false
    }
      

    /**
     * Link the files to create the executable or library
     */
    prv def linkRepo (mut self, cwd : &Path, ofiles : [&Path], conf : GyllirConfig, libs : [&Path], libraries : [[c32]], test : bool = false, verbose : bool = false) -> bool {
        let outputname = if !test {
            cwd.push (self.toPath (conf.name, sep-> "/"s8, add-> "_"s8)).toStr ()
        } else {
            cwd.push ("test-"s8 ~ self.toPath (conf.name, sep-> "/"s8, add-> "_"s8)).toStr ()
        }
        
        println ("[100%] Linking ", outputname);
       

        let mut ldirs : [[c8]] = [];
        for l in libs {
            ldirs = ldirs ~ [l.toStr ()];
        }
                      
        if (conf.type.isExecutable () || test) {
            if (verbose) {
                print ("[INFO] Running cmd gyc"s8, " -o "s8, outputname);
                if test { print (" -funittest") }
                for i in ofiles print (" ", i.toStr ());
                for l in libs print (" ", l.toStr ());
                for l in libraries print (" -l", l);
                println ("");                
            }
            
            for l in libraries {
                ldirs = ldirs ~ ["-l"s8, l.(std::conv::to)![c8] ()];
            }
            
            let opt = if (test) { ["-funittest"s8] } else { [] };
            with dmut subProc = SubProcess::run ("gyc"s8, opt ~ ["-o"s8, outputname] ~ ofiles.map!{|x| => const x.toStr ()} () ~ ldirs, cwd-> cwd) {
                let _ = subProc:.wait ();               
                if (verbose) {                                       
                    let o = subProc:.stdout ():.read ();
                    if (o != ""s8)
                        println (o);
                }
                
                let err = subProc:.stderr ():.read ();
                if (err != ""s8) {
                    println (err);
                    return false
                }
            }
        } else if (conf.type.isLibrary ()) {
            if (verbose) {
                print ("[INFO] Running cmd ar"s8, " cr "s8, outputname, ".a"s8);
                for i in ofiles print (" ", i.toStr ());
                for l in libs print (" ", l.toStr ());
                for l in libraries print (" -l", l);
                println ("");                
            }
            
            with dmut subProc = SubProcess::run ("ar"s8, ["cr"s8, outputname ~ ".a"s8] ~ ofiles.map!{|x| => const x.toStr ()} () ~ ldirs, cwd-> cwd) {
                let _ = subProc:.wait ();
                if (verbose) {
                    let o = subProc:.stdout ():.read ();
                    if (o != ""s8)
                        println (o);
                }

                let err = subProc:.stderr ():.read ();
                if (err != ""s8) {
                    println ("Linking failed : ");
                    println (err);
                    return false
                }
            }
        }

        true
    }

    
    /**
     * Build the files 
     */
    prv def buildFiles (mut self, cwd : &Path, files : [&Path], links : [&Path], buildDir : [c8] = defaults::__BUILD_DIR__, test : bool = false, verbose : bool = false) -> bool {
        self._failed = false;
        let mut percent = 0u64;
        for i in 0us .. files.len {
            let prc = (percent * 100u64) / files.len;
            percent += 1u64;
            
            self._mail:.send ((prc, files [i], cwd, buildDir, test, verbose, links));
        }

        let mut threads : [Thread] = [];
        let nb_threads = clamp (self._args.build.getNbThreads (), 1u32, cast!u32 (files.len));
        if (self._args.build.isVerbose () && nb_threads != 0u32) {
            println ("[INFO] Spawning ", nb_threads, " threads");
        }
        
        for _ in 0u32 .. nb_threads {
            let th = spawnNoPipe (&self:.buildFile);
            threads = threads ~ [th];
        }

        for th in threads {
            th.join ();
        }
        
        !self._failed 
    } catch {
        x : &OutOfArray => { println (x); false }
    }


    /**
     * Thread running file compilation
     */
    prv def buildFile (mut self, _ : Thread) {
        loop {
            let (p, file, cwd, buildDir, test, verbose, links) = atomic self {
                match self._mail:.receive () {
                    Ok (x : _) => { x }
                    _ => { return {} }
                }
            }

            let oname = file.stripExtension ().addExtension (defaults::__OBJECT_EXTENSION__).file ();
            let odir = cwd.push (buildDir).push (file.parent ().removePrefix (cwd));
            atomic self {
                fs::createDir (odir, recursive-> true)?
            }

            let mut idirs : [[c8]] = [];
            atomic self {
                for l in links {
                    idirs = idirs ~ ["-I"s8, l.toStr ()];
                }
                
                if (p < 10u64) 
                    println ("[  ", p, "%] Building object ", odir.push (oname).toStr ());
                else println ("[ ", p, "%] Building object ", odir.push (oname).toStr ());
                if verbose {                    
                    print ("[INFO] Running cmd gyc ");
                    if (self._args.build.isDebug ()) print (" -g"s8)
                    else print (" -O3"s8);                    
                    print (if (test) { "-funittest" } else { "" }, " -fdependency -c -o", odir.push (oname).toStr (), " ", file.toStr (), " ", "-I "s8, cwd.push ("src"s8).toStr ());
                    
                    for i in idirs {
                        print (" ", i);
                    }
                    println ("");
                }
            }

            let opt = if (test) { ["-funittest"s8] } else { [] } ;
            with dmut subProc = SubProcess::run ("gyc"s8, opt ~ [if (self._args.build.isDebug ()) "-g"s8 else "-O3"s8] ~ ["-fdependency"s8, "-c"s8, "-o"s8, odir.push (oname).toStr (), file.toStr (), "-I"s8, cwd.push ("src"s8).toStr ()] ~ idirs, cwd-> cwd.push (buildDir)) {
                let _ = subProc:.wait ();
                if (verbose) {
                    let o = subProc:.stdout ():.read ();
                    if o != ""s8 { println (o); }
                }

                let err = subProc:.stderr ():.read ();
                if (err != ""s8) {
                    println ("Failed to compile file : ", oname);
                    println (err);
                    atomic self {
                        self._mail:.clear ();
                        self._failed = true;
                    }
                    return {}
                }
            }

            let depname = self.toPath (file.stripExtension ().removePrefix (cwd).addExtension (defaults::__DEP_EXTENSION__).removeRoot ().toStr (), sep-> "/"s8, add-> "__"s8);
            let dstname = file.stripExtension ().removePrefix (cwd).addExtension (defaults::__DEP_EXTENSION__).toStr ();
            if (depname != dstname) {
                with dmut subProc = SubProcess::run ("mv"s8, [depname, dstname], cwd-> cwd.push (buildDir)) {
                    let _ = subProc:.wait ();
                    let err = subProc:.stderr ():.read ();
                    if (err != ""s8) {
                        println (err);
                        atomic self {
                            self._mail:.clear ();
                            self._failed = true;
                        }
                        return {}
                    }
                }
            }
        }
    }
    
    /**
     * List all the files to build 
     * Either they don't have a .o binary already made, or the source file was modified more recently than the .o 
     * @params:
     *   - files: the list of source file
     * @returns: the list of source files to build
     */
    prv def listToBuild (self, cwd : &Path, files : [&Path], buildDir : [c8] = defaults::__BUILD_DIR__) -> [&Path] {
        let dmut res = Vec!{&Path}::new ();
        let dmut no = Vec!{&Path}::new ();

        for file in files {
            let oname = file.stripExtension ().addExtension (defaults::__OBJECT_EXTENSION__).file ();
            let odir = cwd.push (buildDir).push (file.parent ().removePrefix (cwd));
            let opath = odir.push (oname);
            {
                if (fs::isFile (opath)) {
                    if (fs::fileDate (opath) < fs::fileDate (file)) res:.push (file);
                    else no:.push (file)
                } else res:.push (file);
            } catch {
                _ => res:.push (file);
            }
        }

        res:.fit ();
        no:.fit ();
        self.resolveDependencies (cwd, no [], res [], buildDir-> buildDir)
    }

    /**
     * List all the files that have to be rebuild, due to dependencies
     * @assume: all the files in `files` have a .o, and probabely a .dep.json    
     * @params: 
     *   - files: the list of files that are not build by default
     *   - force: the list of files that will be rebuild
     */
    prv def resolveDependencies (self, cwd : &Path, files : [&Path], force : [&Path], buildDir : [c8] = defaults::__BUILD_DIR__)-> [&Path] {
        import std::config::json;
        
        for i in 0us .. files.len {
            let depname = files [i].stripExtension ().addExtension ("dep.json"s8).file ();
            let depdir = cwd.push (buildDir).push (files [i].parent ().removePrefix (cwd));
            let deppath = depdir.push (depname);
            if fs::isFile (deppath) {
                with dmut dep = File::open (deppath) {
                    let dependencies = json::parse (dep:.readAll ());
                    if self.hasDependency (cwd, dependencies, force) return self.resolveDependencies (cwd, files [0us .. i] ~ files [i + 1us .. $], force ~ [files [i]], buildDir-> buildDir);
                } catch {
                    _ => return self.resolveDependencies (cwd, files [0us .. i] ~ files [i + 1us .. $], force ~ [files [i]], buildDir-> buildDir);
                }
            }
        } catch {
            x : _ => println (x);
        }

        return force;
    }

    /**
     * @returns: true, if the file has a dependency in files
     */
    prv def hasDependency (self, cwd : &Path, conf : &Config, files : [&Path])-> bool {
        let deps = conf ["dependencies"]?;
        match deps {
            Ok (arr : &Array) => {
                for i in 0us .. arr.len () {
                    for f in files {
                        let filePath = f.removePrefix (cwd).removeRoot ();
                        let depPath = Path::new (self.toPath (arr [i].(config::conv::to)![c8] ())).addExtension (defaults::__YMIR_EXTENSION__);
                        if depPath.toStr () == filePath.toStr () {
                            return true;
                        }
                    }
                }
            }
            _ => return true;
        }
        false
    } catch {
        _ => true
    }

    /**
     * Transform a module name into a path
     * @example: 
     * ===========
     * assert (self.toPath ("std::path"s8) == "std/path.yr"s8)
     * ===========
     */
    prv def toPath (self, module : [c8], sep : [c8] = "::"s8, add : [c8] = "/"s8)-> [c8] {
        let dmut res = StringStream::new ();
        let mut i = 0us;
        while i < module.len {
            if i < (module.len - sep.len - 1us) {
                if (module [i .. i + sep.len] == sep) {                    
                    res:.write (add);
                    i += sep.len;
                } else {
                    res:.write (module [i]);
                    i += 1us;
                } 
            } else {
                res:.write (module [i]);
                i += 1us;
            }
        }
        res []
    } catch {
        _ => __pragma!panic ();
    }

            

            
    /**
     * List all the source files in a directory (recursively)
     * A source file is a file, whose extension is __YMIR_EXTENSION__ (.yr)
     * @params: 
     *   - path: the path to the directory to traverse
     */
    prv def listAllSourceFiles (self, path : &Path)-> [&Path]
        throws &FsError
    {
        let dmut res = Vec!{&Path}::new ();
        {
            for entry in fs::readDir (path) {
                match entry {
                    f : &FileEntry => {
                        if f.getPath ().extension () == defaults::__YMIR_EXTENSION__ {
                            res:.push (path.push (f.getPath ()));
                        }
                    }
                    d : &DirEntry => {
                        let files = self.listAllSourceFiles (path.push (d.getPath ()));
                        for f in files { res:.push (f); }
                    }
                }
            }
        }

        res:.fit ();
        res []
    }
    
    /**
     * ================================================================================================================================================================
     * ================================================================================================================================================================
     * ======================================================================   DEPENDENCY   ==========================================================================
     * ================================================================================================================================================================
     * ================================================================================================================================================================
     */

    /**
     * Resolve a dependency, and build it
     */
    pub def resolvePackageDependency (mut self, cwd : &Path, name : [c8], dependency : Dependency) -> (bool, &Path, &Path)
        throws &RecursiveDependency
    {
        let depPath = cwd.push (defaults::__DEPENCY_DIR__).push (name);
        println ("[INFO] Resolving dependency : ", name, " to ", depPath.toStr ());
        {
            if (dependency.url in self._doneDependencies) {
                throw RecursiveDependency::new (name ~ ":"s8 ~ dependency.url.getPath ().toStr ())
            }
            
            if !isDir (depPath) {
                fs::createDir (depPath, recursive-> true);
                
                if (dependency.url.getType () == UrlType::LOCAL) {
                    fs::copyDir (dependency.url.getPath (), depPath, recursive-> true);
                } else {
                    git::clone (dependency.url.getPath ().toStr (), cwd-> depPath);
                }
            }
            
            git::fetchTags (cwd-> depPath);
            git::checkout ("v"s8 ~ dependency.version.toStr (), cwd-> depPath);
            
            let conf = {
                self.loadToml (depPath.push (defaults::__GYLLIR_CONFIG_FILENAME__))
            } catch {
                x : _ => {
                    println ("Failed to read configuration file (", x, "). Aborting");
                    return (false, Path::new (""s8), Path::new (""s8));
                }
            }

            self._doneDependencies:.insert (dependency.url);
            let succ = { 
                self:.buildRepo (conf, cwd-> depPath)
            } catch {
                r : &RecursiveDependency => {
                    throw RecursiveDependency::new (name ~ ":"s8 ~ dependency.url.getPath ().toStr () ~ " => "s8 ~ r.msg);
                }
            }
            self._doneDependencies:.remove (dependency.url);
            
            return (succ, depPath, if (conf.type.isLibrary ()) depPath.push (conf.name).addExtension (defaults::__LIBRARY_EXTENSION__) else Path::new (""s8));
        } catch {
            _ : &GitError => {
                let versions = { self.toVersionList (git::getTagList (cwd-> depPath)) } catch { _ => [] }
                println ("Missing version : ", dependency.version.toStr (), ". Aborting");
                if (versions.len != 0us) {
                    println ("Available versions are : ", versions.map!{|x| const x.toStr ()} ());
                }
                
                return (false, Path::new (""s8), Path::new (""s8));
            }

            r : &RecursiveDependency => throw r;
            
            _ => {
                println ("Failure. Aborting");
                return (false, Path::new (""s8), Path::new (""s8));
            } 
        }
    }

    /**
     * Transform a list of tags (acquired with git) into a list of version
     */
    pub def toVersionList (self, list : [c8])-> [&Version] {
        let tzer = Tokenizer::new (tokens-> ["\n"]);
        let res = tzer.tokenize (list.(std::conv::to)![c32] ());
        let mut versions : [&Version] = [];
        for i in res {
            {
                if (i.len > 0us && i [0us] == 'v') {
                    versions = versions ~ [Version::new (i [1us .. $])];
                }
            } catch {
                _ => {}
            }
        }
        return versions
    }
    
    /**
     * ================================================================================================================================================================
     * ================================================================================================================================================================
     * =======================================================================    CLEANING   ==========================================================================
     * ================================================================================================================================================================
     * ================================================================================================================================================================
     */

    /**
     * Execute the clean repository command
     */
    pub def cleanRepo (self, cwd : &Path = env::currentDir (), all : bool = false, doc : bool = false) {
        let conf = {
            self.loadToml (cwd.push (defaults::__GYLLIR_CONFIG_FILENAME__))
        } catch {
            _ => {
                println ("Failed to read configuration file. Aborting");
                return {}
            }
        }

	if (doc || all) {
            if (fs::isDir (cwd.push ("__doc"s8))) {
		fs::removeDir (cwd.push ("__doc"s8), recursive-> true);
            }            
        }        
        
	if (!doc || all) {
            if (fs::isDir (cwd.push (".build"s8))) {
		fs::removeDir (cwd.push (".build"s8), recursive-> true);
            }
            
            let outputname = self.toPath (conf.name, sep-> "/"s8, add-> "_"s8);            
            if (fs::isFile (cwd.push (outputname))) 
                fs::removeFile (cwd.push (outputname));
        }        
    } catch {
        x : &FsError => println (x);
    }

    /**
     * ================================================================================================================================================================
     * ================================================================================================================================================================
     * =======================================================================    PUBLISH    ==========================================================================
     * ================================================================================================================================================================
     * ================================================================================================================================================================
     */

    /**
     * Publish the repository 
     */
    pub def publishRepo (mut self) {
        let cwd = env::currentDir ();
        let conf = {
            self.loadToml (cwd.push (defaults::__GYLLIR_CONFIG_FILENAME__))
        } catch {
            x : _ => {
                println ("Failed to read configuration file (", x, "). Aborting");                
                return {}
            }
        }
        
        if !conf.registry.isValid () {
            println ("Invalid registry, unable to publish. Aborting");
            return {}
        }
        
        {            
            match conf.registry.getType () {
                UrlType::LOCAL => { self:.publishLocal (cwd, conf, path-> conf.registry.getPath (), ask-> self._args.publish.isYes ()); }
                _ => {
                    let tmpDir = tempDirectory ();
                    let answer =
                        if (self._args.publish.isYes ()) { "Y"s8 } else { self.askUserFor ("Publish to git : "s8 ~ conf.registry.getPath ().toStr () ~ " (Y/n)"s8, default-> "Y"s8) }
                    
                    if answer != "Y"s8 { println ("Aborting"); return {} }                    
                    let (succ, version) = self:.publishLocal (cwd, conf, path-> tmpDir, ask-> false);
                    if (succ) {
                        self:.publishGit (conf, tmpDir, version);
                    }
                }
            }
        } catch {
            x : _ => println (x);
        }
    }

    /**
     * Publish a package to a local location
     */
    pub def publishLocal (mut self, cwd : &Path, conf : GyllirConfig, path : &Path = Path::new ("."), ask : bool = true)-> (bool, &Version)
        throws &FsError, &GitError
    {
        let answer =
            if (!ask) { "Y"s8 } else { self.askUserFor ("Publish to local : "s8 ~ path.toStr () ~ " (Y/n)"s8, default-> "Y"s8) }

        if answer != "Y"s8 { println ("Aborting"); return (false, conf.version); }
        
        self.cleanRepo (cwd-> cwd, all-> true);
        if (!self._args.publish.isDry ()) {
            let res = {
                self:.runTests (cwd-> cwd)
            } catch {
                r : &RecursiveDependency => {
                    println ("Failed to build repository, recursive dependency : ");
                    println (r.msg);
                    println ("Aborting");
                    return (false, conf.version);
                }
            }
            
            self.cleanRepo (cwd-> cwd, all-> true);
            if !res {
                println ("Test failed to pass. Aborting");
                return (false, conf.version);
            }
        }

        let version = conf.version.increment (major-> self._args.publish.isMajor (),
                                              minor-> self._args.publish.isMinor (),
                                              patch-> self._args.publish.isPatch ());
        let conf2 = GyllirConfig (conf.name, conf.license, conf.description, type-> conf.type, registry-> conf.registry, conf.author, version-> version, dependencies-> conf.dependencies, libraries-> conf.libraries);
        self.saveToml (cwd.push (defaults::__GYLLIR_CONFIG_FILENAME__), conf2.to!{&Config} ());

        git::add (cwd.push ("."s8));
        git::commit (self._args.publish.getMessage ().(std::conv::to)![c8] (), cwd-> cwd);
        git::createTag ("v"s8 ~ version.toStr ());

        if isDir (path) {
            fs::removeDir (path, recursive-> true);
        }
        
        fs::createDir (path, recursive-> true);
        println ("copy dir : ", path, " ", cwd);
        fs::copyDir (cwd, path, recursive-> true);
        
        (true, version)
    }

    /**
     * Publish the repo to a git location
     */
    pub def publishGit (mut self, conf : GyllirConfig, tmpDir : &Path, version : &Version)
    {
        println (tmpDir);
        git::setRemote (cwd-> tmpDir, conf.registry.getPath ().toStr ());
        git::push (["v"s8 ~ version.toStr (), "master"s8], cwd-> tmpDir);
    } catch {
        x : &GitError => {
            println ("Failed to publish to git repository. Aborting");
            println (x);
        }
    }
    
    
    /**
     * ================================================================================================================================================================
     * ================================================================================================================================================================
     * =======================================================================     TESTS     ==========================================================================
     * ================================================================================================================================================================
     * ================================================================================================================================================================
     */

    /**
     * Run the tests of the repo
     */
    pub def runTests (mut self, cwd : &Path = env::currentDir ()) -> bool
        throws &RecursiveDependency
    {
        let conf = {
            self.loadToml (cwd.push (defaults::__GYLLIR_CONFIG_FILENAME__))
        } catch {
            _ => {
                println ("Failed to read configuration file. Aborting");
                return false
            }
        }        
        if self:.buildTest (cwd, conf) {
            let outputname =  cwd.push ("test-"s8 ~ self.toPath (conf.name, sep-> "/"s8, add-> "_"s8));
            let res = self:.launchTest (cwd, outputname);
            fs::removeFile (outputname)?;
            return res;
        }
        
        false
    }
    
    /**
     * Compile the test executable
     */
    pub def buildTest (mut self, cwd : &Path, conf : GyllirConfig)-> bool
        throws &RecursiveDependency
    {
        {
            fs::createDir (cwd.push (defaults::__BUILD_DIR__));
            fs::createDir (cwd.push (defaults::__TEST_DIR__));
        } catch {
            x : &FsError => {
                if (x.code != FsErrorCode::ALREADY_EXISTS) {
                    println ("Failed to create build repository: "s8 ~ x.msg ~ " ("s8 ~ x.code.(fs::errors::to)![c8] () ~ "). Aborting"s8);
                    return false;
                }
            }
        }

        let mut links : [&Path] = [];
        let mut libs : [&Path] = [];        
        for name, dep in conf.dependencies.getList () {
            let (succ, link, lib) = self:.resolvePackageDependency (cwd, name.(std::conv::to)![c8] (), dep);
            if (!succ) return false;
            
            libs = libs ~ [lib];
            links = links ~ [link.push (defaults::__SRC_DIR__)];
        }
        
        let files = {
            self.listAllSourceFiles (cwd.push (defaults::__SRC_DIR__)) ~ self.listAllSourceFiles (cwd.push (defaults::__TEST_DIR__))
        } catch {
            _ : &FsError => {
                println ("Invalid repository, missing test directory. Aborting");
                return false;
            }
        }

        
        let toBuild = self.listToBuild (cwd, files, buildDir-> defaults::__BUILD_TEST_DIR__);
        if (self:.buildFiles (cwd, toBuild, links, buildDir-> defaults::__BUILD_TEST_DIR__, test-> true, verbose-> self._args.test.isVerbose ())) {
            {
                let mut ofiles : [&Path] = [];
                for file in files {
                    let oname = file.stripExtension ().addExtension (defaults::__OBJECT_EXTENSION__).file ();
                    let odir = cwd.push (defaults::__BUILD_TEST_DIR__).push (file.parent ().removePrefix (cwd));
                    ofiles = ofiles ~ [odir.push (oname)];
                }
                
                return self:.linkRepo (cwd, ofiles, conf, libs, conf.libraries, test-> true, verbose-> self._args.test.isVerbose ());
            }
        } 
        
        false
    }

    /**
     * Launch the tests
     */
    pub def launchTest (mut self, cwd : &Path, exec : &Path) -> bool {
        with dmut subProc = SubProcess::run (exec.toStr (), [], cwd-> cwd) {
            let code = subProc:.wait ();
            print (subProc:.stdout ():.read ());

            if (code != 0) {
                println ("[ERROR] Return code : ", code);
                println (subProc:.stderr ():.read ());
                return false;
            }
        }
        return true;
    }
    
    /**
     * ================================================================================================================================================================
     * ================================================================================================================================================================
     * ======================================================================     COMMON     ==========================================================================
     * ================================================================================================================================================================
     * ================================================================================================================================================================
     */


    /**
     * Save a configation into a file
     */
    pub def saveToml (self, path : &Path, content : &Config)
        throws &FsError
    {
        import std::config::toml;
        with dmut f = File::create (path, write-> true) {
            f:.write (content.dump ().(std::conv::to)![c8] ());
        }
    }

    /**
     * Read the configuration file
     */
    pub def loadToml (self, path : &Path)-> GyllirConfig
        throws &FsError, &SyntaxError, &ConfigError
    {
        import std::config::toml;
        with dmut f = File::open (path) {
            toml::parse (f:.readAll ()).(config::conv::to)!{GyllirConfig} ()
        }
    } 

    /**
     * @returns: true if the error was thrown by a sub command that printed the help
     */
    pub def hasHelpPrinted (self, err : &ArgumentError) -> bool {
        match err.subError {
            Ok (HelpPrinted ()) => { true }
            Ok (sub : &ArgumentError) => { self.hasHelpPrinted (sub) }
            _ => false
        }
    }

    /**
     * @returns: true if no option is set
     */
    pub def noneIsSet (self)-> bool {
        !self._args.init.isSet () &&
            !self._args.build.isSet () &&
            !self._args.clean.isSet () &&
            !self._args.publish.isSet () &&
            !self._args.test.isSet ()
    }
    
}
