in manager;

use std::{config::_, fs::_};
use gyllir::{config::_, args, args::_, utils::_};
use gyllir::repo::_;
use std::{concurrency::process, syntax::tokenizer};

/**
 * The gyllir manager if the core of gyllir
 */
pub class GyllirManager {

    // The list of arguments passed to the program
    let mut _args : &Config;

    // The list of resolved dependencies
    let dmut _depPackages : [Url => ()] = [];

    /**
     * Create a Gyllir builder from an argument 
     */
    pub self (args : [[c8]])
        with _args = (copy GyllirArgumentParser ()).parse (args)
    {}
    
    /**
     * Run the builder
     * @returns: the builder did something
     */
    pub fn run (mut self) {
        if let Ok (c) = self._args ["init"]? {
            RepoInitializer (c).run ()
        }

        else if let Ok (c) =  self._args ["build"]? {
            RepoBuilder (env::currentDir (), c, self.loadToml (env::currentDir ())).run (alias self);
        }

        // else if "run" in self._args {
        //     let cfg = self.loadConfig ();
        //     RepoBuilder (cfg).run ();
        //     RepoRunner (cfg).run ();
        // }

        // else if "clean" in self._args {
        //     RepoCleaner (self.loadConfig ()).run ();
        // }

        // else if "publish" in self._args {
        //     RepoPublisher (self.loadConfig ()).run ();
        // }

        // else if "test" in self._args {
        //     RepoTestBuilder (self.loadConfig ()).run ();
        //     RepoTestRunner (self.loadConfig ()).run ();
        // }

        // else if "doc" in self._args {
        //     RepoDocBuilder (self.loadConfig ()).run ();
        //     RepoDocRunner (self.loadConfig ()).run ();
        // }

        else panic;
    } catch {
        err => {
            std::io::eprintln (err);
            etc::c::process::_yrt_exit (-1);
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          PRIVATE          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */


    /**
     * Load the configuration file
     * */
    prv fn loadToml (self, path : Path)-> GyllirPackageConfiguration {
        let dmut f = File::open (path.push (defaults::__GYLLIR_CONFIG_FILENAME__));
        let cfg = std::config::toml::parse (f:.readAll ());
        f:.close ();

        GyllirPackageConfiguration (cfg)
    } catch {
        err => {
            std::io::eprintln (err);
            etc::c::process::_yrt_exit (-1);
            panic;
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          DEPENDENCIES          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Resolve a dependency, and build it
     */
    pub fn resolveDependency (mut self, args : &Config, cwd : Path, name : [c8], dependency : Dependency)
        throws RecursiveDependency
    {
        let depPath = cwd.push (defaults::__DEPENCY_DIR__).push (name);
        {
            if (dependency.url in self._depPackages) {
                throw copy RecursiveDependency (name ~ ":"s8 ~ dependency.url.path.toStr ())
            }

            std::io::println ("[INFO] Resolving dependency : ", name, " to ", depPath.toStr ());
            let gM = GitManager (cwd-> depPath);
            if !isDir (depPath) {
                if !isDir (depPath.parent ()) {
                    fs::sys::createDir (depPath.parent (), recursive-> true);
                }

                if (dependency.url.type == UrlType::LOCAL) {
                    self.runProcess ("cp"s8, copy ["-r"s8, dependency.url.path.toStr (), depPath.parent ().toStr ()]);
                    self.runProcess ("mv"s8, copy [dependency.url.path.file (), name], cwd-> depPath.parent ());
                } else {
                    gM.clone (dependency.url.path.toStr ());
                }
            }

            gM.fetchTags ();
            gM.checkout ("v"s8 ~ dependency.version[]);

            let conf = self.loadToml (depPath);
            if (conf.type.isExecutable ()) {
                std::io::eprintln ("Dependency : ", dependency.url, " is not a library. Aborting.");
                etc::c::process::_yrt_exit (-1);
                panic;
            }

            self._depPackages [dependency.url] = ();
            {
                RepoBuilder (depPath, args, conf).run (alias self);
            } catch {
                r : &RecursiveDependency => {
                    throw copy RecursiveDependency (name ~ ":"s8 ~ dependency.url.path.toStr () ~ " => "s8 ~ r.msg);
                }
            }

            self._depPackages:.remove (dependency.url);
        } catch {
            GitError () => {
                let versions = {
                    self.toVersionList (GitManager (cwd-> depPath).getTagList ())
                } catch { _ => [] };

                std::io::eprintln ("Missing version : ", dependency.version[], ". Aborting");
                if (versions.len != 0us) {
                    std::io::eprintln ("Available versions are : ", copy [c[] for c in versions]);
                }

                etc::c::process::_yrt_exit (-1);
                panic;
            }

            r : &RecursiveDependency => throw r;
            x => {
                std::io::eprintln ("Failure. Aborting", x);
                etc::c::process::_yrt_exit (-1);
                panic;
            }
        }
    }

    /**
     * Transform a list of tags (acquired with git) into a list of version
     */
    pub fn toVersionList (self, list : [c8])-> [Version] {
        let dmut tzer = Tokenizer!c8 ();
        tzer:.insert ("\n", isSkip-> true);
        let res = tzer.tokenizeWithoutSkips (list);

        let mut versions : [Version] = [];
        for i in res {
            {
                if (i.len > 0us && i [0us] == 'v') {
                    versions = versions ~ [Version (i [1us .. $])];
                }
            } catch {
                _ => {}
            }
        }

        return versions;
    }

    /**
     * Run a sub process
     * */
    pub fn runProcess (self, cmd : [c8], params : [[c8]], cwd : Path = env::currentDir ())-> bool {
        let dmut subProc = copy SubProcess (cmd, params, cwd-> cwd);
        subProc:.start (redirect-> false);
        let code = subProc:.wait ();
        code == 0
    } catch {
        _ => false
    }

}
