in manager;

use std::{config::_, fs::_};
use gyllir::{config::_, args, args::_, utils::_};
use gyllir::repo::_;
use std::{concurrency::process, syntax::tokenizer};

/**
 * The gyllir manager if the core of gyllir
 */
pub class GyllirManager {

    // The list of arguments passed to the program
    let mut _args : &Config;

    // The list of resolved dependencies
    let dmut _depPackages : [Url => ()] = [];

    /**
     * Create a Gyllir builder from an argument 
     */
    pub self (args : [[c8]])
        with _args = (copy GyllirArgumentParser ()).parse (args)
    {}
    
    /**
     * Run the builder
     * @returns: the builder did something
     */
    pub fn run (mut self) {
        if let Ok (c) = self._args ["init"]? {
            RepoInitializer (c).run ()
        }

        else if let Ok (c) =  self._args ["build"]? {
            RepoBuilder (env::currentDir (), c, self.loadToml (env::currentDir ())).run (alias self);
        }

        else if let Ok (c) = self._args ["run"]? {
            let cfg = self.loadToml (env::currentDir ());
            RepoBuilder (env::currentDir (), copy Dict (), cfg).run (alias self);
            RepoRunner (env::currentDir (), c, cfg).run ();
        }

        // else if "clean" in self._args {
        //     RepoCleaner (self.loadConfig ()).run ();
        // }

        // else if "publish" in self._args {
        //     RepoPublisher (self.loadConfig ()).run ();
        // }

        // else if "test" in self._args {
        //     RepoTestBuilder (self.loadConfig ()).run ();
        //     RepoTestRunner (self.loadConfig ()).run ();
        // }

        // else if "doc" in self._args {
        //     RepoDocBuilder (self.loadConfig ()).run ();
        //     RepoDocRunner (self.loadConfig ()).run ();
        // }

        else panic;
    } catch {
        err => {
            std::io::eprintln (err);
            etc::c::process::_yrt_exit (-1);
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          PRIVATE          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */


    /**
     * Load the configuration file
     * */
    prv fn loadToml (self, path : Path)-> GyllirPackageConfiguration {
        let dmut f = File::open (path.push (defaults::__GYLLIR_CONFIG_FILENAME__));
        let cfg = std::config::toml::parse (f:.readAll ());
        f:.close ();

        GyllirPackageConfiguration (cfg)
    } catch {
        err => {
            std::io::eprintln (err);
            etc::c::process::_yrt_exit (-1);
            panic;
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          DEPENDENCIES          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Resolve a dependency, and build it
     */
    pub fn resolveDependency (mut self, args : &Config, cwd : Path, name : [c8], dependency : Dependency)-> ([[c8]], [[c8]])
        throws RecursiveDependency
    {
        if (dependency.url in self._depPackages) {
            throw copy RecursiveDependency (name ~ ":"s8 ~ dependency.url.path.toStr ())
        }

        let depPath = cwd.push (defaults::__DEPENCY_DIR__).push (name);
        {
            std::io::println ("[INFO] Resolving dependency : ", name, " to ", depPath.toStr ());
            let gM = GitManager (cwd-> depPath);
            if (dependency.url.type == UrlType::LOCAL) {
                if (!isDir (depPath) || fs::sys::fileDate (depPath) < fs::sys::fileDate (dependency.url.path)) {
                    if !isDir (depPath.parent ()) {
                        fs::sys::createDir (depPath.parent (), recursive-> true);
                    }

                    self.runProcess ("ln"s8, copy ["-s"s8, dependency.url.path.toStr (), depPath.toStr ()]);
                }
            }

            else if !isDir (depPath) {
                gM.clone (dependency.url.path.toStr ());
            }

            let version = dependency.version.select (self.toVersionList (GitManager (cwd-> depPath).getTagList ()));
            gM.fetchTags ();
            if (version.isNumbered ()) {
                gM.checkout ("v" ~ version[]);
            } else gM.checkout (version[]);

            if (dependency.url.type == UrlType::GIT) {
                if (version.isNumbered ()) {
                    gM.pull ("v" ~ version[]);
                } else gM.pull (version[]);
            }

            let conf = self.loadToml (depPath);
            if (conf.type.isExecutable ()) {
                std::io::eprintln ("Dependency : ", dependency.url, " is not a library. Aborting.");
                etc::c::process::_yrt_exit (-1);
                panic;
            }

            self._depPackages [dependency.url] = ();
            let (ext, lbs) = RepoBuilder (depPath, args, conf).run (alias self);

            self._depPackages:.remove (dependency.url);
            (ext, lbs)
        } catch {
            GitError () => {
                let versions = {
                    self.toVersionList (GitManager (cwd-> depPath).getTagList ())
                } catch { _ => [] };

                std::io::eprintln ("Missing version : ", dependency.version[], ". Aborting");
                if (versions.len != 0us) {
                    std::io::eprintln ("Available versions are : ", copy [c[] for c in versions]);
                }

                etc::c::process::_yrt_exit (-1);
                panic;
            }

            r : &RecursiveDependency => {
                throw copy RecursiveDependency (name ~ ":"s8 ~ dependency.url.path.toStr (), subError-> (r)?);
            }
            a : &AssertError => {
                std::io::eprintln (a.msg);
                etc::c::process::_yrt_exit (-1);
                panic;
            }
            x => {
                std::io::eprintln ("Failure. Aborting", x);
                etc::c::process::_yrt_exit (-1);
                panic;
            }
        }
    }

    /**
     * Transform a list of tags (acquired with git) into a list of version
     */
    pub fn toVersionList (self, list : [c8])-> [Version] {
        let dmut tzer = Tokenizer!c8 ();
        tzer:.insert ("\n", isSkip-> true);
        let res = tzer.tokenizeWithoutSkips (list);

        let mut versions : [Version] = [];
        for i in res {
            versions = versions ~ [Version (i)];
        }

        return versions;
    }

    /**
     * Run a sub process
     * */
    pub fn runProcess (self, cmd : [c8], params : [[c8]], cwd : Path = env::currentDir ())-> bool {
        let dmut subProc = copy SubProcess (cmd, params, cwd-> cwd);
        subProc:.start (redirect-> false);
        let code = subProc:.wait ();
        code == 0
    } catch {
        _ => false
    }

}
