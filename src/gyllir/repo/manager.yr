in manager;

use std::config::_;
use gyllir::{config::_, args, args::_};
use gyllir::repo::_;

/**
 * The gyllir manager if the core of gyllir
 */
pub class GyllirManager {

    // The list of arguments passed to the program
    let mut _args : &Config;

    /**
     * Create a Gyllir builder from an argument 
     */
    pub self (args : [[c8]])
        with _args = (copy GyllirArgumentParser ()).parse (args)
    {}
    
    /**
     * Run the builder
     * @returns: the builder did something
     */
    pub fn run (mut self) {
        if "init" in self._args {
            RepoInitializer (self._args ["init"]).run ()
        }

        // else if "build" in self._args {
        //     RepoBuilder (self.loadConfig ()).run ();
        // }

        // else if "run" in self._args {
        //     let cfg = self.loadConfig ();
        //     RepoBuilder (cfg).run ();
        //     RepoRunner (cfg).run ();
        // }

        // else if "clean" in self._args {
        //     RepoCleaner (self.loadConfig ()).run ();
        // }

        // else if "publish" in self._args {
        //     RepoPublisher (self.loadConfig ()).run ();
        // }

        // else if "test" in self._args {
        //     RepoTestBuilder (self.loadConfig ()).run ();
        //     RepoTestRunner (self.loadConfig ()).run ();
        // }

        // else if "doc" in self._args {
        //     RepoDocBuilder (self.loadConfig ()).run ();
        //     RepoDocRunner (self.loadConfig ()).run ();
        // }

        else panic;
    } catch {
        _ => panic;
    }



    // /**
    //  * ================================================================================================================================================================
    //  * ================================================================================================================================================================
    //  * ======================================================================   BUILDING   ============================================================================
    //  * ================================================================================================================================================================
    //  * ================================================================================================================================================================
    //  */

    // /**
    //  * Build a repository
    //  */
    // prv fn buildRepo (mut self, conf : GyllirConfig, cwd : &Path = env::currentDir (), doLink : bool = true, inDependency : bool = false)-> bool
    //     throws &RecursiveDependency
    // {
    //     let dmut builder = RepoBuilder::new (alias self, conf, cwd-> cwd);
    //     let mut succ = false;
    //     {
    //         succ = builder:.construct (inDependency-> inDependency);
    //         if (succ && doLink) {
    //             succ = builder:.compile ();
    //         }
    //     } catch {
    //         _ : &FsError => return false;
    //         x : &RecursiveDependency => throw x;
    //     }

    //     return succ;
    // }


    // /**
    //  * ================================================================================================================================================================
    //  * ================================================================================================================================================================
    //  * ======================================================================   DEPENDENCY   ==========================================================================
    //  * ================================================================================================================================================================
    //  * ================================================================================================================================================================
    //  */

    // /**
    //  * Resolve a dependency, and build it
    //  */
    // pub fn resolvePackageDependency (mut self, cwd : &Path, name : [c8], dependency : Dependency) -> ([c8], bool)
    //     throws &RecursiveDependency
    // {
    //     let depPath = cwd.push (defaults::__DEPENCY_DIR__).push (name);
    //     {
    //         if (dependency.url in self._doneDependencies) {
    //             throw RecursiveDependency::new (name ~ ":"s8 ~ dependency.url.getPath ().toStr ())
    //         }

    //         println ("[INFO] Resolving dependency : ", name, " to ", depPath.toStr ());
    //         if !isDir (depPath) {
    //             if !isDir (depPath.parent ()) {
    //                 fs::sys::createDir (depPath.parent (), recursive-> true);
    //             }

    //             if (dependency.url.getType () == UrlType::LOCAL) {
    //                 self.runProcess ("cp"s8, ["-r"s8, dependency.url.getPath ().toStr (), depPath.parent ().toStr ()]);
    //                 self.runProcess ("mv"s8, [dependency.url.getPath ().file (), name], cwd-> depPath.parent ());
    //             } else {
    //                 git::clone (dependency.url.getPath ().toStr (), cwd-> depPath);
    //             }
    //         }

    //         git::fetchTags (cwd-> depPath);
    //         git::checkout ("v"s8 ~ dependency.version.toStr (), cwd-> depPath);

    //         let conf = {
    //             self.loadToml (depPath.push (defaults::__GYLLIR_CONFIG_FILENAME__))
    //         } catch {
    //             x : _ => {
    //                 eprintln ("Failed to read configuration file (", x, "). Aborting");
    //                 return (""s8, false);
    //             }
    //         }

    //         if (conf.type.isExecutable ()) {
    //             eprintln ("Dependency : ", dependency.url, " is not a library. Aborting.");
    //             return (""s8, false);
    //         }

    //         self._doneDependencies:.insert (dependency.url);
    //         let succ = {
    //             self:.buildRepo (conf, cwd-> depPath, doLink-> false, inDependency-> true)
    //         } catch {
    //             r : &RecursiveDependency => {
    //                 throw RecursiveDependency::new (name ~ ":"s8 ~ dependency.url.getPath ().toStr () ~ " => "s8 ~ r.msg);
    //             }
    //         }
    //         self._doneDependencies:.remove (dependency.url);
    //         return (conf.name, succ);
    //     } catch {
    //         g : &GitError => {
    //             println (g);
    //             let versions = { self.toVersionList (git::getTagList (cwd-> depPath)) } catch { _ => [] }
    //             println ("Missing version : ", dependency.version.toStr (), ". Aborting");
    //             if (versions.len != 0us) {
    //                 println ("Available versions are : ", versions.map!{|x| const x.toStr ()} ());
    //             }

    //             return (""s8, false);
    //         }

    //         r : &RecursiveDependency => throw r;

    //         x : _ => {
    //             println ("Failure. Aborting", x);
    //             return (""s8, false);
    //         }
    //     }
    // }

    // /**
    //  * Transform a list of tags (acquired with git) into a list of version
    //  */
    // pub fn toVersionList (self, list : [c8])-> [&Version] {
    //     let tzer = Tokenizer::new (tokens-> ["\n"]);
    //     let res = tzer.tokenize (list.(std::conv::to)![c32] ());
    //     let mut versions : [&Version] = [];
    //     for i in res {
    //         {
    //             if (i.len > 0us && i [0us] == 'v') {
    //                 versions = versions ~ [Version::new (i [1us .. $])];
    //             }
    //         } catch {
    //             _ => {}
    //         }
    //     }
    //     return versions
    // }

    // /**
    //  * ================================================================================================================================================================
    //  * ================================================================================================================================================================
    //  * =======================================================================    CLEANING   ==========================================================================
    //  * ================================================================================================================================================================
    //  * ================================================================================================================================================================
    //  */

    // /**
    //  * Execute the clean repository command
    //  */
    // pub fn cleanRepo (self, cwd : &Path = env::currentDir (), all : bool = false, doc : bool = false) {
    //     let conf = {
    //         self.loadToml (cwd.push (defaults::__GYLLIR_CONFIG_FILENAME__))
    //     } catch {
    //         _ => {
    //             println ("Failed to read configuration file. Aborting");
    //             return {}
    //         }
    //     }

	// if (doc || all) {
    //         if (fs::sys::isDir (cwd.push ("__doc"s8))) {
    //             self.runProcess ("rm"s8, ["-rf"s8, cwd.push ("__doc"s8).toStr ()]);
    //         }
    //     }

	// if (!doc || all) {
    //         if (fs::sys::isDir (cwd.push (defaults::__BUILD_DIR__))) {
    //             self.runProcess ("rm"s8, ["-rf"s8, cwd.push (defaults::__BUILD_DIR__).toStr ()]);
    //         }

    //         if (fs::sys::isDir (cwd.push (defaults::__LIB_DIR__))) {
    //             self.runProcess ("rm"s8, ["-rf"s8, cwd.push (defaults::__LIB_DIR__).toStr ()]);
    //         }

    //         let outputname = __version WINDOWS {
    //             utils::path::toPath (conf.name ~ ".exe"s8, sep-> "/"s8, add-> "_"s8)
    //         } else {
    //             utils::path::toPath (conf.name, sep-> "/"s8, add-> "_"s8)
    //         }

    //         if (fs::sys::isFile (cwd.push (outputname)))
    //             self.runProcess ("rm"s8, [cwd.push (outputname).toStr ()]);

    //         let testoutputname = __version WINDOWS {
    //             utils::path::toPath ("test_"s8 ~ conf.name ~ ".exe", sep-> "/"s8, add-> "_"s8)
    //         } else {
    //             utils::path::toPath ("test_"s8 ~ conf.name, sep-> "/"s8, add-> "_"s8)
    //         }

    //         if (fs::sys::isFile (cwd.push (testoutputname)))
    //             self.runProcess ("rm"s8, [cwd.push (testoutputname).toStr ()]);
    //     }
    // }

    // /**
    //  * ================================================================================================================================================================
    //  * ================================================================================================================================================================
    //  * =======================================================================    PUBLISH    ==========================================================================
    //  * ================================================================================================================================================================
    //  * ================================================================================================================================================================
    //  */

    // /**
    //  * Publish the repository
    //  */
    // pub fn publishRepo (mut self) {
    //     let cwd = env::currentDir ();
    //     let conf = {
    //         self.loadToml (cwd.push (defaults::__GYLLIR_CONFIG_FILENAME__))
    //     } catch {
    //         x : _ => {
    //             println ("Failed to read configuration file (", x, "). Aborting");
    //             return {}
    //         }
    //     }

    //     if !conf.registry.isValid () {
    //         println ("Invalid registry, unable to publish. Aborting");
    //         return {}
    //     }

    //     {
    //         match conf.registry.getType () {
    //             UrlType::LOCAL => { self:.publishLocal (cwd, conf, path-> conf.registry.getPath (), ask-> self._args.publish.isYes ()); }
    //             _ => {
    //                 let tmpDir = tempDirectory ();
    //                 let answer =
    //                     if (self._args.publish.isYes ()) { "Y"s8 } else { self.askUserFor ("Publish to git : "s8 ~ conf.registry.getPath ().toStr () ~ " (Y/n)"s8, default-> "Y"s8) }

    //                 if answer != "Y"s8 { println ("Aborting"); return {} }
    //                 let (succ, version) = self:.publishLocal (cwd, conf, path-> tmpDir, ask-> false);
    //                 if (succ) {
    //                     self:.publishGit (conf, tmpDir.push (conf.name), version);
    //                 }
    //             }
    //         }
    //     } catch {
    //         x : _ => println (x);
    //     }
    // }

    // /**
    //  * Publish a package to a local location
    //  */
    // pub fn publishLocal (mut self, cwd : &Path, conf : GyllirConfig, path : &Path = Path::new ("."), ask : bool = true)-> (bool, &Version)
    //     throws &FsError, &GitError
    // {
    //     let answer =
    //         if (!ask) { "Y"s8 } else { self.askUserFor ("Publish to local : "s8 ~ path.toStr () ~ " (Y/n)"s8, default-> "Y"s8) }

    //     if answer != "Y"s8 { println ("Aborting"); return (false, conf.version); }

    //     self.cleanRepo (cwd-> cwd, all-> true);
    //     if (!self._args.publish.isDry ()) {
    //         let res = {
    //             self:.runTests (conf, cwd-> cwd, false)
    //         } catch {
    //             r : &RecursiveDependency => {
    //                 println ("Failed to build repository, recursive dependency : ");
    //                 println (r.msg);
    //                 println ("Aborting");
    //                 return (false, conf.version);
    //             }
    //         }

    //         self.cleanRepo (cwd-> cwd, all-> true);
    //         if !res {
    //             println ("Test failed to pass. Aborting");
    //             return (false, conf.version);
    //         }
    //     }

    //     let version = conf.version.increment (major-> self._args.publish.isMajor (),
    //                                           minor-> self._args.publish.isMinor (),
    //                                           patch-> self._args.publish.isPatch ());
    //     let conf2 = GyllirConfig (conf.name, conf.license, conf.description, type-> conf.type, registry-> conf.registry, conf.author, version-> version, dependencies-> conf.dependencies, libraries-> conf.libraries);
    //     self.saveToml (cwd.push (defaults::__GYLLIR_CONFIG_FILENAME__), conf2.to!{&Config} ());

    //     git::add (cwd.push ("."s8));
    //     git::commit (self._args.publish.getMessage ().(std::conv::to)![c8] (), cwd-> cwd);
    //     git::createTag ("v"s8 ~ version.toStr ());

    //     if isDir (path) {
    //         self.runProcess ("rm"s8, ["-rf"s8, path.toStr ()]);
    //     }

    //     fs::sys::createDir (path.parent (), recursive-> true)?;

    //     println ("[INFO] publish to ", path.toStr ());
    //     self.runProcess ("cp"s8, ["-r"s8, cwd.toStr (), path.toStr ()]);

    //     (true, version)
    // }

    // /**
    //  * Publish the repo to a git location
    //  */
    // pub fn publishGit (mut self, conf : GyllirConfig, tmpDir : &Path, version : &Version)
    // {
    //     git::setRemote (cwd-> tmpDir, conf.registry.getPath ().toStr ());
    //     git::push (["v"s8 ~ version.toStr (), "master"s8], cwd-> tmpDir);
    // } catch {
    //     x : &GitError => {
    //         println ("Failed to publish to git repository. Aborting");
    //         println (x);
    //     }
    // }


    // /**
    //  * ================================================================================================================================================================
    //  * ================================================================================================================================================================
    //  * =======================================================================     TESTS     ==========================================================================
    //  * ================================================================================================================================================================
    //  * ================================================================================================================================================================
    //  */

    // /**
    //  * Run the tests of the repo
    //  */
    // prv fn runTests (mut self, conf : GyllirConfig, cwd : &Path = env::currentDir (), isDry : bool) -> bool
    //     throws &RecursiveDependency
    // {
    //     let dmut builder = RepoBuilder::new (alias self, conf, cwd-> cwd);
    //     let mut succ = false;
    //     {
    //         succ = builder:.construct ();
    //         succ = builder:.compile (forTest-> true);

    //         if (succ && !isDry) {
    //             succ = self.runProcess ("./test_"s8 ~ conf.name, [], printOut-> true, printErr-> true);
    //             if (!succ) println ("[ERROR] Tests failed."s8);
    //         }
    //     } catch {
    //         _ : &FsError => return false;
    //         x : &RecursiveDependency => throw x;
    //     }

    //     return succ;

    // }


    // /**
    //  * ================================================================================================================================================================
    //  * ================================================================================================================================================================
    //  * ======================================================================     DOCUMENTATION     ===================================================================
    //  * ================================================================================================================================================================
    //  * ================================================================================================================================================================
    //  */

    // /**
    //  * Generate the documentation of the repository
    //  */
    // prv fn generateDoc (mut self, conf : GyllirConfig, cwd : &Path = env::currentDir ())
    //     throws &RecursiveDependency
    // {
    //     let d = self.getArguments ().doc;
    //     let dmut jsons = Vec!{&Path}::new ();
    //     if (d.inDir () != ""s8) {
    //         {
    //             for e in fs::sys::readDir (Path::new (d.inDir ())) {
    //                 match e {
    //                     f : &FileEntry => {
    //                         if (f.path.extension () == "json"s8) {
    //                             jsons:.push (f.path);
    //                         }
    //                     }
    //                 }
    //             }
    //         } catch {
    //             x : &FsError => {
    //                 println (x);
    //                 println ("[ERROR] Doc compilation failed."s8);
    //                 return {};
    //             }
    //         }
    //     } else {
    //         let dmut builder = RepoBuilder::new (alias self, conf, cwd-> cwd);
    //         let mut succ = false;
    //         {
    //             succ = builder:.construct ();
    //             succ = builder:.compile (forDoc-> true);
    //             if (succ) {
    //                 let srcDir = cwd.push (defaults::__BUILD_DIR__).push (defaults::__DOC_DIR__);
    //                 for e in fs::sys::readDir (srcDir) {
    //                     match e {
    //                         f : &FileEntry => {
    //                             if (f.path.extension () == "json"s8) {
    //                                 jsons:.push (f.path);
    //                             }
    //                         }
    //                     }
    //                 }
    //             } else println ("[ERROR] Doc compilation failed."s8);
    //         } catch {
    //             _ : &FsError => {
    //                 println ("[ERROR] Doc compilation failed."s8);
    //                 return {};
    //             }
    //             x : &RecursiveDependency => throw x;
    //         }
    //     }

    //     let outDir = cwd.push (defaults::__DOC_DIR__);
    //     let dmut docDumper = DocDumper::new (alias self, conf, jsons[], outDir, verbose-> d.isVerbose ());

    //     docDumper.generate ();
    // }

    // /**
    //  * ================================================================================================================================================================
    //  * ================================================================================================================================================================
    //  * ======================================================================     COMMON     ==========================================================================
    //  * ================================================================================================================================================================
    //  * ================================================================================================================================================================
    //  */


    // /**
    //  * Save a configation into a file
    //  */
    // pub fn saveToml (self, path : &Path, content : &Config)
    //     throws &FsError
    // {
    //     import std::config::toml;
    //     with dmut f = File::create (path, write-> true) {
    //         f:.write (content.dump ());
    //     }
    // }

    // /**
    //  * Read the configuration file
    //  */
    // pub fn loadToml (self, path : &Path)-> GyllirConfig
    //     throws &FsError, &SyntaxError, &ConfigError
    // {
    //     import std::config::toml;
    //     with dmut f = File::open (path) {
    //         toml::parse (f:.readAll ()).(config::conv::to)!{GyllirConfig} ()
    //     }
    // }

    // /**
    //  * @returns: true if the error was thrown by a sub command that printed the help
    //  */
    // pub fn hasHelpPrinted (self, err : &ArgumentError) -> bool {
    //     match err.subError {
    //         Ok (HelpPrinted ()) => { true }
    //         Ok (sub : &ArgumentError) => { self.hasHelpPrinted (sub) }
    //         _ => false
    //     }
    // }

    // /**
    //  * @returns: true if no option is set
    //  */
    // pub fn noneIsSet (self)-> bool {
    //     !self._args.init.isSet () &&
    //         !self._args.build.isSet () &&
    //         !self._args.clean.isSet () &&
    //         !self._args.publish.isSet () &&
    //         !self._args.test.isSet () &&
    //         !self._args.doc.isSet ()
    // }

    // /**
    //  * @returns: the arguments passed to the command line
    //  */
    // pub fn getArguments (self)-> GyllirArgs {
    //     self._args
    // }

    // /**
    //  * Run a process, and print its stdout / stderr
    //  * @params:
    //  *     - true if succeded, false otherwise
    //  */
    // pub fn runProcess (self, cmd : [c8], params : [[c8]], cwd : &Path = env::currentDir (), printOut : bool = false, printErr : bool = false)-> bool {
    //     with dmut subProc = SubProcess::run (cmd, params, cwd-> cwd, redirectStdout-> !printOut, redirectStderr-> !printErr) {
    //         let code = subProc:.wait ();
    //         code == 0
    //     }
    // }

    
}
