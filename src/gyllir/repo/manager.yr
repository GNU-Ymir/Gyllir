in manager;

use std::{config::_, fs::_};
use gyllir::{config::_, args, args::_, utils::_};
use gyllir::repo::_;
use std::{concurrency::process, syntax::tokenizer};

/**
 * The gyllir manager if the core of gyllir
 */
pub class GyllirManager {

    // The list of arguments passed to the program
    let mut _args : &Config;

    // The list of resolved dependencies
    let dmut _depPackages : [Url => ()] = copy [];

    /**
     * Create a Gyllir builder from an argument 
     */
    pub self (args : [[c8]])
        with _args = (copy GyllirArgumentParser ()).parse (args)
    {}
    
    /**
     * Run the builder
     * @returns: the builder did something
     */
    pub fn run (mut self) {
        if let Ok (c) = self._args ["init"]? {
            RepoInitializer (c).run (self)
        }

        else if let Ok (c) =  self._args ["build"]? {
            RepoBuilder (env::currentDir (), c, self.loadToml (env::currentDir ()), forUnitTest-> false).run (alias self);
        }

        else if let Ok (c) = self._args ["run"]? {
            let cfg = self.loadToml (env::currentDir ());
            RepoBuilder (env::currentDir (), copy Dict (), cfg, forUnitTest-> false).run (alias self);
            RepoRunner (env::currentDir (), c, cfg, forUnitTest-> false).run ();
        }

        else if let Ok (c) = self._args ["clean"]? {
            RepoCleaner (env::currentDir (), c, self.loadToml (env::currentDir ())).run ();
        }

        else if let Ok (c) = self._args ["publish"]? {
            RepoPublisher (env::currentDir (), c, self.loadToml (env::currentDir ())).run (alias self);
        }

        else if let Ok (c) = self._args ["test"]? {
            let cfg = self.loadToml (env::currentDir ());
            RepoBuilder (env::currentDir (), c, cfg, forUnitTest-> true).run (alias self);
            if let Ok (Bool (value-> _ = false)) = c ["dry"]? {
                RepoRunner (env::currentDir (), copy Dict (), cfg, forUnitTest-> true).run ();
            }
        }

        else if let Ok (c) = self._args ["doc"]? {
            if let Ok (Str (value-> file)) = c ["input"]? {
                RepoDocBuilder (env::currentDir (), c, file).run (alias self);
            } else {
                RepoDocBuilder (env::currentDir (), c, self.loadToml (env::currentDir ())).run (alias self);
            }
        }

        else panic;
    } catch {
        err => {
            utils::log::error ("Error", err);
            etc::c::process::_yrt_exit (-1);
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          PRIVATE          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */


    /**
     * Load the configuration file
     * */
    prv fn loadToml (self, path : Path)-> GyllirPackageConfiguration {
        let dmut f = File::open (path.push (defaults::__GYLLIR_CONFIG_FILENAME__));
        let cfg = std::config::toml::parse (f:.readAll ());
        f:.close ();

        GyllirPackageConfiguration (cfg)
    } catch {
        FsError () => {
            utils::log::error ("Error", "failed to read configuration file gyllir.toml");
            etc::c::process::_yrt_exit (-1);
            panic;
        }
        err => {
            utils::log::error ("Error", err);
            etc::c::process::_yrt_exit (-1);
            panic;
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          DEPENDENCIES          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Resolve a dependency, and build it
     * @params:
     *    - args: the configuration of the current building
     *    - name: the name of the dependency to build
     *    - dependency: the information about the dependency to build
     * @returns:
     *    - .0: the list of path to the root files of libraries to include
     *    - .1: the list of path to the built libraries to link
     */
    pub fn resolveDependency (mut self, args : &Config, cwd : Path, name : [c8], dependency : Dependency, dry : bool)-> ([Path], [Path])
        throws RecursiveDependency
    {
        if (dependency.url in self._depPackages) {
            throw copy RecursiveDependency (name ~ ":"s8 ~ dependency.url.path.toStr ())
        }

        let depPath = cwd.push (defaults::__DEPENCY_DIR__).push (name);
        {
            utils::log::info ("Resolving", "dependency ", name, " to ", depPath.toStr ());
            let gM = GitManager (cwd-> depPath);
            if (dependency.url.type == UrlType::LOCAL) {
                if (!isDir (depPath) || fs::sys::fileDate (depPath) < fs::sys::fileDate (dependency.url.path)) {
                    if !isDir (depPath.parent ()) {
                        fs::sys::createDir (depPath.parent (), recursive-> true);
                    }

                    self.runProcess ("ln"s8, copy ["-s"s8, dependency.url.path.toStr (), depPath.toStr ()]);
                }
            }

            else if !isDir (depPath) {
                gM.clone (dependency.url.path.toStr ());
            }

            gM.fetchTags ();
            let version = dependency.version.select (self.toVersionList (GitManager (cwd-> depPath).getTagList ()));
            if (version.isNumbered ()) {
                gM.checkout ("v" ~ version[]);
            } else gM.checkout (version[]);

            if (dependency.url.type == UrlType::GIT) {
                if (version.isNumbered ()) {
                    gM.pull ("v" ~ version[]);
                } else gM.pull (version[]);
            }

            let conf = self.loadToml (depPath);
            if (conf.type.isExecutable ()) {
                utils::log::error ("Resolving", "dependency ", name, " in ", dependency.url, " is not a library.");
                etc::c::process::_yrt_exit (-1);
                panic;
            }

            self._depPackages [dependency.url] = ();
            let (ext, lbs) = RepoBuilder (depPath, args, conf, forUnitTest-> false, dry-> dry).run (alias self);

            self._depPackages:.remove (dependency.url);
            (ext, lbs)
        } catch {
            GitError () => {
                let versions = {
                    self.toVersionList (GitManager (cwd-> depPath).getTagList ())
                } catch { _ => [] };

                utils::log::error ("Resolving", "dependency ", name, " has no version ", dependency.version);
                if (versions.len != 0us) {
                    utils::log::info ("", "Available versions are : ", copy [c[] for c in versions]);
                }

                etc::c::process::_yrt_exit (-1);
                panic;
            }

            r : &RecursiveDependency => {
                throw copy RecursiveDependency (name ~ ":"s8 ~ dependency.url.path.toStr (), subError-> (r)?);
            }
            a : &AssertError => {
                utils::log::error ("Resolving", "dependency ", name, " failure : ", a.msg);
                etc::c::process::_yrt_exit (-1);
                panic;
            }
            x => {
                utils::log::error ("Resolving", "dependency ", name, " failure : ", x);
                etc::c::process::_yrt_exit (-1);
                panic;
            }
        }
    }

    /**
     * Transform a list of tags (acquired with git) into a list of version
     */
    pub fn toVersionList (self, list : [c8])-> [Version] {
        let dmut tzer = Tokenizer!c8 ();
        tzer:.insert ("\n", isSkip-> true);
        let res = tzer.tokenizeWithoutSkips (list);

        let mut versions : [Version] = [];
        for i in res {
            if (i.len > 0 && i [0] != '(') { // ignore (HEAD detached...)
                versions = versions ~ [Version (i)];
            }
        }

        return versions;
    }

    /**
     * Run a sub process
     * */
    pub fn runProcess (self, cmd : [c8], params : [[c8]], cwd : Path = env::currentDir (), verbose : bool = false)-> bool {
        if (verbose) {
            let dmut stream = copy std::stream::StringStream ();
            stream:.write (cmd);
            for o in params {
                stream:.write (" ");
                stream:.write (o);
            }
            utils::log::info ("Run", stream[]);
        }

        let dmut subProc = copy SubProcess (cmd, params, cwd-> cwd);
        subProc:.start (redirect-> false);
        let code = subProc:.wait ();
        code == 0
    } catch {
        _ => false
    }

    /**
     * Ask the user for a given value (command line read)
     * @params:
     *   - ask: the text to write as a question
     *   - default: the default value to return if the user did write nothing
     */
    pub fn askUserFor (self, ask : [c8], default : [c8] = "") -> [c8] {
        let x = if (default == "") {
            std::io::read![c8] (ask-> (ask ~ " :"))
        } else {
            std::io::read![c8] (ask-> (ask ~ " [" ~ default ~ "]:"))
        };

        if x == "" {
            default
        } else x
    }

    /**
     * Ask the user for a yes no question
     * @params:
     *   - ask: the text to write as a question
     *   - default: the default value to return if the user did write nothing
     */
    pub fn askUserYesNo (self, ask : [c8], default : [c8] = "") -> bool {
        let res = self.askUserFor (ask ~ "(y/n)", default-> default);
        if (res.len == 1 && std::char::toUpper (res [0]) == 'Y') return true;

        false
    }

}
