in cleaner;

use std::{io, env, stream, config::_, fs::{path, errors}, concurrency::process};
use gyllir::{repo::_, utils::_, config::_};


pub record RepoCleaner {

    // The current working directory
    let _cwd : Path;

    // The command line options
    let _args : &Config;

    // The package configuration
    let _cfg : GyllirPackageConfiguration;

    /**
     * @params:
     *    - cfg: the configuration of the repo
     * */
    pub self (path : Path, args : &Config, cfg : GyllirPackageConfiguration)
        with _cwd = path
        , _args = args
        , _cfg = cfg
    {}

    /**
     * Clean directory
     * */
    pub fn run (self) {
        if let Ok (Bool (value-> _ = true)) = self._args ["all"]? {
            self.cleanDoc ();
            self.cleanDeps ();
            self.cleanOutputs ();
        }

        else if let Ok (Bool (value-> _ = true)) = self._args ["doc"]? {
            self.cleanDoc ();
        }

        else {
            self.cleanDeps ();
            self.cleanOutputs ();
        }
    }

    /**
     * Clean the documentation files
     * */
    pub fn cleanDoc (self) {
        let docDir = self._cwd.push (defaults::__DOC_DIR__);
        utils::log::info ("Removing", "documentation directory ", docDir.toStr ());
        {
            fs::sys::removeDir (docDir, recursive-> true);
        }?;
    }

    /**
     * Clean the dependency directory
     * */
    pub fn cleanDeps (self) {
        let depDir = self._cwd.push (defaults::__DEPENCY_DIR__);
        utils::log::info ("Removing", "dependency directory ", depDir.toStr ());
        {
            fs::sys::removeDir (depDir, recursive-> true);
        }?;

        let cacheDebug = self._cwd.push (defaults::__CACHE_DEBUG_DIR__);
        utils::log::info ("Removing", "cache directory ", cacheDebug.toStr ());
        {
            fs::sys::removeDir (cacheDebug, recursive-> true);
        }?;

        let cacheRelease = self._cwd.push (defaults::__CACHE_RELEASE_DIR__);
        utils::log::info ("Removing", "cache directory ", cacheRelease.toStr ());
        {
            fs::sys::removeDir (cacheRelease, recursive-> true);
        }?;

        let cacheTest = self._cwd.push (defaults::__CACHE_TEST_DIR__);
        utils::log::info ("Removing", "cache directory ", cacheTest.toStr ());
        {
            fs::sys::removeDir (cacheTest, recursive-> true);
        }?;

        let cacheUnit = self._cwd.push (defaults::__CACHE_UNIT_DIR__);
        utils::log::info ("Removing", "cache directory ", cacheUnit.toStr ());
        {
            fs::sys::removeDir (cacheUnit, recursive-> true);
        }?;
    }


    pub fn cleanOutputs (self) {
        let outFile = if self._cfg.type.isExecutable () {
            self._cwd.push (self._cfg.name)
        } else {
            self._cwd.push ("lib" ~ self._cfg.name ~ ".a")
        };

        utils::log::info ("Removing", "output file ", outFile.toStr ());
        {
            fs::sys::removeFile (outFile);
        }?;

        let testFile = self._cwd.push (self._cfg.name).addExtension ("test");
        utils::log::info ("Removing", "test file ", testFile.toStr ());
        {
            fs::sys::removeFile (testFile);
        }?;
    }

}
