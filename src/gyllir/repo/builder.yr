in builder;


use std::{io, env, stream, config::_};
use gyllir::{repo::_, utils::_, config::_};
use std::{fs::_, syntax::tokenizer, time::_};


/**
 * Build a repository
 */
pub record RepoBuilder {

    // The current working directory
    let _cwd : Path;

    // The command line options
    let _args : &Config;

    // The package configuration
    let _cfg : GyllirPackageConfiguration;

    /**
     * @params:
     *    - cfg: the configuration of the repo
     * */
    pub self (path : Path, args : &Config, cfg : GyllirPackageConfiguration)
        with _cwd = path
        , _args = args
        , _cfg = cfg
    {}

    /**
     * Build the repository
     * */
    pub fn run (self, dmut context : &GyllirManager, forUnitTest : bool = false)-> ([[c8]], [[c8]])
        throws RecursiveDependency
    {
        let verbose = if let Ok (Bool (value-> true)) = self._args ["verbose"]? {
            true
        } else { false };

        let (lp, ll) = self.resolveDependencies (alias context);
        self.runPreCommands (alias context);
        let (all, cacheDir, changed) = self.listChangedFiles (forUnitTest);

        let srcPath = {
            utils::log::info ("Compiling", self._cfg.name, " v", self._cfg.version[]);
            let (relink, options) = self.createCompileOptions (lp, all, changed, cacheDir, forUnitTest);
            if (changed.len != 0) {
                if (!context.runProcess (self._cfg.compiler, options, cwd-> self._cwd, verbose-> verbose)) {
                    utils::log::error ("Error", "failed to compile project '", self._cfg.name, "'");
                    etc::c::process::_yrt_exit (-1);
                    panic;
                }

                if relink {
                    self.relinkObject (alias context, cacheDir, verbose);
                }
            }

            if (forUnitTest) {
                let (unitAll, unitChanged) = self.listUnittestChangedFiles ();
                if (unitChanged.len != 0) {
                    let (relinkUnit, unitOptions) = self.createUnittestOptions (lp, unitAll, unitChanged, options [0]);
                    utils::log::info ("Compiling", "unittest for ", self._cfg.name, " v", self._cfg.version[]);

                    if (!context.runProcess (self._cfg.compiler, unitOptions, cwd-> self._cwd, verbose-> verbose)) {
                        utils::log::error ("Error", "failed to compile unittests '", self._cfg.name, "'");
                        etc::c::process::_yrt_exit (-1);
                        panic;
                    }

                    if (relinkUnit) {
                        self.relinkObject (alias context, self._cwd.push (defaults::__CACHE_TEST_DIR__), verbose);
                    }
                }
            }

            options [0]
        } catch {
            err : &AssertError => {
                utils::log::error ("Error", "failed to compile project ", self._cfg.name, "' : ", err.msg);
                etc::c::process::_yrt_exit (-1);
                panic;
            }
        };

        let finLl = if forUnitTest {
            self.finalizeUnitTest (alias context, cacheDir, ll, verbose);
            ll

        } else if self._cfg.type.isExecutable () {
            self.finalizeExecutable (alias context, cacheDir, ll, verbose);
            ll
        }

        else {
            let res = self.finalizeLibrary (alias context, cacheDir, ll, verbose);
            ll ~ [res.toStr ()]
        };

        self.runPostCommands (alias context);

        return (lp ~ [srcPath], finLl);
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          COMMAND LINE          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Create the command line used to
     * @returns:
     *   - .0: relink, or full link
     *   - .1: the options to pass to the compiler
     * */
    prv fn createCompileOptions (self, depPaths : [[c8]], all : bool, modules : [Path], cacheDir : Path, forUnitTest : bool)-> (bool, [[c8]])
        throws AssertError
    {
        let dmut options : [[c8]] = [];
        let libPath = self._cwd.push (defaults::__SRC_DIR__).push (self._cfg.name).addExtension (defaults::__YMIR_EXTENSION__);
        let mainPath = self._cwd.push (defaults::__SRC_DIR__).push (defaults::__MAIN_FILE__);
        if (fs::sys::isFile (libPath)) {
            options ~= [libPath.toStr ()];
        } else if (fs::sys::isFile (mainPath)) {
            options ~= [mainPath.toStr ()];
        } else throw copy AssertError ("No package root file, " ~ libPath.toStr () ~ " and " ~ mainPath.toStr () ~ " not found");

        if (forUnitTest) {
            options ~= ["-funittest"];
        }

        let objFile = cacheDir.push (self._cfg.name).addExtension (defaults::__LIBRARY_EXTENSION__);
        let relink = if (!sys::isFile (objFile)) || all {
            options ~= ["-fPIC", "-fv", "-c", "-o", objFile.toStr ()];
            false
        } else {
            options ~= ["-fPIC", "-fv", "-c", "-o", (cacheDir.push ("tmp").addExtension (defaults::__OBJECT_EXTENSION__)).toStr ()];
            true
        };

        for p in depPaths {
            options ~= ["-I", p];
        }

        if !all && relink {
            for m in modules {
                options ~= ["-fmodule", m.toStr ()];
            }
        }

        if let Ok (Bool (value-> _ = true)) = self._args ["release"]? {
            options ~= ["-O3"];
        } else {
            options ~= ["-g"];
        }

        options ~= ["-fdump-deps", cacheDir.toStr ()];

        (relink, options)
    }

    /**
     * Create the compiler option to build the unittest
     * @returns:
     *    - .0: true if needs a relink
     *    - .1: the list of command line options
     * */
    prv fn createUnittestOptions (self, depPaths : [[c8]], all : bool, modules : [Path], srcPath : [c8])-> (bool, [[c8]])
        throws AssertError
    {
        let dmut options : [[c8]] = [];
        let libPath = self._cwd.push (defaults::__TEST_DIR__).push (defaults::__FST_TEST_FILE__);
        if (fs::sys::isFile (libPath)) {
            options ~= [libPath.toStr ()];
        } else throw copy AssertError ("No unittest root file, " ~ libPath.toStr () ~ " not found");

        let cacheDir = self._cwd.push (defaults::__CACHE_TEST_DIR__);
        let objFile = cacheDir.push (self._cfg.name).addExtension (defaults::__LIBRARY_EXTENSION__);

        options ~= ["-fPIC", "-fdump-deps", cacheDir.toStr (), "-funittest", "-fv"];

        let relink = if !sys::isFile (objFile) || all {
            options ~= ["-c", "-o", objFile.toStr ()];
            false
        } else {
            options ~= ["-c", "-o", cacheDir.push ("tmp").addExtension (defaults::__OBJECT_EXTENSION__).toStr ()];
            true
        };

        options ~= ["-I", srcPath];
        for p in depPaths {
            options ~= ["-I", p];
        }

        if !all && relink {
            for m in modules {
                options ~= ["-fmodule", m.toStr ()];
            }
        }

        if let Ok (Bool (value-> _ = true)) = self._args ["release"]? {
            options ~= ["-O3"];
        } else {
            options ~= ["-g"];
        }

        (relink, options)
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          RELINK          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Remove all old symbols from old object file, and relink it with the new one
     * @params:
     *    - files: the list of source files that have been recompiled
     *    - cacheDir: the directory containing the result objects
     * */
    fn relinkObject (self, dmut context : &GyllirManager, cacheDir : Path, verbose : bool) {
        let objFile = (cacheDir.push (self._cfg.name).addExtension (defaults::__LIBRARY_EXTENSION__)).toStr ();
        let tmpFile = (cacheDir.push ("tmp").addExtension (defaults::__OBJECT_EXTENSION__)).toStr ();
        let tmp2 = (cacheDir.push ("relink").addExtension (defaults::__OBJECT_EXTENSION__)).toStr ();

        let dmut elf = etc::runtime::elf::createLoader ();
        elf:.update (tmpFile);

        for sym, _ in elf.getSymbols () {
            context.runProcess ("objcopy", copy ["-W", sym, objFile], cwd-> self._cwd, verbose-> false);
        }

        context.runProcess ("objcopy", copy ["-W", "main", objFile], cwd-> self._cwd, verbose-> false);
        if (!context.runProcess ("ld", copy ["-r", objFile, tmpFile, "-o", tmp2], cwd-> self._cwd, verbose-> verbose)) {
            utils::log::error ("Error", "failed to compile project '", self._cfg.name, "'");
            etc::c::process::_yrt_exit (-1);
            panic;
        }

        if (!context.runProcess ("mv", copy [tmp2, objFile], cwd-> self._cwd, verbose-> verbose)) {
            utils::log::error ("Error", "failed to compile project '", self._cfg.name, "'");
            etc::c::process::_yrt_exit (-1);
            panic;
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          FINALIZATION          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Finalize the unittest executable
     * */
    prv fn finalizeUnitTest (self, dmut context : &GyllirManager, cacheDir : Path, dependencyLibs : [[c8]], verbose : bool) {
        let createdTmp = (cacheDir.push (self._cfg.name).addExtension (defaults::__LIBRARY_EXTENSION__)).toStr ();
        let createdUnittests = (self._cwd.push (defaults::__CACHE_TEST_DIR__).push (self._cfg.name).addExtension (defaults::__LIBRARY_EXTENSION__)).toStr ();

        let mut options = copy ["-fv", "-funittest", createdTmp, createdUnittests, "-o", self._cfg.name ~ ".test"];
        options ~= dependencyLibs;

        for k in self._cfg.libraries {
            options ~= ["-l" ~ k];
        }

        options = if let Ok (Bool (value-> _ = true)) = self._args ["release"]? {
            options ~ ["-O3"]
        } else {
            options ~ ["-g"]
        };

        if (!context.runProcess (self._cfg.compiler, options, cwd-> self._cwd, verbose-> verbose)) {
            utils::log::error ("Error", "failed to compile project '", self._cfg.name, "'");
            etc::c::process::_yrt_exit (-1);
        }

        utils::log::info ("Produced", "executable file ", self._cfg.name ~ ".test");
    }

    /**
     * Finalize the executable
     * */
    prv fn finalizeExecutable (self, dmut context : &GyllirManager, cacheDir : Path, dependencyLibs : [[c8]], verbose : bool) {
        let createdTmp = (cacheDir.push (self._cfg.name).addExtension (defaults::__LIBRARY_EXTENSION__)).toStr ();

        let mut options = copy ["-fv", createdTmp, "-o", self._cfg.name];
        options ~= dependencyLibs;

        for k in self._cfg.libraries {
            options ~= ["-l" ~ k];
        }

        options = if let Ok (Bool (value-> _ = true)) = self._args ["release"]? {
            options ~ ["-O3"]
        } else {
            options ~ ["-g"]
        };

        if (!context.runProcess (self._cfg.compiler, options, cwd-> self._cwd, verbose-> verbose)) {
            utils::log::error ("Error", "failed to compile project '", self._cfg.name, "'");
            etc::c::process::_yrt_exit (-1);
        }

        utils::log::info ("Produced", "executable file ", self._cfg.name);
    }

    /**
     * Finalize the library
     * @returns: the result file
     * */
    prv fn finalizeLibrary (self, dmut context : &GyllirManager, cacheDir : Path, _ : [[c8]], verbose : bool)-> Path {
        let createdTmp = (cacheDir.push (self._cfg.name).addExtension (defaults::__LIBRARY_EXTENSION__)).toStr ();
        let resultFile = self._cwd.push ("lib" ~ self._cfg.name).addExtension (defaults::__LIBRARY_EXTENSION__);

        if (!context.runProcess ("cp", copy [createdTmp, resultFile.toStr ()], cwd-> self._cwd, verbose-> verbose)) {
            utils::log::error ("Error", "failed to compile project '", self._cfg.name, "'");
            etc::c::process::_yrt_exit (-1);
        }

        utils::log::info ("Produced", "library file ", resultFile);
        resultFile
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===============================          FILE MODIFICATIONS          ===============================
     * ====================================================================================================
     * ====================================================================================================
     */

    prv fn listUnittestChangedFiles (self)-> (bool, [Path]) {
        let sources = self.listFilesInDir (self._cwd.push (defaults::__TEST_DIR__));
        let cacheDir = self._cwd.push (defaults::__CACHE_TEST_DIR__);

        let mut results : [Path] = [];
        let mut deps : [Path => mut [Path]] = copy [];
        for src in sources {
            let p = src.removePrefix (self._cwd.push (defaults::__TEST_DIR__));
            if let Ok (Instant (sec-> d)) = sys::fileDate (src)? {
                let (exits, srcDeps) = self.readCacheDependencies (cacheDir, p, d);
                if (exits) {
                    deps [p] = srcDeps;
                } else { results ~= [p]; }
            } else { results ~= [p]; }
        }

        for p, srcDeps in deps {
            let mut found = true;
            for z in srcDeps {
                if z !in deps {
                    found = false;
                    break;
                }
            }

            if !found {
                results ~= [p];
            }
        }

        let all = (results.len == sources.len);
        (all, results)
    }

    /**
     * List the source files to compile
     * @returns:
     *   - .0: true iif all found source files have to be recompiled
     *   - .1: the list of source file to compile (relative path from source dir)
     * */
    prv fn listChangedFiles (self, forUnitTest : bool)-> (bool, Path, [Path]) {
        let cacheDir = if let Ok (Bool (value-> _ = true)) = self._args ["release"]? {
            self._cwd.push (defaults::__CACHE_RELEASE_DIR__)
        } else if forUnitTest {
            self._cwd.push (defaults::__CACHE_UNIT_DIR__)
        } else {
            self._cwd.push (defaults::__CACHE_DEBUG_DIR__)
        };

        let sources = self.listFilesInDir (self._cwd.push (defaults::__SRC_DIR__));

        let mut results : [Path] = [];
        let mut deps : [Path => mut [Path]] = copy [];
        for src in sources {
            let p = src.removePrefix (self._cwd.push (defaults::__SRC_DIR__));
            if let Ok (Instant (sec-> d)) = sys::fileDate (src)? {
                let (exits, srcDeps) = self.readCacheDependencies (cacheDir, p, d);
                if (exits) {
                    deps [p] = srcDeps;
                } else { results ~= [p]; }
            } else { results ~= [p]; }
        }

        for p, srcDeps in deps {
            let mut found = true;
            for z in srcDeps {
                if z !in deps {
                    found = false;
                    break;
                }
            }

            if !found {
                results ~= [p];
            }
        }

        let all = (results.len == sources.len);
        (all, cacheDir, results)
    }

    /**
     * Read a module dependency
     * @params:
     *    - source: the path of the source file
     *    - date: the date of the source file
     * @returns:
     *    - .0: true iif the source file is older than the dep file
     *    - .1: the list of dependencies read in the dep file
     * */
    prv fn readCacheDependencies (self, cacheDir : Path, source : Path, date : u64)-> (bool, [Path]) {
        let depFile = cacheDir.push (source.stripExtension ().toStr (sep-> "_")).addExtension (defaults::__DEPS_EXTENSION__);
        if let Ok (Instant (sec-> d)) = sys::fileDate (depFile)? {
            if d < date {
                return (false, []);
            }

            {
                let dmut results : [Path] = [];
                let dmut f = File::open (depFile, read-> true);
                while let line = f:.readUntil ("\n") && line.len > 0 {
                    if line [$ - 1] == '\n' {
                        results ~= [Path (line [0 .. $ - 1])];
                    } else {
                        results ~= [Path (line)];
                    }
                }

                return (true, results);
            } catch {
                _ => {}
            }
        }

        // No dependency file found
        return (false, []);
    }


    /**
     * List the source files that can be found in the directory 'root'
     * */
    prv fn listFilesInDir (self, root : Path)-> [Path] {
        let dmut result : [Path] = [];
        {
            for entry in sys::readDir (root) {
                match entry {
                    FsEntry (path-> p, kind-> FsEntryKind::DIR) => {
                        result ~= self.listFilesInDir (p);
                    }
                    FsEntry (path-> p, kind-> FsEntryKind::FILE) if (p.extension () == defaults::__YMIR_EXTENSION__) => {
                        result ~= [p];
                    }
                }
            }
        } catch {
            _ => {}
        }

        result
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ================================          CUSTOM COMMANDS          =================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Execute the commands to run before the compilation
     * */
    prv fn runPreCommands (self, dmut context : &GyllirManager) {
        let dmut tzer = Tokenizer!c8 ();
        tzer:.insert (" ", isSkip-> true);
        for _, c in self._cfg.commands [] {
            if !c.isPost () {
                let cmd = tzer.tokenizeWithoutSkips (c.cmd);
                let succ = if (cmd.len > 0) {
                    context.runProcess (cmd [0], cmd [1 .. $], cwd-> self._cwd)
                } else { false };

                if !succ {
                    utils::log::error ("Error", "failed to compile project '", self._cfg.name, "'");
                    etc::c::process::_yrt_exit (-1);
                }
            }
        }
    }

    /**
     * Execute the commands to run after the compilation
     * */
    prv fn runPostCommands (self, dmut context : &GyllirManager) {
        let dmut tzer = Tokenizer!c8 ();
        tzer:.insert (" ", isSkip-> true);
        for _, c in self._cfg.commands [] {
            if c.isPost () {
                let cmd = tzer.tokenizeWithoutSkips (c.cmd);
                let succ = if (cmd.len > 0) {
                    context.runProcess (cmd [0], cmd [1 .. $], cwd-> self._cwd)
                } else { false };

                if !succ {
                    utils::log::error ("Error", "failed to compile project '", self._cfg.name, "'");
                    etc::c::process::_yrt_exit (-1);
                }
            }
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          DEPENDENCIES          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Resolve the dependencies of the package and build them
     * */
    prv fn resolveDependencies (self, dmut context : &GyllirManager)-> ([[c8]], [[c8]])
        throws RecursiveDependency
    {
        let dmut libs : [[c8]] = [];
        let dmut names : [[c8]] = [];
        for k, d in self._cfg.dependencies[] {
            let (n, l) = context:.resolveDependency (self._args, self._cwd, k, d);
            libs ~= l;
            names ~= n;
        }

        (names, libs)
    }

}
