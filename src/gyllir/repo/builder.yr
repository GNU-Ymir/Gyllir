in builder;


use std::{io, env, stream, config::_};
use gyllir::{repo::_, utils::_, config::_};
use std::{fs::_, syntax::tokenizer};


/**
 * Build a repository
 */
pub record RepoBuilder {

    // The current working directory
    let _cwd : Path;

    // The command line options
    let _args : &Config;

    // The package configuration
    let _cfg : GyllirPackageConfiguration;

    /**
     * @params:
     *    - cfg: the configuration of the repo
     * */
    pub self (path : Path, args : &Config, cfg : GyllirPackageConfiguration)
        with _cwd = path
        , _args = args
        , _cfg = cfg
    {}

    /**
     * Build the repository
     * */
    pub fn run (self, dmut context : &GyllirManager)-> ([[c8]], [[c8]])
        throws RecursiveDependency
    {
        let verbose = if let Ok (Bool (value-> true)) = self._args ["verbose"]? {
            true
        } else { false };

        let (lp, ll) = self.resolveDependencies (alias context);
        self.runPreCommands (alias context);
        let srcPath = {
            let options = self.createCompileOptions (lp);
            utils::log::info ("Compiling", self._cfg.name, " v", self._cfg.version[]);

            if (!context.runProcess (self._cfg.compiler, options, cwd-> self._cwd, verbose-> verbose)) {
                utils::log::error ("Error", "failed to compile project '", self._cfg.name, "'");
                etc::c::process::_yrt_exit (-1);
                panic;
            }

            options [0]
        } catch {
            err : &AssertError => {
                utils::log::error ("Error", "failed to compile project ", self._cfg.name, "' : ", err.msg);
                etc::c::process::_yrt_exit (-1);
                panic;
            }
        };

        let finLl = if self._cfg.type.isExecutable () {
            self.finalizeExecutable (alias context, ll, verbose);
            ll
        }

        else {
            self.finalizeLibrary (alias context, ll, verbose);
            ll ~ [self._cwd.push ("lib" ~ self._cfg.name ~ ".a").toStr ()]
        };

        self.runPostCommands (alias context);

        return (lp ~ [srcPath], finLl);
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          COMMAND LINE          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Create the command line used to
     * @returns: the options to pass to the compiler
     * */
    prv fn createCompileOptions (self, depPaths : [[c8]])-> [[c8]]
        throws AssertError
    {
        let dmut options : [[c8]] = [];
        let libPath = self._cwd.push (defaults::__SRC_DIR__).push (self._cfg.name).addExtension (defaults::__YMIR_EXTENSION__);
        let mainPath = self._cwd.push (defaults::__SRC_DIR__).push (defaults::__MAIN_FILE__);
        if (fs::sys::isFile (libPath)) {
            options ~= [libPath.toStr ()];
        } else if (fs::sys::isFile (mainPath)) {
            options ~= [mainPath.toStr ()];
        } else throw copy AssertError ("No package root file, " ~ libPath.toStr () ~ " and " ~ mainPath.toStr () ~ " not found");

        options ~= ["-fv", "-c", "-o", ".__tmp_" ~ self._cfg.name ~ ".a"];
        for p in depPaths {
            options ~= ["-I", p];
        }

        options
    }

    /**
     * Finalize the executable
     * */
    prv fn finalizeExecutable (self, dmut context : &GyllirManager, dependencyLibs : [[c8]], verbose : bool) {
        let createdTmp = ".__tmp_" ~ self._cfg.name ~ ".a";
        let mut options = copy ["-fv", createdTmp, "-o", self._cfg.name];
        options ~= dependencyLibs;

        for k in self._cfg.libraries {
            options ~= ["-l" ~ k];
        }

        if (!context.runProcess (self._cfg.compiler, options, cwd-> self._cwd, verbose-> verbose)) {
            utils::log::error ("Error", "failed to compile project '", self._cfg.name, "'");
            etc::c::process::_yrt_exit (-1);
        }

        if (!context.runProcess ("rm", copy [createdTmp], cwd-> self._cwd, verbose-> verbose)) {
            utils::log::error ("Error", "failed to compile project '", self._cfg.name, "'");
            etc::c::process::_yrt_exit (-1);
        }
    }

    /**
     * Finalize the library
     * */
    prv fn finalizeLibrary (self, dmut context : &GyllirManager, _ : [[c8]], verbose : bool) {
        let createdTmp = ".__tmp_" ~ self._cfg.name ~ ".a";
        if (!context.runProcess ("mv", copy [createdTmp, "lib" ~ self._cfg.name ~ ".a"], cwd-> self._cwd, verbose-> verbose)) {
            utils::log::error ("Error", "failed to compile project '", self._cfg.name, "'");
            etc::c::process::_yrt_exit (-1);
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ================================          CUSTOM COMMANDS          =================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Execute the commands to run before the compilation
     * */
    prv fn runPreCommands (self, dmut context : &GyllirManager) {
        let dmut tzer = Tokenizer!c8 ();
        tzer:.insert (" ", isSkip-> true);
        for _, c in self._cfg.commands [] {
            if !c.isPost () {
                let cmd = tzer.tokenizeWithoutSkips (c.cmd);
                let succ = if (cmd.len > 0) {
                    context.runProcess (cmd [0], cmd [1 .. $], cwd-> self._cwd)
                } else { false };

                if !succ {
                    utils::log::error ("Error", "failed to compile project '", self._cfg.name, "'");
                    etc::c::process::_yrt_exit (-1);
                }
            }
        }
    }

    /**
     * Execute the commands to run after the compilation
     * */
    prv fn runPostCommands (self, dmut context : &GyllirManager) {
        let dmut tzer = Tokenizer!c8 ();
        tzer:.insert (" ", isSkip-> true);
        for _, c in self._cfg.commands [] {
            if c.isPost () {
                let cmd = tzer.tokenizeWithoutSkips (c.cmd);
                let succ = if (cmd.len > 0) {
                    context.runProcess (cmd [0], cmd [1 .. $], cwd-> self._cwd)
                } else { false };

                if !succ {
                    utils::log::error ("Error", "failed to compile project '", self._cfg.name, "'");
                    etc::c::process::_yrt_exit (-1);
                }
            }
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          DEPENDENCIES          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Resolve the dependencies of the package and build them
     * */
    prv fn resolveDependencies (self, dmut context : &GyllirManager)-> ([[c8]], [[c8]])
        throws RecursiveDependency
    {
        let dmut libs : [[c8]] = [];
        let dmut names : [[c8]] = [];
        for k, d in self._cfg.dependencies[] {
            let (n, l) = context:.resolveDependency (self._args, self._cwd, k, d);
            libs ~= l;
            names ~= n;
        }

        (names, libs)
    } 

}
