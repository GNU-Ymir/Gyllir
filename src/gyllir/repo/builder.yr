in builder;


use std::{io, env, stream, config::_};
use gyllir::{repo::_, utils::_, config::_};
use std::{fs::_, syntax::tokenizer, time::_};


/**
 * Build a repository
 */
pub record RepoBuilder {

    // The current working directory
    let _cwd : Path;

    // The command line options
    let _args : &Config;

    // The package configuration
    let _cfg : GyllirPackageConfiguration;

    // True if the builder has to print verbose messages
    let _verbose : bool;

    // True if the repobuilder is used to build unittest executable
    let _forUnitTest : bool;

    // True iif the repobuilder is used to build the documentation file
    let _forDoc : bool;

    // True if does not really compile
    let _dry : bool;

    // The number of threads to spawn in the task pool
    let _nbThreads : u32;

    /**
     * @params:
     *    - cfg: the configuration of the repo
     * */
    pub self (path : Path, args : &Config, cfg : GyllirPackageConfiguration, forUnitTest : bool, forDoc : bool = false, dry : bool = false)
        with _cwd = path
        , _args = args
        , _cfg = cfg
        , _forUnitTest = forUnitTest
        , _forDoc = forDoc
        , _dry = dry
        , _verbose = (if let Ok (Bool (value-> true)) = self._args ["verbose"]? {
            true
        } else { false })
        , _nbThreads = if let Ok (Int (value-> n)) = self._args ["j"]? {
            cast!u32 (n)
        } else { etc::runtime::threads::_yrt_get_nprocs () }
    {}

    /**
     * Build the repository
     * @params:
     *    - context: the context of the compilation
     * @returns:
     *    - .0: the list of path to the root files of libraries to include for further dependency building
     *    - .1: the list of path to the built libraries to link for further dependency building
     * */
    pub fn run (self, dmut context : &GyllirManager)-> ([Path], [Path])
        throws RecursiveDependency
    {
        let (includes, links) = self.resolveDependencies (alias context);
        self.runPreCommands (alias context);
        let (srcPath, cacheDir) = {
            if (self._forDoc) {
                self.buildSourceDoc (alias context, includes)
            } else {
                let (srcPath, cacheDir, changedSources) = self.buildSourceDir (alias context, includes);
                if (self._forUnitTest && !self._dry) {
                    self.buildUnitTest (alias context, srcPath, includes, changedSources);
                }

                (srcPath, cacheDir)
            }
        } catch {
            err : &AssertError => {
                utils::log::error ("Error", "failed to compile project ", self._cfg.name, "' : ", err.msg);
                etc::c::process::_yrt_exit (-1);
                panic;
            }
        };

        let finalLinks = self.finalizeBuild (alias context, cacheDir, links);
        self.runPostCommands (alias context);

        return (includes ~ [srcPath], finalLinks);
    }


    /**
     * Build the source files
     * @params:
     *    - context: the context of the compilation
     *    - depRoots: the list of dependency root source files
     * @returns:
     *    - .0: the directory containing the result of the compilation
     *    - .1: the path to the root file
     *    - .2: the list of source files that have changed since last compilation
     * */
    prv fn buildSourceDir (self, dmut context : &GyllirManager, includes : [Path])-> (Path, Path, [Path])
        throws AssertError
    {
        let srcPath = self.findRootSourceFile ();
        let (cacheDir, sources, changed) = self.listChangedFiles ();

        if (self._dry) { return (srcPath, cacheDir, changed); }

        self.createCacheDirs (cacheDir);

        utils::log::info ("Compiling", self._cfg.name, " v", self._cfg.version[]);

        let objFile = cacheDir.push (self._cfg.name).addExtension (defaults::__LIBRARY_EXTENSION__);

        // if something has to be compiled
        if (changed.len != 0 || !sys::isFile (objFile)) {

            // Create the compile options according to the current configuration
            let options = self.createCompileOptions (srcPath, includes);

            let dmut pool = copy std::concurrency::task::TaskPool (nbThreads-> self._nbThreads);
            let dmut success = copy [0us], mut modFiles : [mut [Path]] = copy [[]];
            let parallel_changed = self.cutModuleList (changed, self._nbThreads);
            let mut submitted = 0u32;

            for i, m in parallel_changed if m.len > 0 {
                let msg = {
                    std::format::format ("{} modules in thread {} (among {} changed files of {}) ", m.len, i + 1, changed.len, sources.len)
                } catch { _ => { "\t" } };
                utils::log::info ("Compiling", msg);

                submitted += 1;
                pool:.submit (copy || => {
                    let modFile = cacheDir.push (Path ("obj_" ~ std::conv::to!{[c8]} (i))).addExtension (defaults::__OBJECT_EXTENSION__);
                    let mut modOption = options ~ ["-o", modFile.toStr ()];
                    for m_ in m {
                        modOption ~= ["-fmodule", m_.toStr ()];
                    }

                    // Execute the compile command
                    if (!context.runProcess (self._cfg.compiler, modOption, cwd-> self._cwd, verbose-> self._verbose)) {
                        pool:.clear ();
                    } else atomic {
                        modFiles [0] ~= [modFile];
                        success [0] += 1;
                    }
                });
            }

            pool:.join ();

            if (success [0] != submitted) {
                utils::log::error ("Error", "failed to compile project '", self._cfg.name, "'");
                etc::c::process::_yrt_exit (-1);
                panic;
            }

            // Create the final object file before finalization using the temporary object files created by the command
            self.relinkObject (alias context, cacheDir, modFiles [0], all-> changed.len == sources.len);
            self.exportDepsFiles (cacheDir);
        }

        (srcPath, cacheDir, changed)
    }


    /**
     * Build the unit test source files
     * @params:
     *    - context: the context of the compilation
     *    - srcPath: the root file of the sources (in src directory)
     * */
    prv fn buildUnitTest (self, dmut context : &GyllirManager, srcPath : Path, includes : [Path], changedSources : [Path])
        throws AssertError
    {
        let (unitSources, unitChanged) = self.listUnittestChangedFiles (changedSources);

        // create the output directory if not exist
        let cacheDir = self._cwd.push (defaults::__CACHE_TEST_DIR__);
        self.createCacheDirs (cacheDir);

        let objFile = cacheDir.push (self._cfg.name).addExtension (defaults::__LIBRARY_EXTENSION__);

        // If something has to be compiled
        if (unitChanged.len != 0 || !sys::isFile (objFile)) {
            let srcTest = self.findRootTestFile ();

            // Create the compile options according to the current configuration
            let options = self.createCompileOptions (srcTest, includes ~ [srcPath]);
            utils::log::info ("Compiling", "unittest for ", self._cfg.name, " v", self._cfg.version[]);
            let dmut pool = copy std::concurrency::task::TaskPool (nbThreads-> self._nbThreads);
            let dmut success = copy [0us], mut modFiles : [mut [Path]] = copy [[]];
            let parallel_changed = self.cutModuleList (unitChanged, self._nbThreads);
            let mut submitted = 0u32;

            for i, m in parallel_changed if m.len > 0 {
                let msg = {
                    std::format::format ("{} modules in thread {} (among {} changed files of {}) ", m.len, i + 1, unitChanged.len, unitSources.len)
                } catch { _ => { "\t" } };
                utils::log::info ("Compiling", msg);
                submitted += 1;

                pool:.submit (copy || => {
                    let modFile = cacheDir.push (Path ("obj_" ~ std::conv::to!{[c8]} (i))).addExtension (defaults::__OBJECT_EXTENSION__);
                    let mut modOption = options ~ ["-o", modFile.toStr ()];
                    for m_ in m {
                        modOption ~= ["-fmodule", m_.toStr ()];
                    }

                    // Execute the compile command
                    if (!context.runProcess (self._cfg.compiler, modOption, cwd-> self._cwd, verbose-> self._verbose)) {
                        pool:.clear ();
                    } else atomic {
                        modFiles [0] ~= [modFile];
                        success [0] += 1;
                    }
                });
            }

            pool:.join ();

            if (success [0] != submitted) {
                utils::log::error ("Error", "failed to compile unittests '", self._cfg.name, "'");
                etc::c::process::_yrt_exit (-1);
                panic;
            }

            self.relinkObject (alias context, cacheDir, modFiles [0], all-> unitChanged.len == unitSources.len);
            self.exportDepsFiles (cacheDir);
        }
    }

    /**
     * Build the documentation file from sources
     * */
    prv fn buildSourceDoc (self, dmut context : &GyllirManager, includes : [Path])-> (Path, Path)
        throws AssertError
    {
        let srcPath = self.findRootTestFile ();
        let cacheDir = self._cwd.push (defaults::__CACHE_DOC_DIR__);
        self.createCacheDirs (cacheDir);

        let options = self.createDocCompileOptions (srcPath, includes);
        utils::log::info ("Compiling", "documentation for ", self._cfg.name, " v", self._cfg.version[]);
        if !context.runProcess (self._cfg.compiler, options, cwd-> self._cwd, verbose-> self._verbose) {
            utils::log::error ("Error", "failed to compile documentation '", self._cfg.name, "'");
            etc::c::process::_yrt_exit (-1);
            panic;
        }

        (srcPath, cacheDir)
    }

    /**
     * Finalize the building of the package
     * @params:
     *    - context: the context of the compilation
     *    - cacheDir: the directory in which the building is done
     *    - libs: the list of libraries to link
     * @returns: the list of libraries to link for further dependencies
     * */
    prv fn finalizeBuild (self, dmut context : &GyllirManager, cacheDir : Path, links : [Path])-> [Path] {
        if self._forUnitTest {
            self.finalizeUnitTest (alias context, cacheDir, links);
            links
        }

        else if self._cfg.type.isExecutable () {
            self.finalizeExecutable (alias context, cacheDir, links);
            links
        }

        else {
            let res = self.finalizeLibrary (alias context, cacheDir, links);
            links ~ [res]
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          COMMAND LINE          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Create the command line used to
     * @returns:
     *   - .0: relink, or full link
     *   - .1: the options to pass to the compiler
     * */
    prv fn createCompileOptions (self, srcPath : Path, depPaths : [Path])-> [[c8]] {
        let mut options : [[c8]] = copy [srcPath.toStr (), "-fPIC", "-c", "-fdump-deps", self._cwd.push (defaults::__CACHE_TMP_DIR__).toStr ()];
        if (self._forUnitTest) {
            options ~= ["-funittest"];
        }

        if (self._verbose) {
            options ~= ["-fv"];
        }

        for p in depPaths {
            options ~= ["-I", p.toStr ()];
        }

        if let Ok (Bool (value-> _ = true)) = self._args ["release"]? {
            options ~= ["-O3"];
        } else {
            options ~= ["-g"];
        }

        options
    }

    /**
     * Build the compile command line option to build documentation file
     * */
    prv fn createDocCompileOptions (self, srcPath : Path, depPaths : [Path])-> [[c8]] {
        let mut options : [[c8]] = copy [srcPath.toStr (), "-c", "-fdoc", self._cwd.push (defaults::__CACHE_DOC_DIR__).push (self._cfg.name).addExtension (defaults::__DOC_EXTENSION__).toStr ()];
        if (self._verbose) {
            options ~= ["-fv"];
        }

        for p in depPaths {
            options ~= ["-I", p.toStr ()];
        }

        options
    }

    /**
     * Cut the module list to be compiled by multiple threads
     * */
    fn cutModuleList (self, modules : [Path], nbThreads : u32)-> [[Path]] {
        let mut result : [mut [Path]] = copy [[] for _ in 0 .. nbThreads];
        if modules.len == 0 {
            return result;
        }

        let nbPerTh = modules.len / cast!usize (nbThreads);
        let rest = modules.len % cast!usize (nbThreads);

        if nbPerTh > 0 {
            for i in 0us .. cast!usize (nbThreads) {
                result [i] = modules [i * nbPerTh .. (i + 1) * nbPerTh];
            }
        }

        if rest != 0 {
            let end = modules.len - rest;
            for i in 0 .. rest {
                result [i] ~= [modules [end + i]];
            }
        }

        result
    }

    /**
     * Remove all old symbols from old object file, and relink it with the new one
     * @params:
     *    - files: the list of source files that have been recompiled
     *    - cacheDir: the directory containing the result objects
     * */
    fn relinkObject (self, dmut context : &GyllirManager, cacheDir : Path, objectFiles : [Path], all : bool) {
        let output = cacheDir.push (self._cfg.name).addExtension (defaults::__LIBRARY_EXTENSION__);
        let intermediate = cacheDir.push ("relink").addExtension (defaults::__OBJECT_EXTENSION__);
        fs::sys::removeFile (intermediate)?;

        if (!context.runProcess ("ld", copy ["-r", "-o", intermediate.toStr ()] ~ copy [o.toStr () for o in objectFiles], cwd-> self._cwd, verbose-> self._verbose)) {
            utils::log::error ("Error", "failed to link object files'", self._cfg.name, "'");
            etc::c::process::_yrt_exit (-1);
            panic;
        }

        if !all && fs::sys::isFile (output) {
            self.removeOldSymbols (alias context, output, intermediate);
            let tmp = cacheDir.push ("tmp").addExtension (defaults::__OBJECT_EXTENSION__);
            if (!context.runProcess ("ld", copy ["-r", "-o", tmp.toStr (), output.toStr (), intermediate.toStr ()], cwd-> self._cwd, verbose-> self._verbose)) {
                utils::log::error ("Error", "failed to link object files'", self._cfg.name, "'");
                etc::c::process::_yrt_exit (-1);
                panic;
            }

            if (!context.runProcess ("mv", copy [tmp.toStr (), output.toStr ()], cwd-> self._cwd, verbose-> self._verbose)) {
                utils::log::error ("Error", "failed to link object files'", self._cfg.name, "'");
                etc::c::process::_yrt_exit (-1);
                panic;
            }
        } else {
            if (!context.runProcess ("mv", copy [intermediate.toStr (), output.toStr ()], cwd-> self._cwd, verbose-> self._verbose)) {
                utils::log::error ("Error", "failed to link object files'", self._cfg.name, "'");
                etc::c::process::_yrt_exit (-1);
                panic;
            }
        }

        for o in objectFiles {
            fs::sys::removeFile (o)?;
        }
    }

    /**
     * Remove the symbols that were rebuilt in the new object files
     * */
    fn removeOldSymbols (self, dmut context : &GyllirManager, output : Path, objFile : Path) {
        let old = output.toStr ();
        let new = objFile.toStr ();
        let dmut elfLoader = etc::runtime::elf::createLoader ();
        elfLoader:.update (new);

        let mut weakens : [[c8]] = [], mut globalize : [[c8]] = [];
        for sym in elfLoader.getSymbols () {
            weakens ~= ["--weaken-symbol=" ~ sym];
            globalize ~= ["--globalize-symbol=" ~ sym];
        }

        context.runProcess ("objcopy", weakens ~ [old], cwd-> self._cwd, verbose-> self._verbose);
        context.runProcess ("objcopy", globalize ~ [new], cwd-> self._cwd, verbose-> self._verbose);
    }

    /**
     * Save the created dependency files
     * */
    fn exportDepsFiles (self, cacheDir : Path) {
        let src = self._cwd.push (defaults::__CACHE_TMP_DIR__);
        for i in fs::sys::readDir (src) match i {
            FsEntry (kind-> FsEntryKind::FILE, path-> p) if (p.extension () == defaults::__DEPS_EXTENSION__) => {
                fs::sys::copyFile (p, cacheDir.push (p.removePrefix (src)))?;
            }
        }

        fs::sys::removeDir (src, recursive-> true)?;
    } catch {
        _ => {
            utils::log::error ("Error", "failed to create output directory '", cacheDir.toStr (), "'");
            etc::c::process::_yrt_exit (-1);
            panic;
        }
    }

    /**
     * Create the directory in which cache will be stored
     * */
    fn createCacheDirs (self, cacheDir : Path) {
        if (!sys::isDir (self._cwd.push (defaults::__CACHE_TMP_DIR__))) {
            sys::createDir (self._cwd.push (defaults::__CACHE_TMP_DIR__), recursive-> true);
        }
        // Create the output directory
        if (!sys::isDir (cacheDir)) {
            sys::createDir (cacheDir, recursive-> true);
        }
    } catch {
        _ => {
            utils::log::error ("Error", "failed to create output directory '", cacheDir.toStr (), "'");
            etc::c::process::_yrt_exit (-1);
            panic;
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          FINALIZATION          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Finalize the unittest executable
     * */
    prv fn finalizeUnitTest (self, dmut context : &GyllirManager, cacheDir : Path, dependencyLibs : [Path]) {
        let createdTmp = (cacheDir.push (self._cfg.name).addExtension (defaults::__LIBRARY_EXTENSION__)).toStr ();
        let createdUnittests = (self._cwd.push (defaults::__CACHE_TEST_DIR__).push (self._cfg.name).addExtension (defaults::__LIBRARY_EXTENSION__)).toStr ();

        let mut options = copy ["-fv", "-funittest", createdTmp, createdUnittests, "-o", self._cfg.name ~ ".test"];
        options ~= copy [d.toStr () for d in dependencyLibs];

        for k in self._cfg.libraries {
            options ~= ["-l" ~ k];
        }

        options = if let Ok (Bool (value-> _ = true)) = self._args ["release"]? {
            options ~ ["-O3"]
        } else {
            options ~ ["-g"]
        };

        if (!context.runProcess (self._cfg.compiler, options, cwd-> self._cwd, verbose-> self._verbose)) {
            utils::log::error ("Error", "failed to compile project '", self._cfg.name, "'");
            etc::c::process::_yrt_exit (-1);
        }

        utils::log::info ("Produced", "executable file ", self._cfg.name, ".test");
    }

    /**
     * Finalize the executable
     * */
    prv fn finalizeExecutable (self, dmut context : &GyllirManager, cacheDir : Path, dependencyLibs : [Path]) {
        let createdTmp = (cacheDir.push (self._cfg.name).addExtension (defaults::__LIBRARY_EXTENSION__)).toStr ();

        let mut options = copy ["-fv", createdTmp, "-o", self._cfg.name];
        options ~= copy [d.toStr () for d in dependencyLibs];

        for k in self._cfg.libraries {
            options ~= ["-l" ~ k];
        }

        options = if let Ok (Bool (value-> _ = true)) = self._args ["release"]? {
            options ~ ["-O3"]
        } else {
            options ~ ["-g"]
        };

        if (!context.runProcess (self._cfg.compiler, options, cwd-> self._cwd, verbose-> self._verbose)) {
            utils::log::error ("Error", "failed to compile project '", self._cfg.name, "'");
            etc::c::process::_yrt_exit (-1);
        }

        utils::log::info ("Produced", "executable file ", self._cfg.name);
    }

    /**
     * Finalize the library
     * @returns: the result file
     * */
    prv fn finalizeLibrary (self, dmut context : &GyllirManager, cacheDir : Path, _ : [Path])-> Path {
        let createdTmp = (cacheDir.push (self._cfg.name).addExtension (defaults::__LIBRARY_EXTENSION__)).toStr ();
        let resultFile = self._cwd.push ("lib" ~ self._cfg.name).addExtension (defaults::__LIBRARY_EXTENSION__);

        if (!context.runProcess ("cp", copy [createdTmp, resultFile.toStr ()], cwd-> self._cwd, verbose-> self._verbose)) {
            utils::log::error ("Error", "failed to compile project '", self._cfg.name, "'");
            etc::c::process::_yrt_exit (-1);
        }

        utils::log::info ("Produced", "library file ", "lib", self._cfg.name, ".", defaults::__LIBRARY_EXTENSION__);
        resultFile
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===============================          FILE MODIFICATIONS          ===============================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * List the unittest source files that have been changed since the last built
     * @returns:
     *    - .0: true iif all source files have changed (or are new)
     *    - .1: the list of path to modules files that have to be recompiled
     * */
    prv fn listUnittestChangedFiles (self, changedSources : [Path])-> ([Path], [Path]) {
        let rootDir = self._cwd.push (defaults::__TEST_DIR__);
        let cacheDir = self._cwd.push (defaults::__CACHE_TEST_DIR__);
        let sources = self.listFilesInDir (rootDir, rootDir);
        let results = self.lookupDependencies (rootDir, cacheDir, sources, true, changedSources);

        (sources, results)
    }

    /**
     * List the source files that have been changed since the last built
     * @returns:
     *   - .0: true iif all found source files have to be recompiled
     *   - .1: the output directory
     *   - .2: the list of source file to compile (relative path from source dir)
     * */
    prv fn listChangedFiles (self)-> (Path, [Path], [Path]) {
        let cacheDir = self.defineOutputDirectory ();
        let rootDir = self._cwd.push (defaults::__SRC_DIR__);
        let sources = self.listFilesInDir (rootDir, rootDir);
        let results = self.lookupDependencies (rootDir, cacheDir, sources, false, []);

        (cacheDir, sources, results)
    }

    /**
     * Check for changed files in the list of sources, and check for changed file dependencies
     * @params:
     *    - prefix: the directory containing the source files
     *    - cacheDir: the output directory containing the dependency files
     *    - sources: the list of source files
     * @returns: the list of files that have changed since last compilation
     * */
    prv fn lookupDependencies (self, prefix : Path, cacheDir : Path, sources : [Path], forUnitTest : bool, changedSources : [Path])-> [Path] {
        let mut results : [Path] = [];
        let mut deps : [Path => mut [Path]] = copy [];
        for src in sources {
            if let Ok (Instant (sec-> d)) = sys::fileDate (prefix.push (src))? {
                let (exits, srcDeps) = self.readCacheDependencies (prefix, cacheDir, src, d, forUnitTest, changedSources);
                if (exits) {
                    deps [src] = srcDeps;
                } else { results ~= [src]; }
            } else { results ~= [src]; }
        }

        for p, srcDeps in deps {
            let mut found = true;
            for z in srcDeps {
                if z !in deps {
                    found = false;
                    break;
                }
            }

            if !found {
                results ~= [p];
            }
        }

        results
    }

    /**
     * Read a module dependency
     * @params:
     *    - source: the path of the source file
     *    - date: the date of the source file
     * @returns:
     *    - .0: true iif the source file is older than the dep file
     *    - .1: the list of dependencies read in the dep file
     * */
    prv fn readCacheDependencies (self, sourceDir : Path, cacheDir : Path, source : Path, date : u64, forUnitTest : bool, changedSources : [Path])-> (bool, [Path]) {
        let depFile = cacheDir.push (source.stripExtension ().toStr (sep-> "_")).addExtension (defaults::__DEPS_EXTENSION__);
        let objFile = cacheDir.push (source.stripExtension ().toStr (sep-> "_")).addExtension (defaults::__OBJECT_EXTENSION__);
        let packageDir = self._cwd.push (defaults::__SRC_DIR__);

        if let Ok (Instant (sec-> d)) = sys::fileDate (depFile)? {
            if d < date {
                sys::removeFile (objFile)?;
                sys::removeFile (depFile)?;
                return (false, []);
            }

            {
                let dmut results : [Path] = [];
                let dmut f = File::open (depFile, read-> true);
                while let line = f:.readUntil ("\n") && line.len > 0 {
                    let currPath = if line [$ - 1] == '\n' {
                        Path (line [0 .. $ - 1])
                    } else {
                        Path (line)
                    };

                    if sourceDir.isPrefix (currPath) {
                        results ~= [currPath.removePrefix (sourceDir)];
                    }

                    else if forUnitTest && packageDir.isPrefix (currPath) {
                        for z in changedSources if packageDir.push (z) == currPath {
                            sys::removeFile (objFile)?;
                            sys::removeFile (depFile)?;
                            return (false, []);
                        }
                    }
                }

                return (true, results);
            } catch {
                _ => {}
            }
        }

        // No dependency file found
        return (false, []);
    }


    /**
     * List the source files that can be found in the directory 'root' (recursively)
     * @params:
     *    - root: the root directory to read
     * @returns: the list of source files
     * */
    prv fn listFilesInDir (self, root : Path, curr : Path)-> [Path] {
        let dmut result : [Path] = [];
        {
            for entry in sys::readDir (curr) {
                match entry {
                    FsEntry (path-> p, kind-> FsEntryKind::DIR) => {
                        result ~= self.listFilesInDir (root, p);
                    }
                    FsEntry (path-> p, kind-> FsEntryKind::FILE) if (p.extension () == defaults::__YMIR_EXTENSION__) => {
                        result ~= [p.removePrefix (root)];
                    }
                }
            }
        } catch {
            _ => {}
        }

        result
    }

    /**
     * Find the root file of the package
     * @returns: the path to the root file of the package
     * */
    prv fn findRootSourceFile (self)-> Path
        throws AssertError
    {
        // Overriden by configuration file
        if let name = self._cfg.packageRoot && name != "" {
            let mainPath = self._cwd.push (defaults::__SRC_DIR__).push (name).addExtension (defaults::__YMIR_EXTENSION__);
            if (!fs::sys::isFile (mainPath)) {
                throw copy AssertError ("No package root file found at " ~ mainPath.toStr ());
            }

            return mainPath;
        }

        // Otherwise searching for default root files __lib__.yr, or package name
        let libPath = self._cwd.push (defaults::__SRC_DIR__).push (self._cfg.name).addExtension (defaults::__YMIR_EXTENSION__);
        if (fs::sys::isFile (libPath)) {
            return libPath;
        }

        let mainPath = self._cwd.push (defaults::__SRC_DIR__).push (defaults::__MAIN_FILE__);
        if (fs::sys::isFile (mainPath)) {
            return mainPath;
        }

        throw copy AssertError ("No package root file, " ~ libPath.toStr () ~ " and " ~ mainPath.toStr () ~ " not found");
    }

    /**
     * Find the root file of the test directory
     * @returns: the path to the root file of unittests
     * */
    prv fn findRootTestFile (self)-> Path
        throws AssertError
    {
        // Overriden by configuration file
        if let name = self._cfg.testRoot && name != "" {
            let mainPath = self._cwd.push (defaults::__TEST_DIR__).push (name).addExtension (defaults::__YMIR_EXTENSION__);
            if (!fs::sys::isFile (mainPath)) {
                throw copy AssertError ("No unittest root file found at " ~ mainPath.toStr ());
            }

            return mainPath;
        }


        // Searching for default root file __test__.yr
        let libPath = self._cwd.push (defaults::__TEST_DIR__).push (defaults::__FST_TEST_FILE__);
        if (fs::sys::isFile (libPath)) {
            return libPath;
        }

        throw copy AssertError ("No unittest root file found at " ~ libPath.toStr ());
    }

    /**
     * Define the output directory of the build
     * */
    prv fn defineOutputDirectory (self)-> Path {
        if let Ok (Bool (value-> _ = true)) = self._args ["release"]? {
            if self._forUnitTest {
                self._cwd.push (defaults::__CACHE_UNIT_RELEASE_DIR__)
            } else {
                self._cwd.push (defaults::__CACHE_RELEASE_DIR__)
            }
        }

        else {
            if self._forUnitTest {
                self._cwd.push (defaults::__CACHE_UNIT_DEBUG_DIR__)
            } else {
                self._cwd.push (defaults::__CACHE_DEBUG_DIR__)
            }
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ================================          CUSTOM COMMANDS          =================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Execute the commands to run before the compilation
     * */
    prv fn runPreCommands (self, dmut context : &GyllirManager) {
        let dmut tzer = Tokenizer!c8 ();
        tzer:.insert (" ", isSkip-> true);
        for _, c in self._cfg.commands [] {
            if !c.isPost () {
                let cmd = tzer.tokenizeWithoutSkips (c.cmd);
                let succ = if (cmd.len > 0) {
                    context.runProcess (cmd [0], cmd [1 .. $], cwd-> self._cwd)
                } else { false };

                if !succ {
                    utils::log::error ("Error", "failed to compile project '", self._cfg.name, "'");
                    etc::c::process::_yrt_exit (-1);
                }
            }
        }
    }

    /**
     * Execute the commands to run after the compilation
     * */
    prv fn runPostCommands (self, dmut context : &GyllirManager) {
        let dmut tzer = Tokenizer!c8 ();
        tzer:.insert (" ", isSkip-> true);
        for _, c in self._cfg.commands [] {
            if c.isPost () {
                let cmd = tzer.tokenizeWithoutSkips (c.cmd);
                let succ = if (cmd.len > 0) {
                    context.runProcess (cmd [0], cmd [1 .. $], cwd-> self._cwd)
                } else { false };

                if !succ {
                    utils::log::error ("Error", "failed to compile project '", self._cfg.name, "'");
                    etc::c::process::_yrt_exit (-1);
                }
            }
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          DEPENDENCIES          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Resolve the dependencies of the package and build them
     * @params:
     *    - context: the context of the compilation
     * @returns:
     *    - .0: the list of root files to include in the compilation
     *    - .1: the list of path to the built libraries to link
     * */
    prv fn resolveDependencies (self, dmut context : &GyllirManager)-> ([Path], [Path])
        throws RecursiveDependency
    {
        let dmut libs : [Path] = [];
        let dmut names : [Path] = [];
        for k, d in self._cfg.dependencies[] {
            let (n, l) = context:.resolveDependency (self._args, self._cwd, k, d, dry-> (self._forDoc || self._dry));
            libs ~= l;
            names ~= n;
        }

        (names, libs)
    }

}
