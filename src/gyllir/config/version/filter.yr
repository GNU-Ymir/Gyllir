in filter;

use std::{config::_, stream};
use std::syntax::tokenizer;
use std::conv::errors;

use gyllir::config::version;

enum : u8
| SUP    = 1
| SUP_EQ = 2
| INF    = 3
| INF_EQ = 4
| EQ     = 5
 ->  FilterKind;

/**
 * A filter the check compatible version
 * */
pub record VersionFilter {

    let mut _filters : [mut (FilterKind, Version)] = [];

    /**
     * Construct a version from a string
     * */
    pub self (filters : [[c8]])
        throws CastFailure
    {
        self:.parseFilters (filters);
    }

    /**
     * Deserialize a version number
     */
    pub self (cfg : &Config)
        throws AssertError, CastFailure
    {
        if let Str (value-> version) = cfg {
            self:.parseFilter (version, self.createTokenizer ());
        }

        else if let a : &Array = cfg {
            self:.parseFilters (a[]);
        }

        else throw copy AssertError ("Version must be a string");
    }

    /**
     * @returns: the version into a string
     */
    pub fn opIndex (self)-> [(FilterKind, Version)] {
        self._filters
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          FILTERING          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Select a version that passes the filter
     * */
    pub fn select (self, versions : [(Version, [c8])])-> (Version, [c8])
        throws AssertError
    {
        let dmut stream = copy StringStream ();
        for i, v in versions {
            let mut found = true;
            for f in self._filters {
                if !self.passFilter (f, v._0) {
                    found = false;
                    break;
                }
            }
                        
            if found return v;
            if (i != 0) stream:.write (", ");
            stream:.write (v._0);
        }

        let dmut msg = copy StringStream ();
        msg:.write ("no version matches the filter ", self, " candidates are [", stream[], "]");        
        throw copy AssertError (msg[]);
    }

    /**
     * Check wether the version passes the filter
     * */
    prv fn passFilter (self, filter : (FilterKind, Version), v : Version)-> bool {
        if filter._1.isIgnore () { return true; }
            
        match filter.0 {
            FilterKind::SUP => {
                return v > filter.1;
            }
            FilterKind::INF => {
                return v < filter.1;
            }
            FilterKind::INF_EQ => {
                return v <= filter.1;
            }
            FilterKind::SUP_EQ => {
                return v >= filter.1;
            }
            _ => {                                            
                return filter._1 == v;
            }
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ======================================          MISC          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Serialize a version filter
     * */
    prv fn serializeFilter (self, filter : (FilterKind, Version))-> &Config {
        let dmut stream = copy StringStream ();
        if !filter._1.isIgnore () { 
            match filter._0 {
                FilterKind::SUP => { stream:.write ('>'); }
                FilterKind::SUP_EQ => { stream:.write (">="); }
                FilterKind::INF => { stream:.write ('<'); }
                FilterKind::INF_EQ => { stream:.write ("<="); }
                FilterKind::EQ => { stream:.write ("="); }
            }
        }

        stream:.write (filter._1);            
        return copy Str (stream[]);
    }   

    impl Hashable;
    impl Streamable {
        pub over toStream (self, dmut stream : &StringStream) {
            stream:.write ('[');
            for i, f in self._filters {
                if !f._1.isIgnore () {
                    match f._0 {
                        FilterKind::SUP => { stream:.write ('>'); }
                        FilterKind::SUP_EQ => { stream:.write (">="); }
                        FilterKind::INF => { stream:.write ('<'); }
                        FilterKind::INF_EQ => { stream:.write ("<="); }
                        FilterKind::EQ => { stream:.write ("="); }
                    }
                }
                stream:.write (f._1);
                if i != 0 { stream:.write (", "); }
            }
            stream:.write (']');
        }
    }

    
    impl Serializable {
        pub over serialize (self)-> &Config {
            if self._filters.len == 1 {
                return self.serializeFilter (self._filters [0]);
            }

            let dmut result = copy Array ();
            for i in self._filters {
                result:.push (self.serializeFilter (i));
            }

            result
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          PRIVATE          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Create a tokenizer to split version filters
     * */
    prv fn createTokenizer (self)-> Tokenizer!{c8} {
        let mut tzer = Tokenizer!{c8} ();
        tzer:.insert ("<");
        tzer:.insert (">");
        tzer:.insert (">=");
        tzer:.insert ("<=");
        tzer:.insert (" ", isSkip-> true);

        tzer
    }

    /**
     * Parse version from string literals
     * */
    prv fn parseFilters (mut self, version : [[c8]])
        throws std::conv::errors::CastFailure
    {
        let tzer = self.createTokenizer ();
        for v in version {
            self:.parseFilter (v, tzer);
        }
    }

    /**
     * Parse version filters from string configs
     * */
    prv fn parseFilters (mut self, version : [&Config])
        throws std::conv::errors::CastFailure
    {
        let tzer = self.createTokenizer ();
        for v in version {
            if let Str (value-> ve) = v {
                self:.parseFilter (ve, tzer);
            }

            else throw copy std::conv::errors::CastFailure (([c8])::__typeinfo__, VersionFilter::__typeinfo__,
                                                            subError-> (copy AssertError ("Version filters must be strings"))?);
        }
    }

    /**
     * Parse a version filter from a string
     * */
    prv fn parseFilter (mut self, version : [c8], tzer : Tokenizer!{c8})
        throws std::conv::errors::CastFailure
    {
        let components = tzer.tokenizeWithoutSkips (version);
        let ver = if components.len == 2 {
            Version (components [1])
        } else if components.len == 1 {
            Version (components [0])
        }  else {
            throw copy std::conv::errors::CastFailure (([c8])::__typeinfo__, VersionFilter::__typeinfo__,
                                                       subError-> (copy AssertError ("malformed version filter " ~ version))?);
        };


        if (components.len == 2) {
            if !ver.isNumbered () {
                throw copy std::conv::errors::CastFailure (([c8])::__typeinfo__, VersionFilter::__typeinfo__,
                                                           subError-> (copy AssertError ("version order filter only applies on numbered versions not " ~ version))?);
            }

            let kind = match components [0] {
                ">" => { FilterKind::SUP }
                "<" => { FilterKind::INF }
                "<=" => { FilterKind::INF_EQ }
                ">=" => { FilterKind::SUP_EQ }
                _ => {
                    throw copy std::conv::errors::CastFailure (([c8])::__typeinfo__, VersionFilter::__typeinfo__,
                                                               subError-> (copy AssertError ("malformed version filter " ~ version))?);
                }
            }

            self._filters ~= [(kind, ver)];
        } else {
            self._filters ~= [(FilterKind::EQ, ver)];
        }
    }

}
