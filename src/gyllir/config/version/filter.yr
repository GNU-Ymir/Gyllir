in filter;

use std::{config::_, stream};
use std::syntax::tokenizer;
use std::conv::errors;

use gyllir::config::version;

enum : u8
| SUP = 1
| SUP_EQ = 2
| INF = 3
| INF_EQ = 4
| EQ  = 5
 ->  FilterKind;

/**
 * A filter the check compatible version
 * */
pub record VersionFilter {

    let mut _filters : [mut (FilterKind, Version)] = [];

    /**
     * Construct a version from a string
     * */
    pub self (filters : [[c8]])
        throws CastFailure
    {
        self:.parseFilters (filters);
    }

    /**
     * Deserialize a version number
     */
    pub self (cfg : &Config)
        throws AssertError, CastFailure
    {
        if let Str (value-> version) = cfg {
            self:.parseFilter (version, self.createTokenizer ());
        }

        else if let a : &Array = cfg {
            self:.parseFilters (a[]);
        }

        else throw copy AssertError ("Version must be a string");
    }

    /**
     * @returns: the version into a string
     */
    pub fn opIndex (self)-> [(FilterKind, Version)] {
        self._filters
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          FILTERING          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Select a version that passes the filter
     * */
    pub fn select (self, versions : [Version])-> Version
        throws AssertError
    {
        let dmut stream = copy StringStream ();
        for i, v in versions {
            let mut found = true;
            for f in self._filters {
                if !self.passFilter (f, v) {
                    found = false;
                    break;
                }
            }

            if found return v;

            if (i != 0) stream:.write (", ");
            stream:.write (v[]);
        }

        throw copy AssertError ("No version matches the filter, candidates are [" ~ stream[] ~ "]");
    }

    /**
     * Check wether the version passes the filter
     * */
    prv fn passFilter (self, filter : (FilterKind, Version), v : Version)-> bool {
        match filter.0 {
            FilterKind::SUP => {
                return v > filter.1;
            }
            FilterKind::INF => {
                return v < filter.1;
            }
            FilterKind::INF_EQ => {
                return v <= filter.1;
            }
            FilterKind::SUP_EQ => {
                return v >= filter.1;
            }
            _ => {
                if (filter.1[]) == "*" return true;
                else return filter.1 == v;
            }
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ======================================          MISC          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Serialize a version filter
     * */
    prv fn serializeFilter (self, filter : (FilterKind, Version))-> &Config {
        if (filter.0 == FilterKind::SUP) {
            return copy Str (">" ~ (filter.1)[]);
        }

        else if (filter.0 == FilterKind::INF) {
            return copy Str (">" ~ (filter.1)[]);
        }

        return copy Str ((filter.1)[]);
    }

    impl Hashable;
    impl Streamable;
    impl Serializable {
        pub over serialize (self)-> &Config {
            if self._filters.len == 1 {
                return self.serializeFilter (self._filters [0]);
            }

            let dmut result = copy Array ();
            for i in self._filters {
                result:.push (self.serializeFilter (i));
            }

            result
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          PRIVATE          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Create a tokenizer to split version filters
     * */
    prv fn createTokenizer (self)-> Tokenizer!{c8} {
        let mut tzer = Tokenizer!{c8} ();
        tzer:.insert ("<");
        tzer:.insert (">");
        tzer:.insert (">=");
        tzer:.insert ("<=");
        tzer:.insert (" ", isSkip-> true);

        tzer
    }

    /**
     * Parse version from string literals
     * */
    prv fn parseFilters (mut self, version : [[c8]])
        throws std::conv::errors::CastFailure
    {
        let tzer = self.createTokenizer ();
        for v in version {
            self:.parseFilter (v, tzer);
        }
    }

    /**
     * Parse version filters from string configs
     * */
    prv fn parseFilters (mut self, version : [&Config])
        throws std::conv::errors::CastFailure
    {
        let tzer = self.createTokenizer ();
        for v in version {
            if let Str (value-> ve) = v {
                self:.parseFilter (ve, tzer);
            }

            else throw copy std::conv::errors::CastFailure (([c8])::__typeinfo__, VersionFilter::__typeinfo__,
                                                            subError-> (copy AssertError ("Version filters must be strings"))?);
        }
    }

    /**
     * Parse a version filter from a string
     * */
    prv fn parseFilter (mut self, version : [c8], tzer : Tokenizer!{c8})
        throws std::conv::errors::CastFailure
    {
        let components = tzer.tokenizeWithoutSkips (version);
        let ver = if components.len == 2 {
            Version (components [1])
        } else if components.len == 1 {
            Version (components [0])
        }  else {
            throw copy std::conv::errors::CastFailure (([c8])::__typeinfo__, VersionFilter::__typeinfo__,
                                                       subError-> (copy AssertError ("malformed version filter " ~ version))?);
        };


        if (components.len == 2) {
            if !ver.isNumbered () {
                throw copy std::conv::errors::CastFailure (([c8])::__typeinfo__, VersionFilter::__typeinfo__,
                                                           subError-> (copy AssertError ("version order filter only applies on numbered versions not " ~ version))?);
            }

            let kind = match components [0] {
                ">" => { FilterKind::SUP }
                "<" => { FilterKind::INF }
                "<=" => { FilterKind::INF_EQ }
                ">=" => { FilterKind::SUP_EQ }
                _ => {
                    throw copy std::conv::errors::CastFailure (([c8])::__typeinfo__, VersionFilter::__typeinfo__,
                                                               subError-> (copy AssertError ("malformed version filter " ~ version))?);
                }
            }

            self._filters ~= [(kind, ver)];
        } else {
            self._filters ~= [(FilterKind::EQ, ver)];
        }
    }

}
