in version;

use std::{config::_, stream};
use std::syntax::tokenizer;
use std::conv::errors;

pub mod ::filter;

/**
 * A version is a serializable record containing three elements:
 * Major version, Minor version and Patch version
 */
pub record Version {

    // True iif version is indifferent 
    let mut _all : bool = false;
    
    // True iif this is a numbered version
    let mut _numbered : bool = false;

    // The numbers of the verseion (applicable iif self._numbered)
    let dmut _numbers : [u32 ; 3] = [0 ; 3];

    // The name of the version (applicable iif !self._numbered)
    let mut _name : [c8] = [];

    /**
     * Version from numbers
     * */
    pub self (major : u32, minor : u32, patch : u32)
        with _numbers = [major, minor, patch]
        , _numbered = true
    {}

    /**
     * Construct a version from a string
     * */
    pub self (version : [c8]) {
        self:.parseVersion (version);
    }

    /**
     * All version 
     * */
    pub self ignore ()
        with _all = true
    {}

    /**
     * Deserialize a version from config
     * */
    pub self (cfg : &Config)
        throws AssertError
    {
        if let Str (value-> version) = cfg {
            self:.parseVersion (version);
        }

        else throw copy AssertError ("version must be a string");
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          UTILS          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Increment the version
     */
    pub fn increment (self, major : bool, minor : bool)-> Version {
        if (!self._numbered) return self;
        if minor {
            return Version (self.major, self.minor + 1u32, 0u32);
        }

        else if major {
            return Version (self.major + 1u32, 0u32, 0u32);
        }

        // by default it is a patch
        return Version (self.major, self.minor, self.patch + 1u32);
    }

    /**
     * @returns: the version into a string
     */
    pub fn opIndex (self)-> [c8] {
        if self._all { return "*"; }
        if (!self._numbered) return self._name;

        let dmut str = copy StringStream ();
        str:.write (self.major)
            :.write (".")
            :.write (self.minor)
            :.write (".")
            :.write (self.patch);

        str[]
    }

    /**
     * @returns: true if this is a numbered version
     * */
    pub fn isNumbered (self)-> bool {
        self._numbered
    }

    @field
    pub fn major (self)-> u32 {
        self._numbers [0]
    }

    @field
    pub fn minor (self)-> u32 {
        self._numbers [1]
    }

    @field
    pub fn patch (self)-> u32 {
        self._numbers [2]
    }

    /**
     * @returns: true if we ignore the version
     * */
    pub fn isIgnore (self)-> bool {
        self._all
    }
    
    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          COMPARISON          ===================================
     * ====================================================================================================
     * ====================================================================================================
     */


    pub fn opEquals (self, o : Version)-> bool {        
        if (self._numbered != o._numbered) return false;
        if self._numbered {
            return self._numbers == o._numbers;
        }

        else return self._name == o._name;
    }

    pub fn opCmp (self, o : Version)-> i32 {
        if self.opEquals (o) {
            return 0;
        }
        
        if self.major > o.major return 1;
        else if self.major < o.major return -1;

        if self.minor > o.minor return 1;
        else if self.minor < o.minor return -1;

        if self.patch > o.patch return 1;
        else if self.patch < o.patch return -1;

        return 0;
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ======================================          MISC          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    impl Hashable;
    impl Streamable {
        pub over toStream (self, dmut stream : &StringStream) {
            stream:.write (self[]);
        }
    }

    impl Serializable {
        pub over serialize (self)-> &Config {
            if (!self._numbered) return copy Str (self._name);

            let dmut stream = copy StringStream ();
            stream:.write (self.major, ".", self.minor, ".", self.patch);
            return copy Str (stream []);
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          PRIVATE          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Parse the version from the string
     * */
    prv fn parseVersion (mut self, version : [c8]) {
        if version == "*" {
            self._all = true;
            return;
        }
        
        let dmut tzer = Tokenizer!{c8} ();
        tzer:.insert (".", isSkip-> true);

        let components = tzer.tokenizeWithoutSkips (version);
        if components.len != 2 && components.len != 3 {
            self._numbered = false;            
            self._name = version;
            return;
        }

        {
            self._numbered = true;
            if (components [0].len > 1 && components [0][0] == 'v') { // numbered version can be written as v1.0.0 (e.g. for git tags)
                self._numbers [0] = std::conv::to!{u32} (components [0][1 .. $]);
            } else self._numbers [0] = std::conv::to!{u32} (components [0]);

            self._numbers [1] = std::conv::to!{u32} (components [1]);

            if components.len == 3 {
                self._numbers [2] = std::conv::to!{u32} (components [2]);
            }
        } catch {
            _ => {
                self._numbered = false;
                self._name = version;
            }

        }
    }
}
