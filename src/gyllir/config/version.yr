mod gyllir::config::version;

import std::config;
import std::config::conv;
import std::config::error;
import std::collection::map;
import std::io;
import std::tokenizer;
import std::config::conv;
import std::conv;


/**
 * A version is a serializable class containing three elements:
 * Major version, Minor version and Patch version
 */
pub class Version {    

    let mut _major : u32 = 0u32;
    let mut _minor : u32 = 1u32;
    let mut _patch : u32 = 0u32;
    
    pub self () {}

    /**
     * Deserialize a version number
     */
    pub self (cfg : &Config) throws &AssertError
    {
        match cfg {
            Str (str->  version: _) => {
                let tzer = Tokenizer::new (tokens-> ["."])
                let res = tzer.tokenize (version);
                {
                    let major = (res[0].to!u32())? // on catch Ã  la fois, OutOfArray et CastFailure
                    let minor = (res[2].to!u32())?
                    let patch = (res[4].to!u32())?
                    self._major = match major {
                        Ok (a : u32) => { a }
                        Err (_ : &OutOfArray) => { throw AssertError::new ("need a major version") }
                        Err (_ : &CastFailure) => { throw AssertError::new ("Invalid major number") }
                        _  => { 0u32 }
                    }
                    
                    self._minor = match minor {
                        Ok (b: u32) => { b }
                        Err (_ : &CastFailure) => { throw AssertError::new ("Invalid minor number") }
                        _  => { 0u32 } 
                    }
                    
                    self._patch = match patch {
                        Ok (c : u32) => { c }
                        Err (_ : &CastFailure) => { throw AssertError::new ("Invalid patch number") }
                        _  => { 0u32 } 
                    };
                } catch {
                    _ => {
                        println ("invalid version number");
                    }
                }                
            }
            _ => {
                assert (false, "version must be a string");
            }
        }            
    }
    
    impl Streamable;

    impl std::config::conv::Serializable {

        /**
         * Transform the version into a configuration string
         */
        pub over serialize (self)-> &Config {
            import std::stream;
            let dmut stream = StringStream::new ();
            stream:.write (self._major, ".", self._minor, ".", self._patch);
            return stream [].to!{&Config} ();
        }
    }
}
